[
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "has_close_elements",
      "arguments": [
        "numbers",
        "threshold"
      ],
      "docstring": {
        "description": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.",
        "examples": [
          ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse",
          ">>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
        ]
      },
      "template": "def {{ has_close_elements }}({{ numbers }}: List[float], {{ threshold }}: float) -> bool:\n    for ({{ idx }}, {{ elem }}) in enumerate({{ numbers }}):\n        for ({{ idx2 }}, {{ elem2 }}) in enumerate({{ numbers }}):\n            if {{ idx }} != {{ idx2 }}:\n                {{ distance }} = abs({{ elem }} - {{ elem2 }})\n                if {{ distance }} < {{ threshold }}:\n                    return True\n    return False",
      "placeholders": [
        "threshold",
        "distance",
        "has_close_elements",
        "elem",
        "numbers",
        "idx",
        "idx2",
        "elem2"
      ]
    },
    "target_function": {
      "name": "has_close_elements_in_array",
      "arguments": [
        "array",
        "threshold"
      ],
      "docstring": {
        "description": "Check if in given array, are any two numbers closer to each other than given threshold.",
        "examples": [
          ">>> has_close_elements_in_array([[1.0, 2.0, 3.0], [1.0, 2.0, 3.0]], 0.5)\nTrue",
          ">>> has_close_elements_in_array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], 0.3)\nFalse"
        ]
      },
      "template": "def {{ has_close_elements_in_array }}({{ array }}: List[List[float]], {{ threshold }}: float) -> bool:\n    return {{ has_close_elements }}([{{ item }} for {{ sublist }} in {{ array }} for {{ item }} in {{ sublist }}], {{ threshold }})",
      "placeholders": [
        "array",
        "threshold",
        "has_close_elements_in_array",
        "item",
        "sublist",
        "has_close_elements"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[2.0, 3.0, 1.0], [100.0, 101.0, 17.8]], 2.2) is True\n    assert candidate([[31.0, 22.7, 38.8], [34.8, 14.8, 22.5]], 0.5) is True\n    assert candidate([[1.0, 2.1, 1.6], [2.4, 2.7, 1.3]], 0.2) is False\n\ndef test_check():\n    check(has_close_elements_in_array)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Any",
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "separate_paren_groups",
      "arguments": [
        "paren_string"
      ],
      "docstring": {
        "description": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.",
        "examples": [
          ">>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']"
        ]
      },
      "template": "def {{ separate_paren_groups }}({{ paren_string }}: str) -> List[str]:\n    {{ result }} = []\n    {{ current_string }} = []\n    {{ current_depth }} = 0\n    for {{ c }} in {{ paren_string }}:\n        if {{ c }} == '(':\n            {{ current_depth }} += 1\n            {{ current_string }}.append({{ c }})\n        elif {{ c }} == ')':\n            {{ current_depth }} -= 1\n            {{ current_string }}.append({{ c }})\n            if {{ current_depth }} == 0:\n                {{ result }}.append(''.join({{ current_string }}))\n                {{ current_string }}.clear()\n    return {{ result }}",
      "placeholders": [
        "current_string",
        "c",
        "current_depth",
        "paren_string",
        "result",
        "separate_paren_groups"
      ]
    },
    "target_function": {
      "name": "nested_separate_paren_groups",
      "arguments": [
        "paren_string"
      ],
      "docstring": {
        "description": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nDifferent from separate_paren_groups, you have to recursively separate a group into subgroups if it is nested.\nSeparate groups are balanced (each open brace is properly closed) and nested within each other\nIgnore any spaces in the input string.",
        "examples": [
          ">>> nested_separate_paren_groups('( ) (( )) (( )( ))')\n['()', ['()'], ['()', '()']]"
        ]
      },
      "template": "def {{ nested_separate_paren_groups }}({{ paren_string }}: str) -> Any:\n    print({{ paren_string }})\n    {{ groups }} = {{ separate_paren_groups }}({{ paren_string }})\n    for {{ idx }} in range(len({{ groups }})):\n        if {{ groups }}[{{ idx }}] == '()':\n            continue\n        else:\n            {{ groups }}[{{ idx }}] = {{ nested_separate_paren_groups }}({{ groups }}[{{ idx }}][1:-1])\n    return {{ groups }}",
      "placeholders": [
        "paren_string",
        "nested_separate_paren_groups",
        "idx",
        "separate_paren_groups",
        "groups"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('(()(()))()()') == [['()', ['()']], '()', '()']\n    assert candidate('((((()))))') == [[[[['()']]]]]\n    assert candidate('()((()())())()(())') == ['()', [['()', '()'], '()'], '()', ['()']]\n\ndef test_check():\n    check(nested_separate_paren_groups)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "truncate_number",
      "arguments": [
        "number"
      ],
      "docstring": {
        "description": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.",
        "examples": [
          ">>> truncate_number(3.5)\n0.5"
        ]
      },
      "template": "def {{ truncate_number }}({{ number }}: float) -> float:\n    return {{ number }} % 1.0",
      "placeholders": [
        "truncate_number",
        "number"
      ]
    },
    "target_function": {
      "name": "is_number_rounded_up",
      "arguments": [
        "number"
      ],
      "docstring": {
        "description": "Given a positive floating point number, return True if the number is\nrounded up, False otherwise.",
        "examples": [
          ">>> is_number_rounded_up(3.5)\nTrue",
          ">>> is_number_rounded_up(3.4)\nFalse"
        ]
      },
      "template": "def {{ is_number_rounded_up }}({{ number }}: float) -> bool:\n    return {{ truncate_number }}({{ number }}) >= 0.5",
      "placeholders": [
        "is_number_rounded_up",
        "number",
        "truncate_number"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(4.2) is False\n    assert candidate(3.141592) is False\n    assert candidate(19.865) is True\n    assert candidate(1.501) is True\n\ndef test_check():\n    check(is_number_rounded_up)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "below_zero",
      "arguments": [
        "operations"
      ],
      "docstring": {
        "description": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.",
        "examples": [
          ">>> below_zero([1, 2, 3])\nFalse",
          ">>> below_zero([1, 2, -4, 5])\nTrue"
        ]
      },
      "template": "def {{ below_zero }}({{ operations }}: List[int]) -> bool:\n    {{ balance }} = 0\n    for {{ op }} in {{ operations }}:\n        {{ balance }} += {{ op }}\n        if {{ balance }} < 0:\n            return True\n    return False",
      "placeholders": [
        "operations",
        "below_zero",
        "op",
        "balance"
      ]
    },
    "target_function": {
      "name": "below_zero_with_initial_value",
      "arguments": [
        "operations",
        "initial"
      ],
      "docstring": {
        "description": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nnon-negative initial balance. Your task is to detect if at any point the balance of account fallls\nbelow zero, and at that point function should return True. Otherwise it should return False.",
        "examples": [
          ">>> below_zero_with_initial_value([1, 2, 3], 0)\nFalse",
          ">>> below_zero_with_initial_value([1, 2, -4, 5], 3)\nFalse"
        ]
      },
      "template": "def {{ below_zero_with_initial_value }}({{ operations }}: List[int], {{ initial }}: int) -> bool:\n    return {{ below_zero }}([{{ initial }}] + {{ operations }})",
      "placeholders": [
        "operations",
        "below_zero_with_initial_value",
        "below_zero",
        "initial"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([3, -15, 4, 2, 1], 14) is False\n    assert candidate([-2, -3, -4, -5], 14) is False\n    assert candidate([2, -4, 3], 1) is True\n    assert candidate([1, 2, -4, 5], 0) is True\n\ndef test_check():\n    check(below_zero_with_initial_value)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "mean_absolute_deviation",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |",
        "examples": [
          ">>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0"
        ]
      },
      "template": "def {{ mean_absolute_deviation }}({{ numbers }}: List[float]) -> float:\n    {{ mean }} = sum({{ numbers }}) / len({{ numbers }})\n    return sum((abs({{ x }} - {{ mean }}) for {{ x }} in {{ numbers }})) / len({{ numbers }})",
      "placeholders": [
        "mean_absolute_deviation",
        "numbers",
        "mean",
        "x"
      ]
    },
    "target_function": {
      "name": "find_outlier",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "For a given list of input numbers, find the outlier.\nOutliers are defined as data whose distance from the mean is greater than\nthe mean absolute deviation.\nThe order of the outliers in the output list should be the same as in the input list.",
        "examples": [
          ">>> find_outlier([1.0, 2.0, 3.0, 4.0])\n[1.0, 4.0]"
        ]
      },
      "template": "def {{ find_outlier }}({{ numbers }}: List[float]) -> List[float]:\n    {{ mean }} = sum({{ numbers }}) / len({{ numbers }})\n    {{ mae }} = {{ mean_absolute_deviation }}({{ numbers }})\n    return [{{ number }} for {{ number }} in {{ numbers }} if abs({{ number }} - {{ mean }}) > {{ mae }}]",
      "placeholders": [
        "find_outlier",
        "mae",
        "mean_absolute_deviation",
        "number",
        "numbers",
        "mean"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([3.0, 2.0, 1.0, 4.0]) == [1.0, 4.0]\n    assert candidate([1.0, 5.0]) == []\n    assert candidate([-5.0, 1.0, 0.0, 1.0]) == [-5.0]\n    assert candidate([1, 2, -4, 5]) == [-4, 5]\n\ndef test_check():\n    check(find_outlier)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "intersperse",
      "arguments": [
        "numbers",
        "delimeter"
      ],
      "docstring": {
        "description": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'",
        "examples": [
          ">>> intersperse([], 4)\n[]",
          ">>> intersperse([1, 2, 3], 4)\n[1, 4, 2, 4, 3]"
        ]
      },
      "template": "def {{ intersperse }}({{ numbers }}: List[int], {{ delimeter }}: int) -> List[int]:\n    if not {{ numbers }}:\n        return []\n    {{ result }} = []\n    for {{ n }} in {{ numbers }}[:-1]:\n        {{ result }}.append({{ n }})\n        {{ result }}.append({{ delimeter }})\n    {{ result }}.append({{ numbers }}[-1])\n    return {{ result }}",
      "placeholders": [
        "intersperse",
        "numbers",
        "result",
        "n",
        "delimeter"
      ]
    },
    "target_function": {
      "name": "intersperse_with_start_end",
      "arguments": [
        "numbers",
        "delimeter"
      ],
      "docstring": {
        "description": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\nand also add 'delimeter' at the beginning and end of the list.",
        "examples": [
          ">>> intersperse_with_start_end([], 4)\n[4, 4]",
          ">>> intersperse_with_start_end([1, 2, 3], 4)\n[4, 1, 4, 2, 4, 3, 4]"
        ]
      },
      "template": "def {{ intersperse_with_start_end }}({{ numbers }}: List[int], {{ delimeter }}: int) -> List[int]:\n    return [{{ delimeter }}] + {{ intersperse }}({{ numbers }}, {{ delimeter }}) + [{{ delimeter }}]",
      "placeholders": [
        "intersperse",
        "numbers",
        "intersperse_with_start_end",
        "delimeter"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([], 100) == [100, 100]\n    assert candidate([7, 7, 7], 1) == [1, 7, 1, 7, 1, 7, 1]\n    assert candidate([3, 6, 9, 12, 15], 6) == [6, 3, 6, 6, 6, 9, 6, 12, 6, 15, 6]\n    assert candidate([7, 5, 3, 2], 1) == [1, 7, 1, 5, 1, 3, 1, 2, 1]\n    assert candidate([101, 100, 98, 95], 100) == [100, 101, 100, 100, 100, 98, 100, 95, 100]\n\ndef test_check():\n    check(intersperse_with_start_end)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "parse_nested_parens",
      "arguments": [
        "paren_string"
      ],
      "docstring": {
        "description": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.",
        "examples": [
          ">>> parse_nested_parens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]"
        ]
      },
      "template": "def {{ parse_nested_parens }}({{ paren_string }}: str) -> List[int]:\n\n    def {{ parse_paren_group }}({{ s }}):\n        {{ depth }} = 0\n        {{ max_depth }} = 0\n        for {{ c }} in {{ s }}:\n            if {{ c }} == '(':\n                {{ depth }} += 1\n                {{ max_depth }} = max({{ depth }}, {{ max_depth }})\n            else:\n                {{ depth }} -= 1\n        return {{ max_depth }}\n    return [{{ parse_paren_group }}({{ x }}) for {{ x }} in {{ paren_string }}.split(' ') if {{ x }}]",
      "placeholders": [
        "depth",
        "c",
        "parse_nested_parens",
        "paren_string",
        "s",
        "max_depth",
        "parse_paren_group",
        "x"
      ]
    },
    "target_function": {
      "name": "remove_nested_parens",
      "arguments": [
        "paren_string"
      ],
      "docstring": {
        "description": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFilter out the group whose deepest level of nesting of parentheses is greater than 2.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.",
        "examples": [
          ">>> remove_nested_parens('(()()) ((())) () ((())()())')\n'(()()) ()'"
        ]
      },
      "template": "def {{ remove_nested_parens }}({{ paren_string }}: str) -> str:\n    {{ depths }} = {{ parse_nested_parens }}({{ paren_string }})\n    return ' '.join(({{ group }} for ({{ group }}, {{ depth }}) in zip({{ paren_string }}.split(), {{ depths }}) if {{ depth }} <= 2))",
      "placeholders": [
        "parse_nested_parens",
        "depth",
        "remove_nested_parens",
        "paren_string",
        "depths",
        "group"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('(()) () ()') == '(()) () ()'\n    assert candidate('((())) ((()))') == ''\n    assert candidate('() (()()) () ((())())') == '() (()()) ()'\n    assert candidate('(()) (()) (())') == '(()) (()) (())'\n    assert candidate('(()()()()) (()()()) (()()) (())') == '(()()()()) (()()()) (()()) (())'\n\ndef test_check():\n    check(remove_nested_parens)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "filter_by_substring",
      "arguments": [
        "strings",
        "substring"
      ],
      "docstring": {
        "description": "Filter an input list of strings only for ones that contain given substring",
        "examples": [
          ">>> filter_by_substring([], 'a')\n[]",
          ">>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd', 'array']"
        ]
      },
      "template": "def {{ filter_by_substring }}({{ strings }}: List[str], {{ substring }}: str) -> List[str]:\n    return [{{ x }} for {{ x }} in {{ strings }} if {{ substring }} in {{ x }}]",
      "placeholders": [
        "filter_by_substring",
        "x",
        "substring",
        "strings"
      ]
    },
    "target_function": {
      "name": "filter_by_substrings",
      "arguments": [
        "strings",
        "substrings"
      ],
      "docstring": {
        "description": "Filter an input list of strings only for ones that contain all of given substrings",
        "examples": [
          ">>> filter_by_substrings([], ['a', 'b'])\n[]",
          ">>> filter_by_substrings(['abc', 'bacd', 'cde', 'array'], ['a', 'b'])\n['abc', 'bacd']"
        ]
      },
      "template": "def {{ filter_by_substrings }}({{ strings }}: List[str], {{ substrings }}: List[str]) -> List[str]:\n    for {{ substring }} in {{ substrings }}:\n        {{ strings }} = {{ filter_by_substring }}({{ strings }}, {{ substring }})\n    return {{ strings }}",
      "placeholders": [
        "filter_by_substring",
        "filter_by_substrings",
        "substring",
        "strings",
        "substrings"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['prefix', 'suffix', 'infix'], ['fix', 'pre']) == ['prefix']\n    assert candidate(['prefix', 'suffix', 'infix'], ['fix', 'pre', 'in']) == []\n    assert candidate(['hot', 'cold', 'warm'], ['o']) == ['hot', 'cold']\n    assert candidate(['abcdef', 'aboekxdeji', 'abekfj'], ['ab', 'de']) == ['abcdef', 'aboekxdeji']\n\ndef test_check():\n    check(filter_by_substrings)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "sum_product",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\nEmpty sum should be equal to 0 and empty product should be equal to 1.",
        "examples": [
          ">>> sum_product([])\n(0, 1)",
          ">>> sum_product([1, 2, 3, 4])\n(10, 24)"
        ]
      },
      "template": "def {{ sum_product }}({{ numbers }}: List[int]) -> Tuple[int, int]:\n    {{ sum_value }} = 0\n    {{ prod_value }} = 1\n    for {{ n }} in {{ numbers }}:\n        {{ sum_value }} += {{ n }}\n        {{ prod_value }} *= {{ n }}\n    return ({{ sum_value }}, {{ prod_value }})",
      "placeholders": [
        "prod_value",
        "sum_product",
        "numbers",
        "n",
        "sum_value"
      ]
    },
    "target_function": {
      "name": "product_sum",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "For a given list of integers, return a tuple consisting of a product and a sum of all the integers in a list.\nEmpty sum should be equal to 0 and empty product should be equal to 1.",
        "examples": [
          ">>> product_sum([])\n(1, 0)",
          ">>> product_sum([1, 2, 3, 4])\n(24, 10)"
        ]
      },
      "template": "def {{ product_sum }}({{ numbers }}: List[int]) -> Tuple[int, int]:\n    ({{ s }}, {{ p }}) = {{ sum_product }}({{ numbers }})\n    return ({{ p }}, {{ s }})",
      "placeholders": [
        "p",
        "s",
        "sum_product",
        "numbers",
        "product_sum"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([]) == (1, 0)\n    assert candidate([4, 3, 0, 8]) == (0, 15)\n    assert candidate([9, 2]) == (18, 11)\n    assert candidate([100, 101, 102]) == (1030200, 303)\n\ndef test_check():\n    check(product_sum)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "rolling_max",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.",
        "examples": [
          ">>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]"
        ]
      },
      "template": "def {{ rolling_max }}({{ numbers }}: List[int]) -> List[int]:\n    {{ running_max }} = None\n    {{ result }} = []\n    for {{ n }} in {{ numbers }}:\n        if {{ running_max }} is None:\n            {{ running_max }} = {{ n }}\n        else:\n            {{ running_max }} = max({{ running_max }}, {{ n }})\n        {{ result }}.append({{ running_max }})\n    return {{ result }}",
      "placeholders": [
        "running_max",
        "numbers",
        "result",
        "n",
        "rolling_max"
      ]
    },
    "target_function": {
      "name": "rolling_max_with_initial_value",
      "arguments": [
        "numbers",
        "initial"
      ],
      "docstring": {
        "description": "From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence. Additionally, the maximum value starts with `initial`.",
        "examples": [
          ">>> rolling_max_with_initial_value([1, 2, 3, 2, 3, 4, 2], 3)\n[3, 3, 3, 3, 3, 4, 4]"
        ]
      },
      "template": "def {{ rolling_max_with_initial_value }}({{ numbers }}: List[int], {{ initial }}: int) -> List[int]:\n    return {{ rolling_max }}([{{ initial }}] + {{ numbers }})[1:]",
      "placeholders": [
        "rolling_max_with_initial_value",
        "numbers",
        "rolling_max",
        "initial"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([2, 4, 3, 2, 3, 2, 5, 4, 6], 3) == [3, 4, 4, 4, 4, 4, 5, 5, 6]\n    assert candidate([8, 3, 5, 9, 9, 11, 6, 4], 13) == [13, 13, 13, 13, 13, 13, 13, 13]\n    assert candidate([2, 2, 3, 7], 1) == [2, 2, 3, 7]\n    assert candidate([72, 74, 75, 76], 74) == [74, 74, 75, 76]\n\ndef test_check():\n    check(rolling_max_with_initial_value)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "make_palindrome",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Find the shortest palindrome that begins with a supplied string.\nAlgorithm idea is simple:\n- Find the longest postfix of supplied string that is a palindrome.\n- Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.",
        "examples": [
          ">>> make_palindrome('')\n''",
          ">>> make_palindrome('cat')\n'catac'",
          ">>> make_palindrome('cata')\n'catac'"
        ]
      },
      "template": "def {{ make_palindrome }}({{ string }}: str) -> str:\n\n    def {{ is_palindrome }}({{ string }}: str) -> bool:\n        return {{ string }} == {{ string }}[::-1]\n    if not {{ string }}:\n        return ''\n    {{ beginning_of_suffix }} = 0\n    while not {{ is_palindrome }}({{ string }}[{{ beginning_of_suffix }}:]):\n        {{ beginning_of_suffix }} += 1\n    return {{ string }} + {{ string }}[:{{ beginning_of_suffix }}][::-1]",
      "placeholders": [
        "string",
        "is_palindrome",
        "beginning_of_suffix",
        "make_palindrome"
      ]
    },
    "target_function": {
      "name": "find_shortest_palindrome_prefix",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Find the shortest prefix that generates the same shortest palindrome that\nbegins with the supplied string.",
        "examples": [
          ">>> find_shortest_palindrome_prefix('')\n''",
          ">>> find_shortest_palindrome_prefix('cat')\n'cat'",
          ">>> find_shortest_palindrome_prefix('cata')\n'cat'"
        ]
      },
      "template": "def {{ find_shortest_palindrome_prefix }}({{ string }}: str) -> str:\n    if len({{ string }}) == 0 or len({{ string }}) == 1:\n        return {{ string }}\n    {{ p }} = {{ make_palindrome }}({{ string }})\n    for {{ idx }} in range(len({{ string }}) - 1, 0, -1):\n        if {{ p }} != {{ make_palindrome }}({{ string }}[:{{ idx }}]):\n            return {{ string }}[:{{ idx }} + 1]",
      "placeholders": [
        "string",
        "p",
        "make_palindrome",
        "idx",
        "find_shortest_palindrome_prefix"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('owienfh') == 'owienfh'\n    assert candidate('abcdedcb') == 'abcde'\n    assert candidate('abababa') == 'ababab'\n\ndef test_check():\n    check(find_shortest_palindrome_prefix)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "string_xor",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Input are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.",
        "examples": [
          ">>> string_xor('010', '110')\n'100'"
        ]
      },
      "template": "def {{ string_xor }}({{ a }}: str, {{ b }}: str) -> str:\n\n    def {{ xor }}({{ i }}, {{ j }}):\n        if {{ i }} == {{ j }}:\n            return '0'\n        else:\n            return '1'\n    return ''.join(({{ xor }}({{ x }}, {{ y }}) for ({{ x }}, {{ y }}) in zip({{ a }}, {{ b }})))",
      "placeholders": [
        "i",
        "a",
        "x",
        "y",
        "xor",
        "b",
        "string_xor",
        "j"
      ]
    },
    "target_function": {
      "name": "string_xor_three",
      "arguments": [
        "a",
        "b",
        "c"
      ],
      "docstring": {
        "description": "Input are three strings a, b, and c consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.",
        "examples": [
          ">>> string_xor('010', '110', '001')\n'101'"
        ]
      },
      "template": "def {{ string_xor_three }}({{ a }}: str, {{ b }}: str, {{ c }}: str) -> str:\n    return {{ string_xor }}({{ string_xor }}({{ a }}, {{ b }}), {{ c }})",
      "placeholders": [
        "c",
        "a",
        "b",
        "string_xor_three",
        "string_xor"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('000', '101', '110') == '011'\n    assert candidate('1100', '1011', '1111') == '1000'\n    assert candidate('010', '110', '100') == '000'\n\ndef test_check():\n    check(string_xor_three)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Optional"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "longest",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Out of list of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input list is empty.",
        "examples": [
          ">>> longest([])\n",
          ">>> longest(['a', 'b', 'c'])\n'a'",
          ">>> longest(['a', 'bb', 'ccc'])\n'ccc'"
        ]
      },
      "template": "def {{ longest }}({{ strings }}: List[str]) -> Optional[str]:\n    if not {{ strings }}:\n        return None\n    {{ maxlen }} = max((len({{ x }}) for {{ x }} in {{ strings }}))\n    for {{ s }} in {{ strings }}:\n        if len({{ s }}) == {{ maxlen }}:\n            return {{ s }}",
      "placeholders": [
        "x",
        "s",
        "strings",
        "maxlen",
        "longest"
      ]
    },
    "target_function": {
      "name": "second_longest",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Out of list of strings, return the second longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input list doesn't have the second longest elements.",
        "examples": [
          ">>> second_longest([])\nNone",
          ">>> second_longest(['a', 'b', 'c'])\nNone",
          ">>> second_longest(['a', 'bb', 'ccc'])\n'bb'"
        ]
      },
      "template": "def {{ second_longest }}({{ strings }}: List[str]) -> Optional[str]:\n    {{ longest_string }} = {{ longest }}({{ strings }})\n    if {{ longest_string }} is None:\n        return None\n    {{ strings }} = [string for string in {{ strings }} if len(string) < len({{ longest_string }})]\n    return {{ longest }}({{ strings }})",
      "placeholders": [
        "longest_string",
        "longest",
        "strings",
        "second_longest"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([]) is None\n    assert candidate(['albha', 'iehwknsj', 'lwi', 'wihml']) == 'albha'\n    assert candidate(['apple', 'banana', 'kiwiiiiiii', 'xxxxxx', 'appledish']) == 'appledish'\n    assert candidate(['what', 'is', 'this']) == 'is'\n\ndef test_check():\n    check(second_longest)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "greatest_common_divisor",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Return a greatest common divisor of two integers a and b",
        "examples": [
          ">>> greatest_common_divisor(3, 5)\n1",
          ">>> greatest_common_divisor(25, 15)\n5"
        ]
      },
      "template": "def {{ greatest_common_divisor }}({{ a }}: int, {{ b }}: int) -> int:\n    while {{ b }}:\n        ({{ a }}, {{ b }}) = ({{ b }}, {{ a }} % {{ b }})\n    return {{ a }}",
      "placeholders": [
        "a",
        "greatest_common_divisor",
        "b"
      ]
    },
    "target_function": {
      "name": "reduce_fraction",
      "arguments": [
        "nominator",
        "denominator"
      ],
      "docstring": {
        "description": "Given nominator and denominator, reduce them to the simplest form.\nReducing fractions means simplifying a fraction, wherein we divide the numerator and denominator by a common divisor until the common factor becomes 1.",
        "examples": [
          ">>> reduce_fraction(3, 5)\n(3, 5)",
          ">>> reduce_fraction(25, 15)\n(5, 3)"
        ]
      },
      "template": "def {{ reduce_fraction }}({{ nominator }}: int, {{ denominator }}: int) -> Tuple[int, int]:\n    {{ gcd }} = {{ greatest_common_divisor }}({{ nominator }}, {{ denominator }})\n    return ({{ nominator }} // {{ gcd }}, {{ denominator }} // {{ gcd }})",
      "placeholders": [
        "nominator",
        "gcd",
        "reduce_fraction",
        "denominator",
        "greatest_common_divisor"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(51, 34) == (3, 2)\n    assert candidate(81, 9) == (9, 1)\n    assert candidate(39, 52) == (3, 4)\n\ndef test_check():\n    check(reduce_fraction)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "all_prefixes",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Return list of all prefixes from shortest to longest of the input string",
        "examples": [
          ">>> all_prefixes('abc')\n['a', 'ab', 'abc']"
        ]
      },
      "template": "def {{ all_prefixes }}({{ string }}: str) -> List[str]:\n    {{ result }} = []\n    for {{ i }} in range(len({{ string }})):\n        {{ result }}.append({{ string }}[:{{ i }} + 1])\n    return {{ result }}",
      "placeholders": [
        "i",
        "all_prefixes",
        "result",
        "string"
      ]
    },
    "target_function": {
      "name": "all_suffixes_prefixes",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Return list of suffixes which are also a prefix from shortest to\nlongest of the input string",
        "examples": [
          ">>> all_suffixes('abc')\n['abc']"
        ]
      },
      "template": "def {{ all_suffixes_prefixes }}({{ string }}: str) -> List[str]:\n    {{ prefixes }} = {{ all_prefixes }}({{ string }})\n    {{ suffixes }} = [{{ x }}[::-1] for {{ x }} in {{ all_prefixes }}({{ string }}[::-1])]\n    return [{{ x }} for {{ x }} in {{ suffixes }} if {{ x }} in {{ prefixes }}]",
      "placeholders": [
        "string",
        "prefixes",
        "x",
        "all_prefixes",
        "all_suffixes_prefixes",
        "suffixes"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('abcabc') == ['abc', 'abcabc']\n    assert candidate('ababab') == ['ab', 'abab', 'ababab']\n    assert candidate('dxewfoird') == ['d', 'dxewfoird']\n\ndef test_check():\n    check(all_suffixes_prefixes)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "string_sequence",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.",
        "examples": [
          ">>> string_sequence(0)\n'0'",
          ">>> string_sequence(5)\n'0 1 2 3 4 5'"
        ]
      },
      "template": "def {{ string_sequence }}({{ n }}: int) -> str:\n    return ' '.join([str({{ x }}) for {{ x }} in range({{ n }} + 1)])",
      "placeholders": [
        "string_sequence",
        "x",
        "n"
      ]
    },
    "target_function": {
      "name": "digit_sum",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the sum of all digits from 0 upto n inclusive.",
        "examples": [
          ">>> digit_sum(0)\n0",
          ">>> digit_sum(5)\n15"
        ]
      },
      "template": "def {{ digit_sum }}({{ n }}: int) -> str:\n    {{ sequence }} = {{ string_sequence }}({{ n }})\n    return sum((int({{ x }}) for {{ x }} in {{ sequence }} if {{ x }} != ' '))",
      "placeholders": [
        "x",
        "n",
        "string_sequence",
        "sequence",
        "digit_sum"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(14) == 60\n    assert candidate(21) == 105\n    assert candidate(104) == 915\n\ndef test_check():\n    check(digit_sum)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "count_distinct_characters",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Given a string, find out how many distinct characters (regardless of case) does it consist of",
        "examples": [
          ">>> count_distinct_characters('xyzXYZ')\n3",
          ">>> count_distinct_characters('Jerry')\n4"
        ]
      },
      "template": "def {{ count_distinct_characters }}({{ string }}: str) -> int:\n    return len(set({{ string }}.lower()))",
      "placeholders": [
        "string",
        "count_distinct_characters"
      ]
    },
    "target_function": {
      "name": "count_words_with_distinct_characters",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Given a list of strings, count the number of words made up of all different letters (regardless of case)",
        "examples": [
          ">>> count_words_with_distinct_characters(['xyz', 'Jerry'])\n1",
          ">>> count_words_with_distinct_characters(['apple', 'bear', 'Take'])\n2"
        ]
      },
      "template": "def {{ count_words_with_distinct_characters }}({{ strings }}: List[str]) -> int:\n    return len([string for string in {{ strings }} if {{ count_distinct_characters }}(string) == len(string)])",
      "placeholders": [
        "count_words_with_distinct_characters",
        "strings",
        "count_distinct_characters"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['valid', 'heart', 'orientation', 'class']) == 2\n    assert candidate(['hunter', 'frog']) == 2\n    assert candidate(['scratch']) == 0\n\ndef test_check():\n    check(count_words_with_distinct_characters)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "parse_music",
      "arguments": [
        "music_string"
      ],
      "docstring": {
        "description": "Input to this function is a string representing musical notes in a special ASCII format.\nYour task is to parse this string and return list of integers corresponding to how many beats does each\nnot last.\n\nHere is a legend:\n'o' - whole note, lasts four beats\n'o|' - half note, lasts two beats\n'.|' - quater note, lasts one beat",
        "examples": [
          ">>> parse_music('o o| .| o| o| .| .| .| .| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]"
        ]
      },
      "template": "def {{ parse_music }}({{ music_string }}: str) -> List[int]:\n    {{ note_map }} = {'o': 4, 'o|': 2, '.|': 1}\n    return [{{ note_map }}[{{ x }}] for {{ x }} in {{ music_string }}.split(' ') if {{ x }}]",
      "placeholders": [
        "note_map",
        "music_string",
        "x",
        "parse_music"
      ]
    },
    "target_function": {
      "name": "count_beats",
      "arguments": [
        "music_string"
      ],
      "docstring": {
        "description": "Input to this function is a string representing musical notes in a special ASCII format.\nYour task is to parse this string and return the total number of beats in the song.\n\nHere is a legend:\n'o' - whole note, lasts four beats\n'o|' - half note, lasts two beats\n'.|' - quater note, lasts one beat",
        "examples": [
          ">>> count_beats('o o| .| o| o| .| .| .| .| o o')\n24"
        ]
      },
      "template": "def {{ count_beats }}({{ music_string }}: str) -> int:\n    return sum({{ parse_music }}({{ music_string }}))",
      "placeholders": [
        "count_beats",
        "parse_music",
        "music_string"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('o o| .|') == 7\n    assert candidate('o| o| o|') == 6\n    assert candidate('o .| o| o o| .| o|') == 16\n\ndef test_check():\n    check(count_beats)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "how_many_times",
      "arguments": [
        "string",
        "substring"
      ],
      "docstring": {
        "description": "Find how many times a given substring can be found in the original string. Count overlaping cases.",
        "examples": [
          ">>> how_many_times('', 'a')\n0",
          ">>> how_many_times('aaa', 'a')\n3",
          ">>> how_many_times('aaaa', 'aa')\n3"
        ]
      },
      "template": "def {{ how_many_times }}({{ string }}: str, {{ substring }}: str) -> int:\n    {{ times }} = 0\n    for {{ i }} in range(len({{ string }}) - len({{ substring }}) + 1):\n        if {{ string }}[{{ i }}:{{ i }} + len({{ substring }})] == {{ substring }}:\n            {{ times }} += 1\n    return {{ times }}",
      "placeholders": [
        "string",
        "how_many_times",
        "i",
        "substring",
        "times"
      ]
    },
    "target_function": {
      "name": "match_cancer_pattern",
      "arguments": [
        "dna",
        "cancer_pattern"
      ],
      "docstring": {
        "description": "Find how many times a given cancer pattern can be found in the given DNA. Count overlaping cases.",
        "examples": [
          ">>> match_cancer_pattern('ATGCGATACGCTTGA', 'CG')\n3",
          ">>> match_cancer_pattern('ATGCGATACGCTTGA', 'CGC')\n1"
        ]
      },
      "template": "def {{ match_cancer_pattern }}({{ dna }}: str, {{ cancer_pattern }}: str) -> int:\n    return {{ how_many_times }}({{ dna }}, {{ cancer_pattern }})",
      "placeholders": [
        "cancer_pattern",
        "match_cancer_pattern",
        "dna",
        "how_many_times"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('ATATATAT', 'ATA') == 3\n    assert candidate('ATGCATGCATGCATGC', 'ATGCATGC') == 3\n    assert candidate('AGCTCTGATCGAT', 'GAT') == 2\n\ndef test_check():\n    check(match_cancer_pattern)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "sort_numbers",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "Input is a space-delimited string of numberals from 'zero' to 'nine'.\nValid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\nReturn the string with numbers sorted from smallest to largest",
        "examples": [
          ">>> sort_numbers('three one five')\n'one three five'"
        ]
      },
      "template": "def {{ sort_numbers }}({{ numbers }}: str) -> str:\n    {{ value_map }} = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    return ' '.join(sorted([{{ x }} for {{ x }} in {{ numbers }}.split(' ') if {{ x }}], key=lambda x: {{ value_map }}[{{ x }}]))",
      "placeholders": [
        "numbers",
        "x",
        "sort_numbers",
        "value_map"
      ]
    },
    "target_function": {
      "name": "sort_numbers_descending",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "Input is a space-delimited string of numberals from 'zero' to 'nine'.\nValid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\nReturn the string with numbers sorted from largest to smallest",
        "examples": [
          ">>> sort_numbers_descending('three one five')\n'five three one'"
        ]
      },
      "template": "def {{ sort_numbers_descending }}({{ numbers }}: str) -> str:\n    return ' '.join(({{ x }} for {{ x }} in reversed({{ sort_numbers }}({{ numbers }}).split(' '))))",
      "placeholders": [
        "numbers",
        "x",
        "sort_numbers_descending",
        "sort_numbers"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('two three four') == 'four three two'\n    assert candidate('nine zero six seven') == 'nine seven six zero'\n    assert candidate('five one three eight') == 'eight five three one'\n\ndef test_check():\n    check(sort_numbers_descending)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "find_closest_elements",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).",
        "examples": [
          ">>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)",
          ">>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)"
        ]
      },
      "template": "def {{ find_closest_elements }}({{ numbers }}: List[float]) -> Tuple[float, float]:\n    {{ closest_pair }} = None\n    {{ distance }} = None\n    for ({{ idx }}, {{ elem }}) in enumerate({{ numbers }}):\n        for ({{ idx2 }}, {{ elem2 }}) in enumerate({{ numbers }}):\n            if {{ idx }} != {{ idx2 }}:\n                if {{ distance }} is None:\n                    {{ distance }} = abs({{ elem }} - {{ elem2 }})\n                    {{ closest_pair }} = tuple(sorted([{{ elem }}, {{ elem2 }}]))\n                else:\n                    {{ new_distance }} = abs({{ elem }} - {{ elem2 }})\n                    if {{ new_distance }} < {{ distance }}:\n                        {{ distance }} = {{ new_distance }}\n                        {{ closest_pair }} = tuple(sorted([{{ elem }}, {{ elem2 }}]))\n    return {{ closest_pair }}",
      "placeholders": [
        "closest_pair",
        "find_closest_elements",
        "distance",
        "elem",
        "numbers",
        "idx",
        "idx2",
        "elem2",
        "new_distance"
      ]
    },
    "target_function": {
      "name": "find_closest_distance",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "From a supplied list of numbers (of length at least two) select and return the distance between two that are\nthe closest to each other.",
        "examples": [
          ">>> find_closest_distance([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n0.2",
          ">>> find_closest_distance([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n0.0"
        ]
      },
      "template": "def {{ find_closest_distance }}({{ numbers }}: List[float]) -> float:\n    ({{ x }}, {{ y }}) = {{ find_closest_elements }}({{ numbers }})\n    return {{ y }} - {{ x }}",
      "placeholders": [
        "find_closest_distance",
        "find_closest_elements",
        "x",
        "numbers",
        "y"
      ]
    },
    "tests": "def check(candidate):\n    assert round(candidate([1.7, 0.5, 3.1, 1.2, 2.1]), 2) == 0.4\n    assert round(candidate([3.0, 4.0, 5.0, 4.0, 3.9]), 2) == 0.0\n    assert round(candidate([1.0, 2.0, 3.0, 10.0]), 2) == 1.0\n\ndef test_check():\n    check(find_closest_distance)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "rescale_to_unit",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "Given list of numbers (of at least two elements), apply a linear transform to that list,\nsuch that the smallest number will become 0 and the largest will become 1",
        "examples": [
          ">>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]"
        ]
      },
      "template": "def {{ rescale_to_unit }}({{ numbers }}: List[float]) -> List[float]:\n    {{ min_number }} = min({{ numbers }})\n    {{ max_number }} = max({{ numbers }})\n    return [({{ x }} - {{ min_number }}) / ({{ max_number }} - {{ min_number }}) for {{ x }} in {{ numbers }}]",
      "placeholders": [
        "min_number",
        "max_number",
        "x",
        "numbers",
        "rescale_to_unit"
      ]
    },
    "target_function": {
      "name": "rescale_to_percentile",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "Given list of numbers (of at least two elements), apply a linear transform to that list,\nsuch that the smallest number will become 0 and the largest will become 100",
        "examples": [
          ">>> rescale_to_percentile([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 25.0, 50.0, 75.0, 100.0]"
        ]
      },
      "template": "def {{ rescale_to_percentile }}({{ numbers }}: List[float]) -> List[float]:\n    return [{{ x }} * 100 for {{ x }} in {{ rescale_to_unit }}({{ numbers }})]",
      "placeholders": [
        "numbers",
        "x",
        "rescale_to_percentile",
        "rescale_to_unit"
      ]
    },
    "tests": "def check(candidate):\n    assert list(map(lambda x: round(x, 2), candidate([38.7, 91.9, 3.4, 94.7, 33.2, 19.1]))) == [38.66, 96.93, 0.0, 100.0, 32.64, 17.2]\n    assert list(map(lambda x: round(x, 2), candidate([3.0, 4.0, 5.0, 4.0, 3.9]))) == [0.0, 50.0, 100.0, 50.0, 45.0]\n    assert list(map(lambda x: round(x, 2), candidate([1.0, 2.0, 3.0, 10.0]))) == [0.0, 11.11, 22.22, 100.0]\n\ndef test_check():\n    check(rescale_to_percentile)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Any",
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "filter_integers",
      "arguments": [
        "values"
      ],
      "docstring": {
        "description": "Filter given list of any python values only for integers",
        "examples": [
          ">>> filter_integers(['a', 3.14, 5])\n[5]",
          ">>> filter_integers([1, 2, 3, 'abc', {  }, []])\n[1, 2, 3]"
        ]
      },
      "template": "def {{ filter_integers }}({{ values }}: List[Any]) -> List[int]:\n    return [{{ x }} for {{ x }} in {{ values }} if isinstance({{ x }}, int)]",
      "placeholders": [
        "filter_integers",
        "x",
        "values"
      ]
    },
    "target_function": {
      "name": "get_second_integer",
      "arguments": [
        "values"
      ],
      "docstring": {
        "description": "Return the second integer element in the list\nIf there is no second integer element, return None",
        "examples": [
          ">>> get_second_observed_integer(['a', 3.14, 5])\nNone",
          ">>> get_second_observed_integer([1, 2, 3, 'abc', {}, []])\n2"
        ]
      },
      "template": "def {{ get_second_integer }}({{ values }}: List[Any]) -> List[int]:\n    {{ integers }} = {{ filter_integers }}({{ values }})\n    if len({{ integers }}) < 2:\n        return None\n    return {{ filter_integers }}({{ values }})[1]",
      "placeholders": [
        "integers",
        "filter_integers",
        "get_second_integer",
        "values"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([75, '75', 'scv', 7.3]) is None\n    assert candidate(['wwkdjf', 'three', 97, 'wild', 3]) == 3\n    assert candidate([85, 92, 77, 94, 77]) == 92\n\ndef test_check():\n    check(get_second_integer)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "strlen",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Return length of given string",
        "examples": [
          ">>> strlen('')\n0",
          ">>> strlen('abc')\n3"
        ]
      },
      "template": "def {{ strlen }}({{ string }}: str) -> int:\n    return len({{ string }})",
      "placeholders": [
        "string",
        "strlen"
      ]
    },
    "target_function": {
      "name": "is_string_length_odd",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Return 'odd' if length of given string is odd, otherwise 'even'",
        "examples": [
          ">>> is_string_length_odd('')\n'even'",
          ">>> is_string_length_odd('abc')\n'odd'"
        ]
      },
      "template": "def {{ is_string_length_odd }}({{ string }}: str) -> str:\n    return 'odd' if {{ strlen }}({{ string }}) % 2 else 'even'",
      "placeholders": [
        "string",
        "is_string_length_odd",
        "strlen"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('apple') == 'odd'\n    assert candidate('working') == 'odd'\n    assert candidate('book') == 'even'\n\ndef test_check():\n    check(is_string_length_odd)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "largest_divisor",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "For a given number n, find the largest number that divides n evenly, smaller than n",
        "examples": [
          ">>> largest_divisor(15)\n5"
        ]
      },
      "template": "def {{ largest_divisor }}({{ n }}: int) -> int:\n    for {{ i }} in reversed(range({{ n }})):\n        if {{ n }} % {{ i }} == 0:\n            return {{ i }}",
      "placeholders": [
        "i",
        "largest_divisor",
        "n"
      ]
    },
    "target_function": {
      "name": "get_smallest_chunk_num",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Given n, find the smallest k such that a number n can be made from k chunks of the same size.\nChunk size must be smaller than n.",
        "examples": [
          ">>> get_smallest_chunk_num(15)\n3"
        ]
      },
      "template": "def {{ get_smallest_chunk_num }}({{ n }}: int) -> bool:\n    return {{ n }} // {{ largest_divisor }}({{ n }})",
      "placeholders": [
        "get_smallest_chunk_num",
        "largest_divisor",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(370) == 2\n    assert candidate(23) == 23\n    assert candidate(77) == 7\n\ndef test_check():\n    check(get_smallest_chunk_num)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "factorize",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return list of prime factors of given integer in the order from smallest to largest.\nEach of the factors should be listed number of times corresponding to how many times it appeares in factorization.\nInput number should be equal to the product of all factors",
        "examples": [
          ">>> factorize(8)\n[2, 2, 2]",
          ">>> factorize(25)\n[5, 5]",
          ">>> factorize(70)\n[2, 5, 7]"
        ]
      },
      "template": "def {{ factorize }}({{ n }}: int) -> List[int]:\n    import math\n    {{ fact }} = []\n    {{ i }} = 2\n    while {{ i }} <= int(math.sqrt({{ n }}) + 1):\n        if {{ n }} % {{ i }} == 0:\n            {{ fact }}.append({{ i }})\n            {{ n }} //= {{ i }}\n        else:\n            {{ i }} += 1\n    if {{ n }} > 1:\n        {{ fact }}.append({{ n }})\n    return {{ fact }}",
      "placeholders": [
        "i",
        "factorize",
        "fact",
        "n"
      ]
    },
    "target_function": {
      "name": "count_unique_prime_factors",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the number of unique prime factors of given integer",
        "examples": [
          ">>> count_unique_prime_factors(8)\n1",
          ">>> count_unique_prime_factors(25)\n1",
          ">>> count_unique_prime_factors(70)\n3"
        ]
      },
      "template": "def {{ count_unique_prime_factors }}({{ n }}: int) -> int:\n    return len(set({{ factorize }}({{ n }})))",
      "placeholders": [
        "count_unique_prime_factors",
        "factorize",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(910) == 4\n    assert candidate(256) == 1\n    assert candidate(936) == 3\n\ndef test_check():\n    check(count_unique_prime_factors)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "remove_duplicates",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "From a list of integers, remove all elements that occur more than once.\nKeep order of elements left the same as in the input.",
        "examples": [
          ">>> remove_duplicates([1, 2, 3, 2, 4])\n[1, 3, 4]"
        ]
      },
      "template": "def {{ remove_duplicates }}({{ numbers }}: List[int]) -> List[int]:\n    import collections\n    {{ c }} = collections.Counter({{ numbers }})\n    return [{{ n }} for {{ n }} in {{ numbers }} if {{ c }}[{{ n }}] <= 1]",
      "placeholders": [
        "c",
        "remove_duplicates",
        "n",
        "numbers"
      ]
    },
    "target_function": {
      "name": "count_duplicates",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "From a list of integers, count how many elements occur more than once.",
        "examples": [
          ">>> count_duplicates([1, 2, 3, 2, 4])\n2",
          ">>> count_duplicates([2, 2, 3, 2, 3])\n5"
        ]
      },
      "template": "def {{ count_duplicates }}({{ numbers }}: List[int]) -> int:\n    return len({{ numbers }}) - len({{ remove_duplicates }}({{ numbers }}))",
      "placeholders": [
        "numbers",
        "remove_duplicates",
        "count_duplicates"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([9, 4, 3, 3, 3]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 6, 4, 2]) == 6\n    assert candidate([96, 33, 27, 96, 2, 11]) == 2\n\ndef test_check():\n    check(count_duplicates)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "flip_case",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "For a given string, flip lowercase characters to uppercase and uppercase to lowercase.",
        "examples": [
          ">>> flip_case('Hello')\n'hELLO'"
        ]
      },
      "template": "def {{ flip_case }}({{ string }}: str) -> str:\n    return {{ string }}.swapcase()",
      "placeholders": [
        "string",
        "flip_case"
      ]
    },
    "target_function": {
      "name": "get_more_uppercase_word",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Return string if string has more or equal number of uppercase characters than\nthe number of lowercase characters. Otherwise, return string whose characters\nare flipped by their case.",
        "examples": [
          ">>> flip_alternative_words('Hello')\n'hELLO'",
          ">>> flip_alternative_words('SotA')\n'SotA'"
        ]
      },
      "template": "def {{ get_more_uppercase_word }}({{ string }}: str) -> str:\n    if sum((1 for {{ c }} in {{ string }} if {{ c }}.isupper())) >= sum((1 for {{ c }} in {{ string }} if {{ c }}.islower())):\n        return {{ string }}\n    else:\n        return {{ flip_case }}({{ string }})",
      "placeholders": [
        "string",
        "c",
        "flip_case",
        "get_more_uppercase_word"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('What') == 'wHAT'\n    assert candidate('APpLe') == 'APpLe'\n    assert candidate('noTeBooK') == 'NOtEbOOk'\n\ndef test_check():\n    check(get_more_uppercase_word)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "concatenate",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Concatenate list of strings into a single string",
        "examples": [
          ">>> concatenate([])\n''",
          ">>> concatenate(['a', 'b', 'c'])\n'abc'"
        ]
      },
      "template": "def {{ concatenate }}({{ strings }}: List[str]) -> str:\n    return ''.join({{ strings }})",
      "placeholders": [
        "concatenate",
        "strings"
      ]
    },
    "target_function": {
      "name": "create_multiline_string",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Create a multiline string from a list of strings. Note that last line should also end with a newline. If string is empty, return empty string.",
        "examples": [
          ">>> create_multiline_string([])\n    ''",
          ">>> create_multiline_string(['a', 'b', 'c'])\n    'a\\nb\\nc"
        ]
      },
      "template": "def {{ create_multiline_string }}({{ strings }}: List[str]) -> str:\n    return {{ concatenate }}([{{ s }} + '\\n' for {{ s }} in {{ strings }}])",
      "placeholders": [
        "concatenate",
        "s",
        "create_multiline_string",
        "strings"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['return scroll', 'might be', ' .']) == 'return scroll\\nmight be\\n .\\n'\n    assert candidate([\"I don't know\"]) == \"I don't know\\n\"\n    assert candidate([]) == ''\n\ndef test_check():\n    check(create_multiline_string)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "filter_by_prefix",
      "arguments": [
        "strings",
        "prefix"
      ],
      "docstring": {
        "description": "Filter an input list of strings only for ones that start with a given prefix.",
        "examples": [
          ">>> filter_by_prefix([], 'a')\n[]",
          ">>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n['abc', 'array']"
        ]
      },
      "template": "def {{ filter_by_prefix }}({{ strings }}: List[str], {{ prefix }}: str) -> List[str]:\n    return [{{ x }} for {{ x }} in {{ strings }} if {{ x }}.startswith({{ prefix }})]",
      "placeholders": [
        "prefix",
        "x",
        "filter_by_prefix",
        "strings"
      ]
    },
    "target_function": {
      "name": "create_autocomplete_options",
      "arguments": [
        "input",
        "options"
      ],
      "docstring": {
        "description": "Create autocomplete options for a given input string from a list of options.\nOptions should be sorted alphabetically.",
        "examples": [
          ">>> create_autocomplete_options('a', [])\n[]",
          ">>> create_autocomplete_options('a', ['abc', 'bcd', 'cde', 'array'])\n['abc', 'array']"
        ]
      },
      "template": "def {{ create_autocomplete_options }}({{ input }}: str, {{ options }}: List[str]) -> List[str]:\n    return sorted({{ filter_by_prefix }}({{ options }}, {{ input }}))",
      "placeholders": [
        "options",
        "create_autocomplete_options",
        "filter_by_prefix",
        "input"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('mac', ['machanic', 'machine', 'mad', 'sort']) == ['machanic', 'machine']\n    assert candidate('le', ['learning', 'lora', 'lecun', 'lemon']) == ['learning', 'lecun', 'lemon']\n    assert candidate('program', ['array', 'bolt', 'programming', 'program']) == ['program', 'programming']\n\ndef test_check():\n    check(create_autocomplete_options)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "get_positive",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return only positive numbers in the list.",
        "examples": [
          ">>> get_positive([-1, 2, -4, 5, 6])\n[2, 5, 6]",
          ">>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]"
        ]
      },
      "template": "def {{ get_positive }}({{ l }}: List[int]) -> List[int]:\n    return [{{ e }} for {{ e }} in {{ l }} if {{ e }} > 0]",
      "placeholders": [
        "l",
        "get_positive",
        "e"
      ]
    },
    "target_function": {
      "name": "sum_positive",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return the sum of all positive numbers in the list.",
        "examples": [
          ">>> sum_positive([-1, 2, -4, 5, 6])\n13",
          ">>> sum_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n146"
        ]
      },
      "template": "def {{ sum_positive }}({{ l }}: list) -> int:\n    return sum({{ get_positive }}({{ l }}))",
      "placeholders": [
        "l",
        "sum_positive",
        "get_positive"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([40, 0, 4]) == 44\n    assert candidate([-1, -2, -3, -4]) == 0\n    assert candidate([7, -6, 10, -22, -1, 0]) == 17\n\ndef test_check():\n    check(sum_positive)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "is_prime",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return true if a given number is prime, and false otherwise.",
        "examples": [
          ">>> is_prime(6)\nFalse",
          ">>> is_prime(101)\nTrue",
          ">>> is_prime(11)\nTrue",
          ">>> is_prime(13441)\nTrue",
          ">>> is_prime(61)\nTrue",
          ">>> is_prime(4)\nFalse",
          ">>> is_prime(1)\nFalse"
        ]
      },
      "template": "def {{ is_prime }}({{ n }}: int) -> bool:\n    if {{ n }} < 2:\n        return False\n    for {{ k }} in range(2, {{ n }} - 1):\n        if {{ n }} % {{ k }} == 0:\n            return False\n    return True",
      "placeholders": [
        "is_prime",
        "k",
        "n"
      ]
    },
    "target_function": {
      "name": "get_prime_times_prime",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Returns a sorted list of numbers less than n that are\nthe product of two distinct primes.",
        "examples": [
          ">>> get_number(6)\n[]",
          ">>> get_number(20)\n[6, 10, 14, 15]"
        ]
      },
      "template": "def {{ get_prime_times_prime }}({{ n }}: int) -> bool:\n    {{ primes }} = [{{ i }} for {{ i }} in range(2, {{ n }}) if {{ is_prime }}({{ i }})]\n    {{ results }} = []\n    for {{ i }} in range(len({{ primes }})):\n        for {{ j }} in range({{ i }} + 1, len({{ primes }})):\n            if {{ primes }}[{{ i }}] * {{ primes }}[{{ j }}] < {{ n }}:\n                {{ results }}.append({{ primes }}[{{ i }}] * {{ primes }}[{{ j }}])\n    return sorted({{ results }})",
      "placeholders": [
        "get_prime_times_prime",
        "i",
        "results",
        "is_prime",
        "n",
        "primes",
        "j"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(35) == [6, 10, 14, 15, 21, 22, 26, 33, 34]\n    assert candidate(49) == [6, 10, 14, 15, 21, 22, 26, 33, 34, 35, 38, 39, 46]\n    assert candidate(100) == [6, 10, 14, 15, 21, 22, 26, 33, 34, 35, 38, 39, 46, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95]\n\ndef test_check():\n    check(get_prime_times_prime)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "sort_third",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "This function takes a list l and returns a list l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.",
        "examples": [
          ">>> sort_third([1, 2, 3])\n[1, 2, 3]",
          ">>> sort_third([5, 6, 3, 4, 8, 9, 2])\n[2, 6, 3, 4, 8, 9, 5]"
        ]
      },
      "template": "def {{ sort_third }}({{ l }}: List[int]) -> List[int]:\n    {{ l }} = list({{ l }})\n    {{ l }}[::3] = sorted({{ l }}[::3])\n    return {{ l }}",
      "placeholders": [
        "l",
        "sort_third"
      ]
    },
    "target_function": {
      "name": "sort_first_column",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "This function takes an array of n by 3.\nIt returns an array of N x 3 such that the elements in the first column are sorted.",
        "examples": [
          ">>> sort_first_column([[1, 2, 3], [9, 6, 4], [5, 3, 2]])\n[[1, 2, 3], [5, 6, 4], [9, 3, 2]]",
          ">>> sort_first_column([[8, 9, 8], [6, 6, 6], [2, 9, 1]])\n[[2, 9, 8], [6, 6, 6], [8, 9, 1]]"
        ]
      },
      "template": "def {{ sort_first_column }}({{ l }}: List[List[int]]):\n    {{ l }} = [{{ y }} for {{ x }} in {{ l }} for {{ y }} in {{ x }}]\n    {{ l }} = {{ sort_third }}({{ l }})\n    return [[{{ l }}[3 * {{ i }}], {{ l }}[3 * {{ i }} + 1], {{ l }}[3 * {{ i }} + 2]] for {{ i }} in range(len({{ l }}) // 3)]",
      "placeholders": [
        "sort_third",
        "l",
        "i",
        "x",
        "sort_first_column",
        "y"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[5, 9, 2], [4, 3, 11], [2, 67, 4]]) == [[2, 9, 2], [4, 3, 11], [5, 67, 4]]\n    assert candidate([[32, 5, 7], [25, 4, 32]]) == [[25, 5, 7], [32, 4, 32]]\n    assert candidate([[4, 8, 3], [9, 5, 2], [1, 5, 2], [5, 5, 8]]) == [[1, 8, 3], [4, 5, 2], [5, 5, 2], [9, 5, 8]]\n\ndef test_check():\n    check(sort_first_column)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "max_element",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return maximum element in the list.",
        "examples": [
          ">>> max_element([1, 2, 3])\n3",
          ">>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n123"
        ]
      },
      "template": "def {{ max_element }}({{ l }}: List[int]) -> int:\n    {{ m }} = {{ l }}[0]\n    for {{ e }} in {{ l }}:\n        if {{ e }} > {{ m }}:\n            {{ m }} = {{ e }}\n    return {{ m }}",
      "placeholders": [
        "l",
        "max_element",
        "m",
        "e"
      ]
    },
    "target_function": {
      "name": "max_element_nested_list",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return maximum element in a nested list.\nl could be nested by any depth.",
        "examples": [
          ">>> max_element_nested_list([1, 2, 3])\n3",
          ">>> max_element_nested_list([[5, 3], [[-5], [2, -3, 3], [[9, 0], [123]], 1], -10])\n123"
        ]
      },
      "template": "def {{ max_element_nested_list }}({{ l }}: list):\n    return {{ max_element }}([{{ max_element_nested_list }}({{ e }}) if isinstance({{ e }}, list) else {{ e }} for {{ e }} in {{ l }}])",
      "placeholders": [
        "max_element",
        "l",
        "max_element_nested_list",
        "e"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[1, 2], [3], [[4], [5, 6]]]) == 6\n    assert candidate([[[[6]], [5, 4, 3, 2], [1]], 0]) == 6\n    assert candidate([53, [23, [34, 23], [22, 15, 52]]]) == 53\n\ndef test_check():\n    check(max_element_nested_list)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "fizz_buzz",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.",
        "examples": [
          ">>> fizz_buzz(50)\n0",
          ">>> fizz_buzz(78)\n2",
          ">>> fizz_buzz(79)\n3"
        ]
      },
      "template": "def {{ fizz_buzz }}({{ n }}: int) -> int:\n    {{ ns }} = []\n    for {{ i }} in range({{ n }}):\n        if {{ i }} % 11 == 0 or {{ i }} % 13 == 0:\n            {{ ns }}.append({{ i }})\n    {{ s }} = ''.join(list(map(str, {{ ns }})))\n    {{ ans }} = 0\n    for {{ c }} in {{ s }}:\n        {{ ans }} += {{ c }} == '7'\n    return {{ ans }}",
      "placeholders": [
        "c",
        "i",
        "ans",
        "s",
        "ns",
        "fizz_buzz",
        "n"
      ]
    },
    "target_function": {
      "name": "lucky_number",
      "arguments": [
        "k"
      ],
      "docstring": {
        "description": "Return the smallest non-negative number n that the digit 7 appears at\nleast k times in integers less than n which are divisible by 11 or 13.",
        "examples": [
          ">>> lucky_number(3)\n79",
          ">>> lucky_number(0)\n0"
        ]
      },
      "template": "def {{ lucky_number }}({{ k }}: int) -> int:\n    {{ n }} = 0\n    while {{ fizz_buzz }}({{ n }}) < {{ k }}:\n        {{ n }} += 1\n    return {{ n }}",
      "placeholders": [
        "fizz_buzz",
        "lucky_number",
        "k",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(1) == 78\n    assert candidate(2) == 78\n    assert candidate(4) == 118\n\ndef test_check():\n    check(lucky_number)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "sort_even",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "This function takes a list l and returns a list l' such that\nl' is identical to l in the odd indicies, while its values at the\neven indicies are equal to the values of the even indicies of l,\nbut sorted.",
        "examples": [
          ">>> sort_even([1, 2, 3])\n[1, 2, 3]",
          ">>> sort_even([5, 6, 3, 4])\n[3, 6, 5, 4]"
        ]
      },
      "template": "def {{ sort_even }}({{ l }}: list[int]) -> list[int]:\n    {{ evens }} = {{ l }}[::2]\n    {{ odds }} = {{ l }}[1::2]\n    {{ evens }}.sort()\n    {{ ans }} = []\n    for ({{ e }}, {{ o }}) in zip({{ evens }}, {{ odds }}):\n        {{ ans }}.extend([{{ e }}, {{ o }}])\n    if len({{ evens }}) > len({{ odds }}):\n        {{ ans }}.append({{ evens }}[-1])\n    return {{ ans }}",
      "placeholders": [
        "evens",
        "odds",
        "l",
        "ans",
        "o",
        "sort_even",
        "e"
      ]
    },
    "target_function": {
      "name": "paired_sort",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "This function takes a list l and returns a list l' such that\nl' is sorted to l in the odd indicies, also its values at the\neven indicies are equal to the values of the even indicies of l,\nbut sorted.",
        "examples": [
          ">>> sort_even([1, 2, 3])\n[1, 2, 3]",
          ">>> sort_even([5, 6, 3, 4])\n[3, 4, 5, 6]"
        ]
      },
      "template": "def {{ paired_sort }}({{ l }}: list[int]) -> list[int]:\n    {{ l }} = [{{ l }}[0]] + {{ sort_even }}({{ l }}[1:])\n    {{ l }} = {{ sort_even }}({{ l }})\n    return {{ l }}",
      "placeholders": [
        "l",
        "sort_even",
        "paired_sort"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([5, 2, 4, 3]) == [4, 2, 5, 3]\n    assert candidate([5, 4, 8, 6, 4, 2]) == [4, 2, 5, 4, 8, 6]\n    assert candidate([1, 7, 8, 9, 4, 3, 8]) == [1, 3, 4, 7, 8, 9, 8]\n\ndef test_check():\n    check(paired_sort)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "prime_fib",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.",
        "examples": [
          ">>> prime_fib(1)\n2",
          ">>> prime_fib(2)\n3",
          ">>> prime_fib(3)\n5",
          ">>> prime_fib(4)\n13",
          ">>> prime_fib(5)\n89"
        ]
      },
      "template": "def {{ prime_fib }}({{ n }}: int) -> int:\n    import math\n\n    def {{ is_prime }}({{ p }}):\n        if {{ p }} < 2:\n            return False\n        for {{ k }} in range(2, min(int(math.sqrt({{ p }})) + 1, {{ p }} - 1)):\n            if {{ p }} % {{ k }} == 0:\n                return False\n        return True\n    {{ f }} = [0, 1]\n    while True:\n        {{ f }}.append({{ f }}[-1] + {{ f }}[-2])\n        if {{ is_prime }}({{ f }}[-1]):\n            {{ n }} -= 1\n        if {{ n }} == 0:\n            return {{ f }}[-1]",
      "placeholders": [
        "p",
        "f",
        "prime_fib",
        "is_prime",
        "k",
        "n"
      ]
    },
    "target_function": {
      "name": "prime_fib_diff",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the difference between the n-th number that is a Fibonacci number and\nit's also prime and the (n+1)-th number that is a Fibonacci number and it's also prime.",
        "examples": [
          ">>> prime_fib_dif(1)\n1",
          ">>> prime_fib_dif(2)\n2",
          ">>> prime_fib_dif(3)\n8",
          ">>> prime_fib_dif(4)\n76"
        ]
      },
      "template": "def {{ prime_fib_diff }}({{ n }}: int):\n    return {{ prime_fib }}({{ n }} + 1) - {{ prime_fib }}({{ n }})",
      "placeholders": [
        "prime_fib_diff",
        "prime_fib",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(8) == 485572\n    assert candidate(3) == 8\n    assert candidate(10) == 2537720636\n\ndef test_check():\n    check(prime_fib_diff)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "triples_sum_to_zero",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "triples_sum_to_zero takes a list of integers as an input.\nit returns True if there are three distinct elements in the list that\nsum to zero, and False otherwise.",
        "examples": [
          ">>> triples_sum_to_zero([1, 3, 5, 0])\nFalse",
          ">>> triples_sum_to_zero([1, 3, -2, 1])\nTrue",
          ">>> triples_sum_to_zero([1, 2, 3, 7])\nFalse",
          ">>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\nTrue",
          ">>> triples_sum_to_zero([1])\nFalse"
        ]
      },
      "template": "def {{ triples_sum_to_zero }}({{ l }}: list[int]) -> bool:\n    for {{ i }} in range(len({{ l }})):\n        for {{ j }} in range({{ i }} + 1, len({{ l }})):\n            for {{ k }} in range({{ j }} + 1, len({{ l }})):\n                if {{ l }}[{{ i }}] + {{ l }}[{{ j }}] + {{ l }}[{{ k }}] == 0:\n                    return True\n    return False",
      "placeholders": [
        "triples_sum_to_zero",
        "i",
        "l",
        "k",
        "j"
      ]
    },
    "target_function": {
      "name": "get_shortest_prefix_triples_sum_to_zero",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "get_shortest_prefix_triples_sum_to_zero takes a list of integers as an input.\nit returns the shortest prefix of the list such that there are three distinct elements in the prefix that\nsum to zero, and an empty list if no such prefix exists.",
        "examples": [
          ">>> get_shortest_prefix_triples_sum_to_zero([1, 3, 5, 0])\n[]",
          ">>> get_shortest_prefix_triples_sum_to_zero([1, 3, -2, 1])\n[1, 3, -2]",
          ">>> get_shortest_prefix_triples_sum_to_zero([1, 2, 3, 7])\n[]",
          ">>> get_shortest_prefix_triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n[2, 4, -5, 3]",
          ">>> get_shortest_prefix_triples_sum_to_zero([1])\n[]"
        ]
      },
      "template": "def {{ get_shortest_prefix_triples_sum_to_zero }}({{ l }}: list) -> list:\n    for {{ i }} in range(1, len({{ l }}) + 1):\n        if {{ triples_sum_to_zero }}({{ l }}[:{{ i }}]):\n            return {{ l }}[:{{ i }}]\n    return []",
      "placeholders": [
        "i",
        "l",
        "get_shortest_prefix_triples_sum_to_zero",
        "triples_sum_to_zero"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([4, 8, 8, -16, 3]) == [4, 8, 8, -16]\n    assert candidate([-5, 2, 2, 1, 0]) == []\n    assert candidate([3, 2, -9, -8, 6, 7]) == [3, 2, -9, -8, 6]\n\ndef test_check():\n    check(get_shortest_prefix_triples_sum_to_zero)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "car_race_collision",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Imagine a road that's a perfectly straight infinitely long line.\nn cars are driving left to right;  simultaneously, a different set of n cars\nare driving right to left.   The two sets of cars start out being very far from\neach other.  All cars move in the same speed.  Two cars are said to collide\nwhen a car that's moving left to right hits a car that's moving right to left.\nHowever, the cars are infinitely sturdy and strong; as a result, they continue moving\nin their trajectory as if they did not collide.\n\nThis function outputs the number of such collisions.",
        "examples": []
      },
      "template": "def {{ car_race_collision }}({{ n }}: int) -> int:\n    return {{ n }} ** 2",
      "placeholders": [
        "car_race_collision",
        "n"
      ]
    },
    "target_function": {
      "name": "ball_collision",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Imagine a road that's a perfectly straight infinitely long line.\nn balls are rolling left to right; simultaneously, a different set of n balls\nare rolling right to left. The two sets of balls start out being very far from\neach other.  All balls move in the same speed.  Two balls are said to collide\nwhen a ball that's moving left to right hits a ball that's moving right to left.\nHowever, the balls are infinitely sturdy and strong; as a result, they continue moving\nin their trajectory as if they did not collide.\n\nThis function outputs the number of such collisions.",
        "examples": []
      },
      "template": "def {{ ball_collision }}({{ n }}: int):\n    return {{ car_race_collision }}({{ n }})",
      "placeholders": [
        "car_race_collision",
        "ball_collision",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(15) == 225\n    assert candidate(4) == 16\n    assert candidate(9) == 81\n\ndef test_check():\n    check(ball_collision)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "incr_list",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return list with elements incremented by 1.",
        "examples": [
          ">>> incr_list([1, 2, 3])\n[2, 3, 4]",
          ">>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]"
        ]
      },
      "template": "def {{ incr_list }}({{ l }}: list[int]) -> list[int]:\n    return [{{ e }} + 1 for {{ e }} in {{ l }}]",
      "placeholders": [
        "l",
        "e",
        "incr_list"
      ]
    },
    "target_function": {
      "name": "incr_sublist",
      "arguments": [
        "l",
        "start",
        "end"
      ],
      "docstring": {
        "description": "Return list that the element in the sublist from\n`start` (inclusive) to `end` (exclusive) incremented by 1.",
        "examples": [
          ">>> incr_until_10([1, 2, 3], 0, 2)\n[2, 3, 3]",
          ">>> incr_until_10([5, 3, 5, 2, 3, 3, 9, 0, 123], 3, 7)\n[5, 3, 5, 3, 4, 4, 10, 0, 123]"
        ]
      },
      "template": "def {{ incr_sublist }}({{ l }}: list, {{ start }}: int, {{ end }}: int):\n    return {{ l }}[:{{ start }}] + {{ incr_list }}({{ l }}[{{ start }}:{{ end }}]) + {{ l }}[{{ end }}:]",
      "placeholders": [
        "incr_sublist",
        "start",
        "l",
        "end",
        "incr_list"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([3, 6, 32, 6, 8, 8], 2, 6) == [3, 6, 33, 7, 9, 9]\n    assert candidate([8, 1, 5, 2, 7, 89, 9, 5, 4], 4, 8) == [8, 1, 5, 2, 8, 90, 10, 6, 4]\n    assert candidate([1, 56, 5, 24, 9, 45, 6, 34], 3, 4) == [1, 56, 5, 25, 9, 45, 6, 34]\n\ndef test_check():\n    check(incr_sublist)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "pairs_sum_to_zero",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "pairs_sum_to_zero takes a list of integers as an input.\nit returns True if there are two distinct elements in the list that\nsum to zero, and False otherwise.",
        "examples": [
          ">>> pairs_sum_to_zero([1, 3, 5, 0])\nFalse",
          ">>> pairs_sum_to_zero([1, 3, -2, 1])\nFalse",
          ">>> pairs_sum_to_zero([1, 2, 3, 7])\nFalse",
          ">>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\nTrue",
          ">>> pairs_sum_to_zero([1])\nFalse"
        ]
      },
      "template": "def {{ pairs_sum_to_zero }}({{ l }}: List[int]) -> bool:\n    for ({{ i }}, {{ l1 }}) in enumerate({{ l }}):\n        for {{ j }} in range({{ i }} + 1, len({{ l }})):\n            if {{ l1 }} + {{ l }}[{{ j }}] == 0:\n                return True\n    return False",
      "placeholders": [
        "pairs_sum_to_zero",
        "i",
        "l",
        "l1",
        "j"
      ]
    },
    "target_function": {
      "name": "triple_sum_to_zero_with_zero",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "triple_sum_to_zero_with_zero takes a list of integers as an input.\nit returns True if there are three distinct elements in the list that\nsum to zero and one of elements must be zero, and False otherwise.",
        "examples": [
          ">>> triple_sum_to_zero_with_zero([1, 3, -1, 0])\nTrue",
          ">>> triple_sum_to_zero_with_zero([1, 3, -2, 1])\nFalse",
          ">>> triple_sum_to_zero_with_zero([1, 2, 3, 7])\nFalse",
          ">>> triple_sum_to_zero_with_zero([2, 4, -5, 0, 3, 5, 7])\nTrue",
          ">>> triple_sum_to_zero_with_zero([1])\nFalse"
        ]
      },
      "template": "def {{ triple_sum_to_zero_with_zero }}({{ l }}):\n    if 0 not in {{ l }}:\n        return False\n    else:\n        {{ l }}.remove(0)\n        return {{ pairs_sum_to_zero }}({{ l }})",
      "placeholders": [
        "l",
        "triple_sum_to_zero_with_zero",
        "pairs_sum_to_zero"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([3, 6, 32, 6, 8, 8]) == False\n    assert candidate([-8, 1, 0, -5, 2, 7, -89, 9, 5, -4]) == True\n    assert candidate([1, 0, 56, -5, -24, 9, -45, 6, 34]) == False\n\ndef test_check():\n    check(triple_sum_to_zero_with_zero)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "change_base",
      "arguments": [
        "x",
        "base"
      ],
      "docstring": {
        "description": "Change numerical base of input number x to base.\nreturn string representation after the conversion.\nbase numbers are less than 10.",
        "examples": [
          ">>> change_base(8, 3)\n'22'",
          ">>> change_base(8, 2)\n'1000'",
          ">>> change_base(7, 2)\n'111'"
        ]
      },
      "template": "def {{ change_base }}({{ x }}: int, {{ base }}: int) -> str:\n    {{ ret }} = ''\n    while {{ x }} > 0:\n        {{ ret }} = str({{ x }} % {{ base }}) + {{ ret }}\n        {{ x }} //= {{ base }}\n    return {{ ret }}",
      "placeholders": [
        "base",
        "ret",
        "x",
        "change_base"
      ]
    },
    "target_function": {
      "name": "change_base_extension",
      "arguments": [
        "n",
        "base_from",
        "base_to"
      ],
      "docstring": {
        "description": "Change numerical base of input number n represented as string from base_from to base_to.\nreturn string representation after the conversion.\nbase numbers are less than 10.",
        "examples": [
          ">>> change_base_extension('22', 3, 2)\n'1000'",
          ">>> change_base_extension('1000', 2, 3)\n'22'",
          ">>> change_base_extension('111', 2, 10)\n'7'"
        ]
      },
      "template": "def {{ change_base_extension }}({{ n }}: str, {{ base_from }}: int, {{ base_to }}: int) -> str:\n    return {{ change_base }}(int({{ n }}, {{ base_from }}), {{ base_to }})",
      "placeholders": [
        "base_from",
        "base_to",
        "change_base_extension",
        "n",
        "change_base"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('43', 7, 2) == '11111'\n    assert candidate('101101', 2, 4) == '231'\n    assert candidate('3128', 10, 5) == '100003'\n\ndef test_check():\n    check(change_base_extension)\n\ntest_check()"
  },
  {
    "imports": [
      [
        null,
        [
          "math"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "triangle_area",
      "arguments": [
        "a",
        "h"
      ],
      "docstring": {
        "description": "Given length of a side and high return area for a triangle.",
        "examples": [
          ">>> triangle_area(5, 3)\n7.5"
        ]
      },
      "template": "def {{ triangle_area }}({{ a }}: int, {{ h }}: int) -> float:\n    return {{ a }} * {{ h }} / 2.0",
      "placeholders": [
        "a",
        "triangle_area",
        "h"
      ]
    },
    "target_function": {
      "name": "equilaternal_triangle_area",
      "arguments": [
        "a"
      ],
      "docstring": {
        "description": "Given length of a side return area for an equilaternal triangle.",
        "examples": [
          ">>> round(equilaternal_triangle_area(5), 2)\n10.83"
        ]
      },
      "template": "def {{ equilaternal_triangle_area }}({{ a }}):\n    return {{ triangle_area }}({{ a }}, {{ a }} * math.sqrt(3) / 2.0)",
      "placeholders": [
        "a",
        "equilaternal_triangle_area",
        "triangle_area"
      ]
    },
    "tests": "def check(candidate):\n    assert round(candidate(3.5), 2) == 5.3\n    assert round(candidate(10), 2) == 43.3\n    assert round(candidate(7.8), 2) == 26.34\n\ndef test_check():\n    check(equilaternal_triangle_area)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "fib4",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nfib4(0) -> 0\nfib4(1) -> 0\nfib4(2) -> 2\nfib4(3) -> 0\nfib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\nPlease write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.",
        "examples": [
          ">>> fib4(5)\n4",
          ">>> fib4(6)\n8",
          ">>> fib4(7)\n14"
        ]
      },
      "template": "def {{ fib4 }}({{ n }}: int) -> int:\n    {{ results }} = [0, 0, 2, 0]\n    if {{ n }} < 4:\n        return {{ results }}[{{ n }}]\n    for {{ _ }} in range(4, {{ n }} + 1):\n        {{ results }}.append({{ results }}[-1] + {{ results }}[-2] + {{ results }}[-3] + {{ results }}[-4])\n        {{ results }}.pop(0)\n    return {{ results }}[-1]",
      "placeholders": [
        "_",
        "results",
        "fib4",
        "n"
      ]
    },
    "target_function": {
      "name": "fib2_to_4",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the n-th value of sequence defined by the following recurrence relation.\nfib2_to_4(0) -> 0\nfib2_to_4(1) -> 1\nfib2_to_4(n) -> fib4(n) if n is even\nfib2_to_4(n) -> fib2_to_4(n-1) + fib2_to_4(n-2) if n is odd",
        "examples": [
          ">>> fib2_to_4(5)\n8",
          ">>> fib2_to_4(0)\n0",
          ">>> get_smallest_fib4_number(10)\n14"
        ]
      },
      "template": "def {{ fib2_to_4 }}({{ n }}: int):\n    if {{ n }} < 2:\n        return {{ n }}\n    if {{ n }} % 2 == 0:\n        return {{ fib4 }}({{ n }})\n    else:\n        return {{ fib2_to_4 }}({{ n }} - 1) + {{ fib2_to_4 }}({{ n }} - 2)",
      "placeholders": [
        "fib2_to_4",
        "fib4",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(4) == 2\n    assert candidate(8) == 28\n    assert candidate(11) == 145\n\ndef test_check():\n    check(fib2_to_4)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "median",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return median of elements in the list l.",
        "examples": [
          ">>> median([3, 1, 2, 4, 5])\n3",
          ">>> median([-10, 4, 6, 1000, 10, 20])\n15.0"
        ]
      },
      "template": "def {{ median }}({{ l }}: List[int]) -> float:\n    {{ l }} = sorted({{ l }})\n    if len({{ l }}) % 2 == 1:\n        return {{ l }}[len({{ l }}) // 2]\n    else:\n        return ({{ l }}[len({{ l }}) // 2 - 1] + {{ l }}[len({{ l }}) // 2]) / 2.0",
      "placeholders": [
        "l",
        "median"
      ]
    },
    "target_function": {
      "name": "is_skewed",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return \"positive\" if the list l is positive skewed, \"negative\" if the list l is negative skewed.\nOtherwise, return \"neutral\".\nA distribution with negative skew can have its mean greater than the median.\nA distribution with positive skew can have its mean less than the median.",
        "examples": [
          ">>> is_skewed([1, 2, 3, 4, 5])\n\"neutral\"",
          ">>> is_skewed([-10, 4, 6, 1000, 10, 20])\n\"positive\""
        ]
      },
      "template": "def {{ is_skewed }}({{ l }}: list):\n    {{ median_val }} = {{ median }}({{ l }})\n    {{ mean_val }} = sum({{ l }}) / len({{ l }})\n    if {{ mean_val }} > {{ median_val }}:\n        return 'positive'\n    elif {{ mean_val }} < {{ median_val }}:\n        return 'negative'\n    else:\n        return 'neutral'",
      "placeholders": [
        "is_skewed",
        "median",
        "median_val",
        "l",
        "mean_val"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1]) == 'neutral'\n    assert candidate([3, 4, 8, 9, 10]) == 'negative'\n    assert candidate([8, 3, 6, 2, 3, 4, 5, 7]) == 'positive'\n\ndef test_check():\n    check(is_skewed)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "is_palindrome",
      "arguments": [
        "text"
      ],
      "docstring": {
        "description": "Checks if given string is a palindrome",
        "examples": [
          ">>> is_palindrome('')\nTrue",
          ">>> is_palindrome('aba')\nTrue",
          ">>> is_palindrome('aaaaa')\nTrue",
          ">>> is_palindrome('zbcd')\nFalse"
        ]
      },
      "template": "def {{ is_palindrome }}({{ text }}: str) -> bool:\n    for {{ i }} in range(len({{ text }})):\n        if {{ text }}[{{ i }}] != {{ text }}[len({{ text }}) - 1 - {{ i }}]:\n            return False\n    return True",
      "placeholders": [
        "i",
        "is_palindrome",
        "text"
      ]
    },
    "target_function": {
      "name": "is_even_palidrome",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Checks if the chacters located in the even indices in the\ngiven string is a palindrome.",
        "examples": [
          ">>> is_palindrome('')\nTrue",
          ">>> is_palindrome('aba')\nTrue",
          ">>> is_palindrome('acaaa')\nTrue",
          ">>> is_palindrome('zbcd')\nFalse"
        ]
      },
      "template": "def {{ is_even_palidrome }}({{ s }}: str) -> bool:\n    return {{ is_palindrome }}({{ s }}[::2])",
      "placeholders": [
        "is_palindrome",
        "s",
        "is_even_palidrome"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('afbwccdhcebwa') == True\n    assert candidate('dabbrctdscfbeaa') == False\n    assert candidate('aabbcccybua') == True\n\ndef test_check():\n    check(is_even_palidrome)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "modp",
      "arguments": [
        "n",
        "p"
      ],
      "docstring": {
        "description": "Return 2^n modulo p (be aware of numerics).",
        "examples": [
          ">>> modp(3, 5)\n3",
          ">>> modp(1101, 101)\n2",
          ">>> modp(0, 101)\n1",
          ">>> modp(3, 11)\n8",
          ">>> modp(100, 101)\n1"
        ]
      },
      "template": "def {{ modp }}({{ n }}: int, {{ p }}: int) -> int:\n    {{ ret }} = 1\n    for {{ i }} in range({{ n }}):\n        {{ ret }} = 2 * {{ ret }} % {{ p }}\n    return {{ ret }}",
      "placeholders": [
        "modp",
        "p",
        "i",
        "n",
        "ret"
      ]
    },
    "target_function": {
      "name": "modp4",
      "arguments": [
        "n",
        "p"
      ],
      "docstring": {
        "description": "Return 4^n modulo p (be aware of numerics).",
        "examples": [
          ">>> modp4(3, 5)\n4"
        ]
      },
      "template": "def {{ modp4 }}({{ n }}: int, {{ p }}: int) -> int:\n    return {{ modp }}(2 * {{ n }}, {{ p }})",
      "placeholders": [
        "modp",
        "p",
        "modp4",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(403, 22) == 20\n    assert candidate(441, 2) == 0\n    assert candidate(9, 9) == 1\n\ndef test_check():\n    check(modp4)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "remove_vowels",
      "arguments": [
        "text"
      ],
      "docstring": {
        "description": "remove_vowels is a function that takes string and returns string without vowels.",
        "examples": [
          ">>> remove_vowels('')\n''",
          ">>> remove_vowels('abcdef')\n'bcdf'",
          ">>> remove_vowels('aaaaa')\n''",
          ">>> remove_vowels('aaBAA')\n'B'",
          ">>> remove_vowels('zbcd')\n'zbcd'"
        ]
      },
      "template": "def {{ remove_vowels }}({{ text }}: str) -> str:\n    return ''.join([{{ s }} for {{ s }} in {{ text }} if {{ s }}.lower() not in ['a', 'e', 'i', 'o', 'u']])",
      "placeholders": [
        "text",
        "s",
        "remove_vowels"
      ]
    },
    "target_function": {
      "name": "equal",
      "arguments": [
        "text1",
        "text2"
      ],
      "docstring": {
        "description": "check if the non-vowel characters in text1 and the non-vowel characters in texts is equal or not.",
        "examples": [
          ">>> count_vowels('apple', 'pple')\nTrue",
          ">>> count_vowels(\"pear\", \"par\")\nTrue",
          ">>> count_vowels(\"test\", \"text\")\nFalse"
        ]
      },
      "template": "def {{ equal }}({{ text1 }}: str, {{ text2 }}: str) -> bool:\n    return {{ remove_vowels }}({{ text1 }}) == {{ remove_vowels }}({{ text2 }})",
      "placeholders": [
        "text1",
        "remove_vowels",
        "text2",
        "equal"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('coke', 'cake') == True\n    assert candidate('desk', 'dust') == False\n    assert candidate('pandas', 'aeponeedosi') == True\n\ndef test_check():\n    check(equal)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "below_threshold",
      "arguments": [
        "l",
        "t"
      ],
      "docstring": {
        "description": "Return True if all numbers in the list l are below threshold t.",
        "examples": [
          ">>> below_threshold([1, 2, 4, 10], 100)\nTrue",
          ">>> below_threshold([1, 20, 4, 10], 5)\nFalse"
        ]
      },
      "template": "def {{ below_threshold }}({{ l }}: List[int], {{ t }}: int) -> bool:\n    for {{ e }} in {{ l }}:\n        if {{ e }} >= {{ t }}:\n            return False\n    return True",
      "placeholders": [
        "l",
        "below_threshold",
        "e",
        "t"
      ]
    },
    "target_function": {
      "name": "detect_high_blood_sugar",
      "arguments": [
        "blood_sugar_graph"
      ],
      "docstring": {
        "description": "Return True if the symptom of high blood sugar is detected in the blood sugar graph.\nHigh blood sugar rate means that the blood sugar level is above 100.\nHigh blood sugar is detected even if only one high blood sugar level is present.",
        "examples": [
          ">>> blood_sugar_graph([65, 66, 70, 84, 81])\nFalse",
          ">>> blood_sugar_graph([65, 76, 81, 95, 101])\nTrue"
        ]
      },
      "template": "def {{ detect_high_blood_sugar }}({{ blood_sugar_graph }}: list) -> bool:\n    return not {{ below_threshold }}({{ blood_sugar_graph }}, 100)",
      "placeholders": [
        "blood_sugar_graph",
        "below_threshold",
        "detect_high_blood_sugar"
      ]
    },
    "tests": "def check(candidate):\n    assert round(candidate([77, 79, 75, 81, 82, 81, 84])) == False\n    assert round(candidate([101, 102, 99, 95, 93, 90])) == True\n    assert round(candidate([91, 95, 98, 101, 99])) == True\n\ndef test_check():\n    check(detect_high_blood_sugar)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "fib",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return n-th Fibonacci number.",
        "examples": [
          ">>> fib(10)\n55",
          ">>> fib(1)\n1",
          ">>> fib(8)\n21"
        ]
      },
      "template": "def {{ fib }}({{ n }}: int) -> int:\n    if {{ n }} == 0:\n        return 0\n    if {{ n }} == 1:\n        return 1\n    return {{ fib }}({{ n }} - 1) + {{ fib }}({{ n }} - 2)",
      "placeholders": [
        "fib",
        "n"
      ]
    },
    "target_function": {
      "name": "sum_fib",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return sum of first n Fibonacci numbers.\nYou can use this property: sum_{i=1}^{n} F_i = F_{n+2} - 1",
        "examples": [
          ">>> sum_fib(8)\n54",
          ">>> sum_fib(1)\n1",
          ">>> sum_fib(6)\n20"
        ]
      },
      "template": "def {{ sum_fib }}({{ n }}: int):\n    return {{ fib }}({{ n }} + 2) - 1",
      "placeholders": [
        "fib",
        "sum_fib",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(3) == 4\n    assert candidate(10) == 143\n    assert candidate(7) == 33\n\ndef test_check():\n    check(sum_fib)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "correct_bracketing",
      "arguments": [
        "brackets"
      ],
      "docstring": {
        "description": "brackets is a string of \"<\" and \">\".\nreturn True if every opening bracket has a corresponding closing bracket.",
        "examples": [
          ">>> correct_bracketing('<')\nFalse",
          ">>> correct_bracketing('<>')\nTrue",
          ">>> correct_bracketing('<<><>>')\nTrue",
          ">>> correct_bracketing('><<>')\nFalse"
        ]
      },
      "template": "def {{ correct_bracketing }}({{ brackets }}: str) -> bool:\n    {{ depth }} = 0\n    for {{ b }} in {{ brackets }}:\n        if {{ b }} == '<':\n            {{ depth }} += 1\n        else:\n            {{ depth }} -= 1\n        if {{ depth }} < 0:\n            return False\n    return {{ depth }} == 0",
      "placeholders": [
        "brackets",
        "depth",
        "correct_bracketing",
        "b"
      ]
    },
    "target_function": {
      "name": "extended_correct_bracketing",
      "arguments": [
        "brackets"
      ],
      "docstring": {
        "description": "brackets is a string of \"<\", \"(\", \">\" and \")\".\nThere is opening bracket \"<\" and \"(\" and closing bracket \">\", \")\".\nreturn True if every opening bracket has a corresponding closing bracket.\nNote that it is ok not to match the shape between opening bracket and closing bracket.\nFor example, \"<)\" is also true.",
        "examples": [
          ">>> extended_correct_bracketing(\"(>\")\nTrue",
          ">>> extended_correct_bracketing(\"(<)<<)>)\")\nTrue",
          ">>> extended_correct_bracketing(\"><)(<>)\")\nFalse"
        ]
      },
      "template": "def {{ extended_correct_bracketing }}({{ brackets }}: str) -> bool:\n    return {{ correct_bracketing }}({{ brackets }}.replace('(', '<').replace(')', '>'))",
      "placeholders": [
        "correct_bracketing",
        "extended_correct_bracketing",
        "brackets"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('(<(>)>') == True\n    assert candidate('<<>)<()<>>') == True\n    assert candidate('<<(<))<>))<>>') == False\n\ndef test_check():\n    check(extended_correct_bracketing)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "monotonic",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Return True is list elements are monotonically increasing or decreasing.",
        "examples": [
          ">>> monotonic([1, 2, 4, 20])\nTrue",
          ">>> monotonic([1, 20, 4, 10])\nFalse",
          ">>> monotonic([4, 1, 0, -10])\nTrue"
        ]
      },
      "template": "def {{ monotonic }}({{ l }}: list[int]) -> bool:\n    if {{ l }} == sorted({{ l }}) or {{ l }} == sorted({{ l }}, reverse=True):\n        return True\n    return False",
      "placeholders": [
        "l",
        "monotonic"
      ]
    },
    "target_function": {
      "name": "monotonic_2d",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Check if all rows and columns in the given array is monotonimally\nincreasing or decreasing.\nAssume that the given array is rectangular.",
        "examples": [
          ">>> monotonic_2d([[0, 1, 2], [3, 4, 5], [6, 7, 8]])\nTrue",
          ">>> monotonic_2d([[3, 5, 8], [2, 6, 9], [4, 7, 10]])\nFalse"
        ]
      },
      "template": "def {{ monotonic_2d }}({{ arr }}: list[list[int]]) -> bool:\n    for {{ i }} in range(len({{ arr }})):\n        if not {{ monotonic }}({{ arr }}[{{ i }}]):\n            return False\n    for {{ j }} in range(len({{ arr }}[0])):\n        if not {{ monotonic }}([{{ arr }}[{{ i }}][{{ j }}] for {{ i }} in range(len({{ arr }}))]):\n            return False\n    return True",
      "placeholders": [
        "i",
        "monotonic_2d",
        "monotonic",
        "j",
        "arr"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[4, 9, 13], [24, 19, 15], [25, 26, 27]]) == True\n    assert candidate([[100, 0], [0, 100]]) == True\n    assert candidate([[8, 6, 4], [8, 6, 4], [7, 8, 5]]) == False\n\ndef test_check():\n    check(monotonic_2d)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "largest_prime_factor",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the largest prime factor of n. Assume n > 1 and is not a prime.",
        "examples": [
          ">>> largest_prime_factor(13195)\n29",
          ">>> largest_prime_factor(2048)\n2"
        ]
      },
      "template": "def {{ largest_prime_factor }}({{ n }}: int) -> int:\n\n    def {{ is_prime }}({{ k }}):\n        if {{ k }} < 2:\n            return False\n        for {{ i }} in range(2, {{ k }} - 1):\n            if {{ k }} % {{ i }} == 0:\n                return False\n        return True\n    {{ largest }} = 1\n    for {{ j }} in range(2, {{ n }} + 1):\n        if {{ n }} % {{ j }} == 0 and {{ is_prime }}({{ j }}):\n            {{ largest }} = max({{ largest }}, {{ j }})\n    return {{ largest }}",
      "placeholders": [
        "i",
        "largest_prime_factor",
        "is_prime",
        "k",
        "n",
        "j",
        "largest"
      ]
    },
    "target_function": {
      "name": "get_exponent_of_largest_prime_factor",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the exponent of largest prime factor after factorizing n. Assume n > 1 and is not a prime.",
        "examples": [
          ">>> get_exponent_of_largest_prime_factor(13195)  # 13195 = 5 * 7 * 13 * 29\n1",
          ">>> get_exponent_of_largest_prime_factor(2048)  # 2048 = 2^11\n11"
        ]
      },
      "template": "def {{ get_exponent_of_largest_prime_factor }}({{ n }}: int):\n    {{ largest }} = {{ largest_prime_factor }}({{ n }})\n    {{ ans }} = 1\n    while {{ largest_prime_factor }}({{ n }} // {{ largest }}) == {{ largest }}:\n        {{ ans }} += 1\n        {{ n }} = {{ n }} // {{ largest }}\n    return {{ ans }}",
      "placeholders": [
        "ans",
        "largest_prime_factor",
        "n",
        "largest",
        "get_exponent_of_largest_prime_factor"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(162) == 4\n    assert candidate(506250) == 5\n    assert candidate(1071875) == 3\n\ndef test_check():\n    check(get_exponent_of_largest_prime_factor)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "derivative",
      "arguments": [
        "xs"
      ],
      "docstring": {
        "description": "xs represent coefficients of a polynomial.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\n Return derivative of this polynomial in the same form.",
        "examples": [
          ">>> derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]",
          ">>> derivative([1, 2, 3])\n[2, 6]"
        ]
      },
      "template": "def {{ derivative }}({{ xs }}: list[int]) -> list[int]:\n    return [{{ i }} * {{ x }} for ({{ i }}, {{ x }}) in enumerate({{ xs }})][1:]",
      "placeholders": [
        "i",
        "xs",
        "derivative",
        "x"
      ]
    },
    "target_function": {
      "name": "second_derivative",
      "arguments": [
        "xs"
      ],
      "docstring": {
        "description": "xs represent coefficients of a polynomial.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nReturn second derivative of this polynomial in the same form.",
        "examples": [
          ">>> derivative([3, 1, 2, 4, 5])\n[4, 24, 60]",
          ">>> derivative([1, 2, 3])\n[6]"
        ]
      },
      "template": "def {{ second_derivative }}({{ xs }}: list[int]) -> list[int]:\n    return {{ derivative }}({{ derivative }}({{ xs }}))",
      "placeholders": [
        "derivative",
        "second_derivative",
        "xs"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([4, 9, 5, 2]) == [10, 12]\n    assert candidate([9, 8, 2, 5, 3]) == [4, 30, 36]\n    assert candidate([10, 8, 43, 4, 23, 4]) == [86, 24, 276, 80]\n\ndef test_check():\n    check(second_derivative)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "vowels_count",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Write a function vowels_count which takes a string representing\na word as input and returns the number of vowels in the string.\nVowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\nvowel, but only when it is at the end of the given word.",
        "examples": [
          ">>> vowels_count('abcde')\n2",
          ">>> vowels_count('ACEDY')\n3"
        ]
      },
      "template": "def {{ vowels_count }}({{ s }}: str) -> int:\n    {{ vowels }} = 'aeiouAEIOU'\n    {{ n_vowels }} = sum(({{ c }} in {{ vowels }} for {{ c }} in {{ s }}))\n    if {{ s }}[-1] == 'y' or {{ s }}[-1] == 'Y':\n        {{ n_vowels }} += 1\n    return {{ n_vowels }}",
      "placeholders": [
        "c",
        "vowels",
        "n_vowels",
        "s",
        "vowels_count"
      ]
    },
    "target_function": {
      "name": "is_vowel_enough",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Check if the given string contains at least 30% of vowels.",
        "examples": [
          ">>> is_vowel_enough(\"abcde\")\nTrue",
          ">>> is_vowel_enough(\"abc\")\nFalse"
        ]
      },
      "template": "def {{ is_vowel_enough }}({{ s }}: str) -> bool:\n    return {{ vowels_count }}({{ s }}) / len({{ s }}) >= 0.3",
      "placeholders": [
        "s",
        "is_vowel_enough",
        "vowels_count"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('Eulogia') == True\n    assert candidate('Drain') == True\n    assert candidate('hardship') == False\n\ndef test_check():\n    check(is_vowel_enough)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "circular_shift",
      "arguments": [
        "x",
        "shift"
      ],
      "docstring": {
        "description": "Circular shift the digits of the integer x, shift the digits right by shift\nand return the result as a string.\nIf shift > number of digits, return digits reversed.",
        "examples": [
          ">>> circular_shift(12, 1)\n'21'",
          ">>> circular_shift(12, 2)\n'12'"
        ]
      },
      "template": "def {{ circular_shift }}({{ x }}: int, {{ shift }}: int) -> str:\n    {{ s }} = str({{ x }})\n    if {{ shift }} > len({{ s }}):\n        return {{ s }}[::-1]\n    else:\n        return {{ s }}[len({{ s }}) - {{ shift }}:] + {{ s }}[:len({{ s }}) - {{ shift }}]",
      "placeholders": [
        "circular_shift",
        "s",
        "x",
        "shift"
      ]
    },
    "target_function": {
      "name": "is_circular_same",
      "arguments": [
        "x",
        "y"
      ],
      "docstring": {
        "description": "Return True if x and y are circularly same, False otherwise.\nCirculary same means that any of circular shift of x is equal\nto any of circular shift of y.",
        "examples": [
          ">>> is_circular_same(12, 21)\nTrue",
          ">>> is_circular_same(354, 453)\nFalse"
        ]
      },
      "template": "def {{ is_circular_same }}({{ x }}: int, {{ y }}: int) -> bool:\n    {{ xs }} = set(({{ circular_shift }}({{ x }}, {{ i }}) for {{ i }} in range(len(str({{ x }})))))\n    {{ ys }} = set(({{ circular_shift }}({{ y }}, {{ i }}) for {{ i }} in range(len(str({{ y }})))))\n    return len({{ xs }}.intersection({{ ys }})) > 0",
      "placeholders": [
        "xs",
        "i",
        "x",
        "is_circular_same",
        "y",
        "ys",
        "circular_shift"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(40273, 73402) is True\n    assert candidate(33, 23) is False\n    assert candidate(9447, 4794) is True\n\ndef test_check():\n    check(is_circular_same)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "digitSum",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Task\nWrite a function that takes a string as input and returns the sum of the upper characters only'\nASCII codes.",
        "examples": [
          ">>> digitSum('')\n0",
          ">>> digitSum('abAB')\n131",
          ">>> digitSum('abcCd')\n67",
          ">>> digitSum('helloE')\n69",
          ">>> digitSum('woArBld')\n131",
          ">>> digitSum('aAaaaXa')\n153"
        ]
      },
      "template": "def {{ digitSum }}({{ s }}: str) -> int:\n    if {{ s }} == '':\n        return 0\n    return sum((ord({{ char }}) if {{ char }}.isupper() else 0 for {{ char }} in {{ s }}))",
      "placeholders": [
        "digitSum",
        "char",
        "s"
      ]
    },
    "target_function": {
      "name": "sort_by_sum_upper_character_ascii",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Sort string based on the custom key defined as the sum of the upper\ncharacters only' ASCII codes. The order of string should be preserved in\ncase of a tie.\n\nExamples:\n    sort_by_digitsum([\"\", \"abAB\", \"abcCd\", \"helloE\"]) => [\"\", \"abcCd\", \"helloE\", \"abAB\"]",
        "examples": []
      },
      "template": "def {{ sort_by_sum_upper_character_ascii }}({{ s }}: List[str]) -> List[str]:\n    return sorted({{ s }}, key={{ digitSum }})",
      "placeholders": [
        "digitSum",
        "s",
        "sort_by_sum_upper_character_ascii"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['abAB', 'ABab']) == ['abAB', 'ABab']\n    assert candidate(['AAAAAAAA', 'zzzzzzzzz', 'B']) == ['zzzzzzzzz', 'B', 'AAAAAAAA']\n    assert candidate(['My', 'Name', 'Is', 'Hulk']) == ['Hulk', 'Is', 'My', 'Name']\n\ndef test_check():\n    check(sort_by_sum_upper_character_ascii)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "fruit_distribution",
      "arguments": [
        "s",
        "n"
      ],
      "docstring": {
        "description": "In this task, you will be given a string that represents a number of apples and oranges\nthat are distributed in a basket of fruit this basket contains\napples, oranges, and mango fruits. Given the string that represents the total number of\nthe oranges and apples and an integer that represent the total number of the fruits\nin the basket return the number of the mango fruits in the basket.",
        "examples": [
          ">>> fruit_distribution('5 apples and 6 oranges', 19)\n8",
          ">>> fruit_distribution('0 apples and 1 oranges', 3)\n2",
          ">>> fruit_distribution('2 apples and 3 oranges', 100)\n95",
          ">>> fruit_distribution('100 apples and 1 oranges', 120)\n19"
        ]
      },
      "template": "def {{ fruit_distribution }}({{ s }}: str, {{ n }}: int) -> int:\n    {{ lis }} = list()\n    for {{ i }} in {{ s }}.split(' '):\n        if {{ i }}.isdigit():\n            {{ lis }}.append(int({{ i }}))\n    return {{ n }} - sum({{ lis }})",
      "placeholders": [
        "lis",
        "i",
        "s",
        "n",
        "fruit_distribution"
      ]
    },
    "target_function": {
      "name": "happy_fruit_distribution",
      "arguments": [
        "s",
        "n"
      ],
      "docstring": {
        "description": "In this task, you will be given a string that represents a number of apples and oranges\nthat are distributed in a basket of fruit this basket contains\napples, oranges, and mango fruits. Given the string that represents the total number of\nthe oranges and apples and an integer that represent the total number of the fruits\nin the basket, your task is to check the fruit distribution is happy or not.\nThe fruit distribution is happy when the number of the mango fruits is more than the\ntotal number of remainders.",
        "examples": [
          ">>> happy_fruit_distribution('5 apples and 6 oranges', 19)\n'not happy'",
          ">>> fruit_distribution('0 apples and 1 oranges', 3)\n'happy'",
          ">>> fruit_distribution('2 apples and 3 oranges', 100)\n'happy'",
          ">>> fruit_distribution('100 apples and 1 oranges', 120)\n'not happy'"
        ]
      },
      "template": "def {{ happy_fruit_distribution }}({{ s }}: str, {{ n }}: int) -> int:\n    return 'happy' if {{ fruit_distribution }}({{ s }}, {{ n }}) > {{ n }} // 2 else 'not happy'",
      "placeholders": [
        "fruit_distribution",
        "happy_fruit_distribution",
        "s",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('3 apples and 3 oranges', 9) == 'not happy'\n    assert candidate('9 apples and 1 oranges', 21) == 'happy'\n    assert candidate('0 apples and 0 oranges', 1) == 'happy'\n\ndef test_check():\n    check(happy_fruit_distribution)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "pluck",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "\"Given an array representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a list, [ smalest_value, its index ],\nIf there are no even values or the given array is empty, return [].",
        "examples": [
          ">>> pluck([4, 2, 3])\n[2, 1]",
          ">>> pluck([1, 2, 3])\n[2, 1]",
          ">>> pluck([])\n[]",
          ">>> pluck([5, 0, 3, 0, 4, 2])\n[0, 1]"
        ]
      },
      "template": "def {{ pluck }}({{ arr }}: List[int]) -> List[int]:\n    if len({{ arr }}) == 0:\n        return []\n    {{ evens }} = list(filter(lambda x: {{ x }} % 2 == 0, {{ arr }}))\n    if {{ evens }} == []:\n        return []\n    return [min({{ evens }}), {{ arr }}.index(min({{ evens }}))]",
      "placeholders": [
        "evens",
        "x",
        "arr",
        "pluck"
      ]
    },
    "target_function": {
      "name": "pluck_and_select_larger_branch",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Given a branch represented as a list of non-negative integers,\nplucking (and then cutting) a node will result in the branch\nbeing split into two (or fewer) seperate branches.\n\nAmong the divided branches,\nreturn the one with a larger sum of the nodes that compose it.\n\nIf the sum of nodes in the divided branches is the same,\nreturn the branch with the smaller index.\n\nAssuming the sum of nodes in an empty branch is -1,\nreturn `[]` if there are only empty branches remaining after plucking.",
        "examples": [
          ">>> pluck_and_select_larger_branch([1, 3, 2, 4, 5])\n[4, 5]",
          ">>> pluck_and_select_larger_branch([1, 3, 2, 3, 1])\n[1, 3]",
          ">>> pluck_and_select_larger_branch([2, 1, 2, 1])\n[1, 2, 1]",
          ">>> pluck_and_select_larger_branch([2])\n[]",
          ">>> pluck_and_select_larger_branch([1, 3, 5, 7, 9])\n[1, 3, 5, 7, 9]"
        ]
      },
      "template": "def {{ pluck_and_select_larger_branch }}({{ arr }}: List[int]) -> List[int]:\n    {{ plucked_node }} = {{ pluck }}({{ arr }})\n    if {{ plucked_node }} == []:\n        return {{ arr }}\n    ({{ _ }}, {{ index }}) = {{ plucked_node }}\n    {{ left_branch }} = {{ arr }}[:{{ index }}]\n    {{ right_branch }} = {{ arr }}[{{ index }} + 1:]\n    {{ left_branch_value }} = sum({{ left_branch }}) if {{ left_branch }} != [] else -1\n    {{ right_branch_value }} = sum({{ right_branch }}) if {{ right_branch }} != [] else -1\n    return {{ left_branch }} if {{ left_branch_value }} >= {{ right_branch_value }} else {{ right_branch }}",
      "placeholders": [
        "index",
        "right_branch",
        "plucked_node",
        "left_branch",
        "pluck_and_select_larger_branch",
        "pluck",
        "left_branch_value",
        "_",
        "right_branch_value",
        "arr"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([33, 12, 10, 10, 1, 3, 1]) == [33, 12]\n    assert candidate([1, 7, 12, 5, 3]) == [1, 7]\n    assert candidate([12, 9, 7, 8]) == [12, 9, 7]\n    assert candidate([100]) == []\n    assert candidate([11, 21, 31, 41, 51]) == [11, 21, 31, 41, 51]\n    assert candidate([]) == []\n\ndef test_check():\n    check(pluck_and_select_larger_branch)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "search",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than\nzero, and has a frequency greater than or equal to the value of the integer itself.\nThe frequency of an integer is the number of times it appears in the list.\nIf no such a value exist, return -1.",
        "examples": [
          ">>> search([4, 1, 2, 2, 3, 1])\n2",
          ">>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n3",
          ">>> search([5, 5, 4, 4, 4])\n-1"
        ]
      },
      "template": "def {{ search }}({{ lst }}: List[int]) -> int:\n    {{ frq }} = [0] * (max({{ lst }}) + 1)\n    for {{ i }} in {{ lst }}:\n        {{ frq }}[{{ i }}] += 1\n    {{ ans }} = -1\n    for {{ i }} in range(1, len({{ frq }})):\n        if {{ frq }}[{{ i }}] >= {{ i }}:\n            {{ ans }} = {{ i }}\n    return {{ ans }}",
      "placeholders": [
        "frq",
        "search",
        "lst",
        "i",
        "ans"
      ]
    },
    "target_function": {
      "name": "remove_integers_with_higher_frequency",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Return a list obtained from the given non-empty list of positive integers\nby removing all integers whose frequency is greater than or equal to the integer itself.\n\nEnsure that the order of elements between them is preserverd.",
        "examples": [
          ">>> remove_integers_with_higher_frequency([2, 3, 3, 3, 3, 3, 4, 4])\n[2, 4, 4]",
          ">>> remove_integers_with_higher_frequency([3, 2, 4, 5, 1, 4, 3, 2])\n[3, 4, 5, 4, 3]",
          ">>> remove_integers_with_higher_frequency([2, 3, 3, 4, 4, 4])\n[2, 3, 3, 4, 4, 4]"
        ]
      },
      "template": "def {{ remove_integers_with_higher_frequency }}({{ lst }}: List[int]) -> List[int]:\n    {{ integer }} = {{ search }}({{ lst }})\n    while {{ integer }} != -1:\n        {{ lst }} = [{{ i }} for {{ i }} in {{ lst }} if {{ i }} != {{ integer }}]\n        {{ integer }} = {{ search }}({{ lst }})\n    return {{ lst }}",
      "placeholders": [
        "search",
        "lst",
        "i",
        "remove_integers_with_higher_frequency",
        "integer"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([11, 5, 4, 22, 4, 33, 5, 5, 5, 44, 4, 55, 4, 5]) == [11, 22, 33, 44, 55]\n    assert candidate([1, 5, 2, 4, 3, 5, 4, 5, 3, 1, 2, 1, 3, 4, 3, 3, 2, 5]) == [5, 4, 5, 4, 5, 4, 5]\n    assert candidate([3, 4, 4, 2, 4, 3]) == [3, 4, 4, 2, 4, 3]\n    assert candidate([10, 10, 10, 10, 10, 10, 10, 10, 10]) == [10, 10, 10, 10, 10, 10, 10, 10, 10]\n    assert candidate([100]) == [100]\n\ndef test_check():\n    check(remove_integers_with_higher_frequency)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "strange_sort_list",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given list of integers, return list in strange order.\nStrange sorting, is when you start with the minimum value,\nthen maximum of the remaining integers, then minimum and so on.",
        "examples": [
          ">>> strange_sort_list([1, 2, 3, 4])\n[1, 4, 3, 2]",
          ">>> strange_sort_list([5, 5, 5, 5])\n[5, 5, 5, 5]",
          ">>> strange_sort_list([])\n[]"
        ]
      },
      "template": "def {{ strange_sort_list }}({{ lst }}: list[int]) -> list[int]:\n    ({{ res }}, {{ switch }}) = ([], True)\n    while {{ lst }}:\n        {{ res }}.append(min({{ lst }}) if {{ switch }} else max({{ lst }}))\n        {{ lst }}.remove({{ res }}[-1])\n        {{ switch }} = not {{ switch }}\n    return {{ res }}",
      "placeholders": [
        "switch",
        "lst",
        "res",
        "strange_sort_list"
      ]
    },
    "target_function": {
      "name": "extended_strange_sort_list",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given list of integers, return list in strange order.\nExtended strange sorting, is when you start with the minimum value,\nthen maximum of the remaining integers, then maximum and minimum and so on.",
        "examples": [
          ">>> extended_strange_sort_list([1, 2, 3, 4])\n[1, 4, 3, 2]",
          ">>> extended_strange_sort_list([5, 5, 5, 5])\n[5, 5, 5, 5]",
          ">>> extended_strange_sort_list([])\n[]"
        ]
      },
      "template": "def {{ extended_strange_sort_list }}({{ lst }}: list[int]) -> list[int]:\n    {{ res }} = []\n    for {{ idx }} in range(len({{ lst }})):\n        {{ res }}.append(min({{ lst }}) if {{ idx }} % 4 in [0, 3] else max({{ lst }}))\n        {{ lst }}.remove({{ res }}[-1])\n    return {{ res }}",
      "placeholders": [
        "extended_strange_sort_list",
        "lst",
        "res",
        "idx"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([9, 2, 4, 3, 8, 9]) == [2, 9, 9, 3, 4, 8]\n    assert candidate([5, 2, 1, 7, 5, 4, 4, 9]) == [1, 9, 7, 2, 4, 5, 5, 4]\n    assert candidate([8, 7, 2, 4, 6, 5, 1, 5]) == [1, 8, 7, 2, 4, 6, 5, 5]\n\ndef test_check():\n    check(extended_strange_sort_list)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "triangle_area",
      "arguments": [
        "a",
        "b",
        "c"
      ],
      "docstring": {
        "description": "Given the lengths of the three sides of a triangle. Return the area of\nthe triangle rounded to 2 decimal points if the three sides form a valid triangle.\nOtherwise return -1\nThree sides make a valid triangle when the sum of any two sides is greater\nthan the third side.",
        "examples": [
          ">>> triangle_area(3, 4, 5)\n6.0",
          ">>> triangle_area(1, 2, 10)\n-1"
        ]
      },
      "template": "def {{ triangle_area }}({{ a }}: int, {{ b }}: int, {{ c }}: int) -> float:\n    if {{ a }} + {{ b }} <= {{ c }} or {{ a }} + {{ c }} <= {{ b }} or {{ b }} + {{ c }} <= {{ a }}:\n        return -1\n    {{ s }} = ({{ a }} + {{ b }} + {{ c }}) / 2\n    {{ area }} = ({{ s }} * ({{ s }} - {{ a }}) * ({{ s }} - {{ b }}) * ({{ s }} - {{ c }})) ** 0.5\n    {{ area }} = round({{ area }}, 2)\n    return {{ area }}",
      "placeholders": [
        "c",
        "a",
        "s",
        "triangle_area",
        "b",
        "area"
      ]
    },
    "target_function": {
      "name": "sum_of_triangle_areas",
      "arguments": [
        "triangles"
      ],
      "docstring": {
        "description": "Return the sum of the areas of all given triangles.\nEach triangle is given as a list of the lengths of its three sides.\nIf the input includes any invalid triangles, return -1.",
        "examples": [
          ">>> sum_of_triangle_areas([[3, 4, 5], [5, 12, 13]])\n36.0",
          ">>> sum_of_triangle_areas([[5, 12, 13], [1, 1, 10]])\n-1"
        ]
      },
      "template": "def {{ sum_of_triangle_areas }}({{ triangles }}: List[List[int]]) -> float:\n    {{ triangle_areas }} = [{{ triangle_area }}({{ a }}, {{ b }}, {{ c }}) for ({{ a }}, {{ b }}, {{ c }}) in {{ triangles }}]\n    if -1 in {{ triangle_areas }}:\n        return -1\n    else:\n        return sum({{ triangle_areas }})",
      "placeholders": [
        "sum_of_triangle_areas",
        "c",
        "a",
        "triangle_area",
        "triangles",
        "triangle_areas",
        "b"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[3, 4, 5], [5, 12, 13], [5, 5, 6]]) == 48.0\n    assert candidate([[6, 8, 10], [10, 10, 12]]) == 72.0\n    assert candidate([[3, 4, 5], [3, 4, 7]]) == -1.0\n\ndef test_check():\n    check(sum_of_triangle_areas)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "will_it_fly",
      "arguments": [
        "q",
        "w"
      ],
      "docstring": {
        "description": "Write a function that returns True if the object q will fly, and False otherwise.\nThe object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.",
        "examples": [
          ">>> will_it_fly([1, 2], 5)\nFalse",
          ">>> will_it_fly([3, 2, 3], 1)\nFalse",
          ">>> will_it_fly([3, 2, 3], 9)\nTrue",
          ">>> will_it_fly([3], 5)\nTrue"
        ]
      },
      "template": "def {{ will_it_fly }}({{ q }}: List[int], {{ w }}: int) -> bool:\n    if sum({{ q }}) > {{ w }}:\n        return False\n    ({{ i }}, {{ j }}) = (0, len({{ q }}) - 1)\n    while {{ i }} < {{ j }}:\n        if {{ q }}[{{ i }}] != {{ q }}[{{ j }}]:\n            return False\n        {{ i }} += 1\n        {{ j }} -= 1\n    return True",
      "placeholders": [
        "i",
        "w",
        "j",
        "will_it_fly",
        "q"
      ]
    },
    "target_function": {
      "name": "is_palindrome",
      "arguments": [
        "q"
      ],
      "docstring": {
        "description": "Write a function that determines whether a given list is a palindrome.",
        "examples": [
          ">>> is_palindrome([1, 2])\nFalse",
          ">>> is_palindrome([1, 2, 1])\nTrue"
        ]
      },
      "template": "def {{ is_palindrome }}({{ q }}: List[int]) -> bool:\n    return {{ will_it_fly }}({{ q }}, sum({{ q }}))",
      "placeholders": [
        "is_palindrome",
        "will_it_fly",
        "q"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8]) is False\n    assert candidate([1, 2, 3, 2, 1]) is True\n    assert candidate([1, 1, 1, 1]) is True\n\ndef test_check():\n    check(is_palindrome)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "smallest_change",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Given an array arr of integers, find the minimum number of elements that\nneed to be changed to make the array palindromic. A palindromic array is an array that\nis read the same backwards and forwards. In one change, you can change one element to any other element.",
        "examples": [
          ">>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n4",
          ">>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n1",
          ">>> smallest_change([1, 2, 3, 2, 1])\n0"
        ]
      },
      "template": "def {{ smallest_change }}({{ arr }}: List[int]) -> int:\n    {{ ans }} = 0\n    for {{ i }} in range(len({{ arr }}) // 2):\n        if {{ arr }}[{{ i }}] != {{ arr }}[len({{ arr }}) - {{ i }} - 1]:\n            {{ ans }} += 1\n    return {{ ans }}",
      "placeholders": [
        "i",
        "smallest_change",
        "ans",
        "arr"
      ]
    },
    "target_function": {
      "name": "is_palindrome",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Write a function that determines whether a given list is a palindrome.",
        "examples": [
          ">>> is_palindrome([1, 2])\nFalse",
          ">>> is_palindrome([1, 2, 1])\nTrue"
        ]
      },
      "template": "def {{ is_palindrome }}({{ arr }}: List[int]) -> bool:\n    return {{ smallest_change }}({{ arr }}) == 0",
      "placeholders": [
        "is_palindrome",
        "arr",
        "smallest_change"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8]) is False\n    assert candidate([1, 2, 3, 2, 1]) is True\n    assert candidate([1, 1, 1, 1]) is True\n\ndef test_check():\n    check(is_palindrome)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "total_match",
      "arguments": [
        "lst1",
        "lst2"
      ],
      "docstring": {
        "description": "Write a function that accepts two lists of strings and returns the list that has\ntotal number of chars in the all strings of the list less than the other list.\n\nif the two lists have the same number of chars, return the first list.",
        "examples": [
          ">>> total_match([], [])\n[]",
          ">>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n['hI', 'Hi']",
          ">>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n['hi', 'admin']",
          ">>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n['hI', 'hi', 'hi']",
          ">>> total_match(['4'], ['1', '2', '3', '4', '5'])\n['4']"
        ]
      },
      "template": "def {{ total_match }}({{ lst1 }}: List[str], {{ lst2 }}: List[str]) -> List[str]:\n    {{ l1 }} = 0\n    for {{ st }} in {{ lst1 }}:\n        {{ l1 }} += len({{ st }})\n    {{ l2 }} = 0\n    for {{ st }} in {{ lst2 }}:\n        {{ l2 }} += len({{ st }})\n    if {{ l1 }} <= {{ l2 }}:\n        return {{ lst1 }}\n    else:\n        return {{ lst2 }}",
      "placeholders": [
        "l1",
        "l2",
        "lst2",
        "st",
        "total_match",
        "lst1"
      ]
    },
    "target_function": {
      "name": "total_match_three",
      "arguments": [
        "lst1",
        "lst2",
        "lst3"
      ],
      "docstring": {
        "description": "Return the list of strings with the smallest total number of characters\namong the three string lists.\nIf some lists have the same total number of characters,\nreturn the list that appears ealier.",
        "examples": [
          ">>> total_match_three(['a'], ['a', 'b'], ['a', 'b', 'c'])\n['a']",
          ">>> total_match_three(['abcd'], ['a', 'b'])\n['a', 'b']",
          ">>> total_match_three(['a'], ['b'], ['c'])\n['a']"
        ]
      },
      "template": "def {{ total_match_three }}({{ lst1 }}: List[str], {{ lst2 }}: List[str], {{ lst3 }}: List[str]) -> List[str]:\n    return {{ total_match }}({{ total_match }}({{ lst1 }}, {{ lst2 }}), {{ lst3 }})",
      "placeholders": [
        "lst3",
        "lst2",
        "total_match",
        "total_match_three",
        "lst1"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['total', 'match', 'three'], ['I', 'love', 'you'], ['This', 'is', 'good']) == ['I', 'love', 'you']\n    assert candidate(['a', 'aa', 'aaa'], ['aaaaa'], ['aaaaaaa']) == ['aaaaa']\n    assert candidate(['a', 'bcd'], ['ab', 'cd'], ['abc', 'd']) == ['a', 'bcd']\n\ndef test_check():\n    check(total_match_three)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "is_multiply_prime",
      "arguments": [
        "a"
      ],
      "docstring": {
        "description": "Write a function that returns true if the given number is the multiplication of 3 prime numbers\nand false otherwise.\nKnowing that (a) is less then 100.",
        "examples": [
          ">>> is_multiply_prime(30)\nTrue"
        ]
      },
      "template": "def {{ is_multiply_prime }}({{ a }}: int) -> bool:\n\n    def {{ is_prime }}({{ n }}):\n        for {{ j }} in range(2, {{ n }}):\n            if {{ n }} % {{ j }} == 0:\n                return False\n        return True\n    for {{ i }} in range(2, 101):\n        if not {{ is_prime }}({{ i }}):\n            continue\n        for {{ j }} in range(2, 101):\n            if not {{ is_prime }}({{ j }}):\n                continue\n            for {{ k }} in range(2, 101):\n                if not {{ is_prime }}({{ k }}):\n                    continue\n                if {{ i }} * {{ j }} * {{ k }} == {{ a }}:\n                    return True\n    return False",
      "placeholders": [
        "i",
        "a",
        "is_prime",
        "k",
        "n",
        "j",
        "is_multiply_prime"
      ]
    },
    "target_function": {
      "name": "sum_of_multiply_primes",
      "arguments": [
        "nums"
      ],
      "docstring": {
        "description": "Return the sum of numbers among the given numbers\nthat can be expressed as the product of three prime numbers.",
        "examples": [
          ">>> sum_of_multiply_prime([30, 42])\n72",
          ">>> sum_of_multiply_prime([30, 35, 40, 42])\n72"
        ]
      },
      "template": "def {{ sum_of_multiply_primes }}({{ nums }}: List[int]) -> int:\n    return sum([{{ n }} for {{ n }} in {{ nums }} if {{ is_multiply_prime }}({{ n }})])",
      "placeholders": [
        "nums",
        "sum_of_multiply_primes",
        "n",
        "is_multiply_prime"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([30, 42, 66, 70, 78]) == 286\n    assert candidate([25, 40, 55, 72, 77]) == 0\n    assert candidate([25, 30, 40, 42, 55, 66, 70, 72, 77, 78]) == 286\n\ndef test_check():\n    check(sum_of_multiply_primes)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "is_simple_power",
      "arguments": [
        "x",
        "n"
      ],
      "docstring": {
        "description": "Your task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x",
        "examples": [
          ">>> is_simple_power(1, 4)\nTrue",
          ">>> is_simple_power(2, 2)\nTrue",
          ">>> is_simple_power(8, 2)\nTrue",
          ">>> is_simple_power(3, 2)\nFalse",
          ">>> is_simple_power(3, 1)\nFalse",
          ">>> is_simple_power(5, 3)\nFalse"
        ]
      },
      "template": "def {{ is_simple_power }}({{ x }}: int, {{ n }}: int) -> bool:\n    if {{ n }} == 1:\n        return {{ x }} == 1\n    {{ power }} = 1\n    while {{ power }} < {{ x }}:\n        {{ power }} = {{ power }} * {{ n }}\n    return {{ power }} == {{ x }}",
      "placeholders": [
        "power",
        "x",
        "is_simple_power",
        "n"
      ]
    },
    "target_function": {
      "name": "log",
      "arguments": [
        "n",
        "x"
      ],
      "docstring": {
        "description": "Implement a function that calculates the value log_n(x)\nand returns it if it is an integer, otherwise returns -1.",
        "examples": [
          ">>> log(2, 8)\n3",
          ">>> log(2, 3)\n-1"
        ]
      },
      "template": "def {{ log }}({{ n }}: int, {{ x }}: int) -> int:\n    if {{ is_simple_power }}({{ x }}, {{ n }}):\n        {{ value }} = 0\n        while {{ x }} > 1:\n            {{ x }} /= {{ n }}\n            {{ value }} += 1\n        return {{ value }}\n    else:\n        return -1",
      "placeholders": [
        "x",
        "log",
        "n",
        "is_simple_power",
        "value"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(2, 1024) == 10\n    assert candidate(3, 27) == 3\n    assert candidate(3, 8) == -1\n\ndef test_check():\n    check(log)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "iscube",
      "arguments": [
        "a"
      ],
      "docstring": {
        "description": "Write a function that takes an integer a and returns True\nif this ingeger is a cube of some integer number.\nNote: you may assume the input is always valid.",
        "examples": [
          ">>> iscube(1)\nTrue",
          ">>> iscube(2)\nFalse",
          ">>> iscube(-1)\nTrue",
          ">>> iscube(64)\nTrue",
          ">>> iscube(0)\nTrue",
          ">>> iscube(180)\nFalse"
        ]
      },
      "template": "def {{ iscube }}({{ a }}: int) -> bool:\n    {{ a }} = abs({{ a }})\n    return int(round({{ a }} ** (1.0 / 3))) ** 3 == {{ a }}",
      "placeholders": [
        "iscube",
        "a"
      ]
    },
    "target_function": {
      "name": "num_cube_pairs",
      "arguments": [
        "nums1",
        "nums2"
      ],
      "docstring": {
        "description": "Find the number of pairs (n1, n2) where n1 + n2 equals to\na cube of some integer number. (n1 in nums1 and n2 in nums2)",
        "examples": [
          ">>> num_cube_pairs([1, 2, 3], [1, 2, 3])\n0",
          ">>> num_cube_pairs([1, 2, 3], [5, 6])\n2"
        ]
      },
      "template": "def {{ num_cube_pairs }}({{ nums1 }}: List[int], {{ nums2 }}: List[int]) -> int:\n    return len([1 for {{ n1 }} in {{ nums1 }} for {{ n2 }} in {{ nums2 }} if {{ iscube }}({{ n1 }} + {{ n2 }})])",
      "placeholders": [
        "iscube",
        "n2",
        "num_cube_pairs",
        "n1",
        "nums2",
        "nums1"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == 1\n    assert candidate([1, 2, 3, 4], [-2, 0, 2, 4]) == 5\n    assert candidate([5, 25], [39, 100]) == 2\n\ndef test_check():\n    check(num_cube_pairs)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "hex_key",
      "arguments": [
        "num"
      ],
      "docstring": {
        "description": "You have been tasked to write a function that receives\na hexadecimal number as a string and counts the number of hexadecimal\ndigits that are primes (prime number, or a prime, is a natural number\ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7,\nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string,\nand symbols A,B,C,D,E,F are always uppercase.",
        "examples": [
          ">>> hex_key('AB')\n1",
          ">>> hex_key('1077E')\n2",
          ">>> hex_key('ABED1A33')\n4",
          ">>> hex_key('123456789ABCDEF0')\n6",
          ">>> hex_key('2020')\n2"
        ]
      },
      "template": "def {{ hex_key }}({{ num }}: str) -> int:\n    {{ primes }} = ('2', '3', '5', '7', 'B', 'D')\n    {{ total }} = 0\n    for {{ i }} in range(0, len({{ num }})):\n        if {{ num }}[{{ i }}] in {{ primes }}:\n            {{ total }} += 1\n    return {{ total }}",
      "placeholders": [
        "i",
        "num",
        "total",
        "hex_key",
        "primes"
      ]
    },
    "target_function": {
      "name": "num_not_hex_primes",
      "arguments": [
        "num"
      ],
      "docstring": {
        "description": "Count the number of hexadecimal digits in the given hexadecimal string\nthat are not prime.",
        "examples": [
          ">>> num_not_hex_primes('AB')\n1",
          ">>> num_not_hex_primes('1077E')\n3"
        ]
      },
      "template": "def {{ num_not_hex_primes }}({{ num }}: str) -> int:\n    return len({{ num }}) - {{ hex_key }}({{ num }})",
      "placeholders": [
        "num_not_hex_primes",
        "hex_key",
        "num"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('12345678') == 4\n    assert candidate('ABCDEF') == 4\n    assert candidate('11AA22BB33CC44DD') == 8\n\ndef test_check():\n    check(num_not_hex_primes)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "decimal_to_binary",
      "arguments": [
        "decimal"
      ],
      "docstring": {
        "description": "You will be given a number in decimal form and your task is to convert it to\nbinary format. The function should return a string, with each character representing a binary\nnumber. Each character in the string will be '0' or '1'.\n\nThere will be an extra couple of characters 'db' at the beginning and at the end of the string.\nThe extra characters are there to help with the format.",
        "examples": [
          ">>> decimal_to_binary(15)\n'db1111db'",
          ">>> decimal_to_binary(32)\n'db100000db'"
        ]
      },
      "template": "def {{ decimal_to_binary }}({{ decimal }}: int) -> str:\n    return 'db' + bin({{ decimal }})[2:] + 'db'",
      "placeholders": [
        "decimal_to_binary",
        "decimal"
      ]
    },
    "target_function": {
      "name": "num_1s_in_binary",
      "arguments": [
        "decimal"
      ],
      "docstring": {
        "description": "Return the count of digit 1 in the binary representation of the given number.",
        "examples": [
          ">>> num_1s_in_binary(15)\n4",
          ">>> num_1s_in_binary(32)\n1"
        ]
      },
      "template": "def {{ num_1s_in_binary }}({{ decimal }}: int) -> int:\n    return {{ decimal_to_binary }}({{ decimal }}).count('1')",
      "placeholders": [
        "decimal_to_binary",
        "decimal",
        "num_1s_in_binary"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(1000) == 6\n    assert candidate(1023) == 10\n    assert candidate(1024) == 1\n\ndef test_check():\n    check(num_1s_in_binary)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "is_happy",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "You are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct",
        "examples": [
          ">>> is_happy('a')\nFalse",
          ">>> is_happy('aa')\nFalse",
          ">>> is_happy('abcd')\nTrue",
          ">>> is_happy('aabb')\nFalse",
          ">>> is_happy('adb')\nTrue",
          ">>> is_happy('xyy')\nFalse"
        ]
      },
      "template": "def {{ is_happy }}({{ s }}: str) -> bool:\n    if len({{ s }}) < 3:\n        return False\n    for {{ i }} in range(len({{ s }}) - 2):\n        if {{ s }}[{{ i }}] == {{ s }}[{{ i }} + 1] or {{ s }}[{{ i }} + 1] == {{ s }}[{{ i }} + 2] or {{ s }}[{{ i }}] == {{ s }}[{{ i }} + 2]:\n            return False\n    return True",
      "placeholders": [
        "i",
        "s",
        "is_happy"
      ]
    },
    "target_function": {
      "name": "num_happy_sentences",
      "arguments": [
        "d"
      ],
      "docstring": {
        "description": "Implement a function that, given a document d where sentences are concatenated\n    with newlines as separators, returns the count of happy sentences.",
        "examples": [
          ">>> num_happy_sentences('a\naa')",
          ">>> num_happy_sentences('abcd\naabb"
        ]
      },
      "template": "def {{ num_happy_sentences }}({{ d }}: str) -> int:\n    return len([1 for {{ s }} in {{ d }}.splitlines() if {{ is_happy }}({{ s }})])",
      "placeholders": [
        "is_happy",
        "s",
        "num_happy_sentences",
        "d"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('aaa\\nababab\\nabcabcabc') == 1\n    assert candidate('a\\nab\\nabc\\nabcd') == 2\n    assert candidate('numhappysentences\\niloveyou\\nthisisgood') == 1\n\ndef test_check():\n    check(num_happy_sentences)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "numerical_letter_grade",
      "arguments": [
        "grades"
      ],
      "docstring": {
        "description": "It is the last week of the semester and the teacher has to give the grades\nto students. The teacher has been making her own algorithm for grading.\nThe only problem is, she has lost the code she used for grading.\nShe has given you a list of GPAs for some students and you have to write\na function that can output a list of letter grades using the following table:\n         GPA       |    Letter grade\n          4.0                A+\n        > 3.7                A\n        > 3.3                A-\n        > 3.0                B+\n        > 2.7                B\n        > 2.3                B-\n        > 2.0                C+\n        > 1.7                C\n        > 1.3                C-\n        > 1.0                D+\n        > 0.7                D\n        > 0.0                D-\n          0.0                E",
        "examples": [
          ">>> grade_equation([4.0, 3, 1.7, 2, 3.5])\n['A+', 'B', 'C-', 'C', 'A-']"
        ]
      },
      "template": "def {{ numerical_letter_grade }}({{ grades }}: List[float]) -> List[str]:\n    {{ letter_grade }} = []\n    for {{ gpa }} in {{ grades }}:\n        if {{ gpa }} == 4.0:\n            {{ letter_grade }}.append('A+')\n        elif {{ gpa }} > 3.7:\n            {{ letter_grade }}.append('A')\n        elif {{ gpa }} > 3.3:\n            {{ letter_grade }}.append('A-')\n        elif {{ gpa }} > 3.0:\n            {{ letter_grade }}.append('B+')\n        elif {{ gpa }} > 2.7:\n            {{ letter_grade }}.append('B')\n        elif {{ gpa }} > 2.3:\n            {{ letter_grade }}.append('B-')\n        elif {{ gpa }} > 2.0:\n            {{ letter_grade }}.append('C+')\n        elif {{ gpa }} > 1.7:\n            {{ letter_grade }}.append('C')\n        elif {{ gpa }} > 1.3:\n            {{ letter_grade }}.append('C-')\n        elif {{ gpa }} > 1.0:\n            {{ letter_grade }}.append('D+')\n        elif {{ gpa }} > 0.7:\n            {{ letter_grade }}.append('D')\n        elif {{ gpa }} > 0.0:\n            {{ letter_grade }}.append('D-')\n        else:\n            {{ letter_grade }}.append('E')\n    return {{ letter_grade }}",
      "placeholders": [
        "letter_grade",
        "gpa",
        "numerical_letter_grade",
        "grades"
      ]
    },
    "target_function": {
      "name": "num_students_above_C",
      "arguments": [
        "grades"
      ],
      "docstring": {
        "description": "Given a list of students' GPAs, return the number of students\nwho will receive a grade of B- or higher.",
        "examples": [
          ">>> num_students_above_C([4.0, 3, 1.7, 2, 3.5])\n3"
        ]
      },
      "template": "def {{ num_students_above_C }}({{ grades }}: List[float]) -> int:\n    {{ grades }} = {{ numerical_letter_grade }}({{ grades }})\n    return len([1 for {{ grade }} in {{ grades }} if {{ grade }}[0] < 'C'])",
      "placeholders": [
        "numerical_letter_grade",
        "grade",
        "grades",
        "num_students_above_C"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([0.0, 1.0, 2.0, 3.0, 4.0]) == 2\n    assert candidate([2.1, 2.2, 2.3, 2.4, 2.5]) == 2\n    assert candidate([1.4, 2.8, 2.0, 3.5, 3.0, 2.1, 0.7]) == 3\n\ndef test_check():\n    check(num_students_above_C)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "prime_length",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Write a function that takes a string and returns True if the string\nlength is a prime number or False otherwise",
        "examples": [
          ">>> prime_length('Hello')\nTrue",
          ">>> prime_length('abcdcba')\nTrue",
          ">>> prime_length('kittens')\nTrue",
          ">>> prime_length('orange')\nFalse"
        ]
      },
      "template": "def {{ prime_length }}({{ string }}: str) -> bool:\n    {{ l }} = len({{ string }})\n    if {{ l }} == 0 or {{ l }} == 1:\n        return False\n    for {{ i }} in range(2, {{ l }}):\n        if {{ l }} % {{ i }} == 0:\n            return False\n    return True",
      "placeholders": [
        "l",
        "i",
        "prime_length",
        "string"
      ]
    },
    "target_function": {
      "name": "is_concat_length_prime",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Implement a function that checks whether the length of the string\nobtained by concatenating the given strings is a prime number.",
        "examples": [
          ">>> is_concat_length_prime(['He', 'llo'])\nTrue",
          ">>> is_concat_length_prime(['or', 'an', 'ge'])\nFalse"
        ]
      },
      "template": "def {{ is_concat_length_prime }}({{ strings }}: List[str]) -> bool:\n    return {{ prime_length }}(''.join({{ strings }}))",
      "placeholders": [
        "prime_length",
        "is_concat_length_prime",
        "strings"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['ab', 'abc', 'abcd', 'ab']) is True\n    assert candidate(['aaaaaaaaaa', 'aaaaa']) is False\n    assert candidate(['is', 'concat', 'length', 'prime']) is True\n\ndef test_check():\n    check(is_concat_length_prime)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "starts_one_ends",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Given a positive integer n, return the count of the numbers of n-digit\npositive integers that start or end with 1.",
        "examples": []
      },
      "template": "def {{ starts_one_ends }}({{ n }}: int) -> int:\n    if {{ n }} == 1:\n        return 1\n    return 18 * 10 ** ({{ n }} - 2)",
      "placeholders": [
        "starts_one_ends",
        "n"
      ]
    },
    "target_function": {
      "name": "non_starts_or_ends_with_one_count",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Return the count of n-digit positive integers\nthat do not start or end with 1.",
        "examples": [
          ">>> non_starts_or_ends_with_one_count(1)\n8",
          ">>> non_starts_or_ends_with_one_count(2)\n72"
        ]
      },
      "template": "def {{ non_starts_or_ends_with_one_count }}({{ n }}: int) -> int:\n    return len(range(10 ** ({{ n }} - 1), 10 ** {{ n }})) - {{ starts_one_ends }}({{ n }})",
      "placeholders": [
        "starts_one_ends",
        "n",
        "non_starts_or_ends_with_one_count"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(3) == 720\n    assert candidate(4) == 7200\n    assert candidate(5) == 72000\n\ndef test_check():\n    check(non_starts_or_ends_with_one_count)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "solve",
      "arguments": [
        "N"
      ],
      "docstring": {
        "description": "Given a positive integer N, return the total sum of its digits in binary.",
        "examples": [
          ">>> solve(1000)\n'1'",
          ">>> solve(150)\n'110'",
          ">>> solve(147)\n'1100'"
        ]
      },
      "template": "def {{ solve }}({{ N }}: int) -> str:\n    return bin(sum((int({{ i }}) for {{ i }} in str({{ N }}))))[2:]",
      "placeholders": [
        "i",
        "N",
        "solve"
      ]
    },
    "target_function": {
      "name": "sum_digits_to_binary",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Calculate the sum of numerical characters in the given string\nand return it as a binary representation.",
        "examples": [
          ">>> sum_digits_to_binary('10a00')\n'1'",
          ">>> sum_digits_to_binary('a1b5c0d')\n'110'"
        ]
      },
      "template": "def {{ sum_digits_to_binary }}({{ string }}: str) -> str:\n    {{ digits }} = ''.join([{{ c }} for {{ c }} in {{ string }} if {{ c }}.isdecimal()])\n    return {{ solve }}(int({{ digits }}))",
      "placeholders": [
        "string",
        "c",
        "digits",
        "solve",
        "sum_digits_to_binary"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('1234') == '1010'\n    assert candidate('a3b2c1d0e') == '110'\n    assert candidate('sum2digits9to4binary1') == '10000'\n\ndef test_check():\n    check(sum_digits_to_binary)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "add",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a non-empty list of integers lst. add the even elements that are at odd indices..",
        "examples": [
          ">>> add([4, 2, 6, 7])\n2"
        ]
      },
      "template": "def {{ add }}({{ lst }}: List[int]) -> int:\n    return sum([{{ lst }}[{{ i }}] for {{ i }} in range(1, len({{ lst }}), 2) if {{ lst }}[{{ i }}] % 2 == 0])",
      "placeholders": [
        "i",
        "lst",
        "add"
      ]
    },
    "target_function": {
      "name": "sum_even_second_digits",
      "arguments": [
        "number"
      ],
      "docstring": {
        "description": "Return the sum of even numbers among every second digit in the given number.",
        "examples": [
          ">>> sum_even_second_digits(4267)\n2"
        ]
      },
      "template": "def {{ sum_even_second_digits }}({{ number }}: int) -> int:\n    return {{ add }}([int({{ c }}) for {{ c }} in str({{ number }})])",
      "placeholders": [
        "c",
        "number",
        "sum_even_second_digits",
        "add"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(123456) == 12\n    assert candidate(234567) == 0\n    assert candidate(202307102232) == 4\n\ndef test_check():\n    check(sum_even_second_digits)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "anti_shuffle",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Write a function that takes a string and returns an ordered version of it.\nOrdered version of string, is a string where all words (separated by space)\nare replaced by a new word where all the characters arranged in\nascending order based on ascii value.\nNote: You should keep the order of words and blank spaces in the sentence.",
        "examples": [
          ">>> anti_shuffle('Hi')\n'Hi'",
          ">>> anti_shuffle('hello')\n'ehllo'",
          ">>> anti_shuffle('Hello World!!!')\n'Hello !!!Wdlor'"
        ]
      },
      "template": "def {{ anti_shuffle }}({{ s }}: str) -> str:\n    return ' '.join([''.join(sorted(list({{ i }}))) for {{ i }} in {{ s }}.split(' ')])",
      "placeholders": [
        "i",
        "s",
        "anti_shuffle"
      ]
    },
    "target_function": {
      "name": "sort_and_concatenate_strings",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Implement a function that takes a list of strings,\nsorts each string in ascending order,\nand then concatenates them using a space as the separator.",
        "examples": [
          ">>> sort_and_concatenate_strings(['hello'])\n'ehllo'",
          ">>> sort_and_concatenate_strings(['Hello', 'World!!!'])\n'Hello !!!Wdlor'"
        ]
      },
      "template": "def {{ sort_and_concatenate_strings }}({{ strings }}: List[str]) -> str:\n    return {{ anti_shuffle }}(' '.join({{ strings }}))",
      "placeholders": [
        "sort_and_concatenate_strings",
        "strings",
        "anti_shuffle"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['abcd', 'dcba', 'bdac']) == 'abcd abcd abcd'\n    assert candidate(['sort', 'and', 'concatenate', 'strings']) == 'orst adn aacceennott ginrsst'\n    assert candidate(['heLLo', 'worLd!']) == 'LLeho !Ldorw'\n\ndef test_check():\n    check(sort_and_concatenate_strings)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "get_row",
      "arguments": [
        "lst",
        "x"
      ],
      "docstring": {
        "description": "You are given a 2 dimensional data, as a nested lists,\nwhich is similar to matrix, however, unlike matrices,\neach row may contain a different number of columns.\nGiven lst, and integer x, find integers x in the list,\nand return list of tuples, [(x1, y1), (x2, y2) ...] such that\neach tuple is a coordinate - (row, columns), starting with 0.\nSort coordinates initially by rows in ascending order.\nAlso, sort coordinates of the row by columns in descending order.",
        "examples": [
          ">>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]",
          ">>> get_row([], 1)\n[]",
          ">>> get_row([[], [1], [1, 2, 3]], 3)\n[(2, 2)]"
        ]
      },
      "template": "def {{ get_row }}({{ lst }}: List[List[int]], {{ x }}: int) -> List[Tuple[int, int]]:\n    {{ coords }} = [({{ i }}, {{ j }}) for {{ i }} in range(len({{ lst }})) for {{ j }} in range(len({{ lst }}[{{ i }}])) if {{ lst }}[{{ i }}][{{ j }}] == {{ x }}]\n    return sorted(sorted({{ coords }}, key=lambda x: {{ x }}[1], reverse=True), key=lambda x: {{ x }}[0])",
      "placeholders": [
        "lst",
        "i",
        "x",
        "j",
        "get_row",
        "coords"
      ]
    },
    "target_function": {
      "name": "count_integer_in_nested_lists",
      "arguments": [
        "lst",
        "x"
      ],
      "docstring": {
        "description": "Implement a function that counts how many times an integer x appears\nin a list of lists of integers.",
        "examples": [
          ">>> count_integer_in_nested_lists([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n5",
          ">>> count_integer_in_nested_lists([[], [1], [1, 2, 3]], 3)\n1"
        ]
      },
      "template": "def {{ count_integer_in_nested_lists }}({{ lst }}: List[List[int]], {{ x }}: int) -> int:\n    return len({{ get_row }}({{ lst }}, {{ x }}))",
      "placeholders": [
        "count_integer_in_nested_lists",
        "x",
        "get_row",
        "lst"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[0, 0, 0, 0, 0], [0, 0, 1, 0], [1, 1, 1]], 1) == 4\n    assert candidate([[1, 3, 5, 7, 9], [], [3, 4, 5, 6, 7], []], 2) == 0\n    assert candidate([[3, 3, 3, 3, 3], [3, 3, 3], [3]], 3) == 9\n\ndef test_check():\n    check(count_integer_in_nested_lists)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "sort_array",
      "arguments": [
        "array"
      ],
      "docstring": {
        "description": "Given an array of non-negative integers, return a copy of the given array after sorting,\nyou will sort the given array in ascending order if the sum( first index value, last index value) is odd,\nor sort it in descending order if the sum( first index value, last index value) is even.\n\nNote:\n* don't change the given array.",
        "examples": [
          ">>> sort_array([])\n[]",
          ">>> sort_array([5])\n[5]",
          ">>> sort_array([2, 4, 3, 0, 1, 5])\n[0, 1, 2, 3, 4, 5]",
          ">>> sort_array([2, 4, 3, 0, 1, 5, 6])\n[6, 5, 4, 3, 2, 1, 0]"
        ]
      },
      "template": "def {{ sort_array }}({{ array }}: List[int]) -> List[int]:\n    return [] if len({{ array }}) == 0 else sorted({{ array }}, reverse=({{ array }}[0] + {{ array }}[-1]) % 2 == 0)",
      "placeholders": [
        "sort_array",
        "array"
      ]
    },
    "target_function": {
      "name": "count_elements_in_original_position",
      "arguments": [
        "array"
      ],
      "docstring": {
        "description": "Given an integer array, return the count of elements that remain in their original positions\nwhen the array is sorted in ascending order if the sum of the first and last elements is odd,\nor in descending order if the sum is even.",
        "examples": [
          ">>> count_elements_in_original_position([2, 4, 3, 0, 1, 5])\n1",
          ">>> count_elements_in_original_position([2, 4, 3, 0, 1, 5, 6])\n0"
        ]
      },
      "template": "def {{ count_elements_in_original_position }}({{ array }}: List[int]) -> int:\n    {{ sorted_array }} = {{ sort_array }}({{ array }})\n    return len([1 for ({{ a }}, {{ b }}) in zip({{ array }}, {{ sorted_array }}) if {{ a }} == {{ b }}])",
      "placeholders": [
        "array",
        "sorted_array",
        "a",
        "b",
        "sort_array",
        "count_elements_in_original_position"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([10, 2, 8, 3, 1, 5, 4, 7, 9, 6]) == 4\n    assert candidate([6, 8, 3, 1, 5, 7, 4, 2, 9]) == 3\n    assert candidate([1, 3, 5, 3, 1, 3, 5]) == 1\n\ndef test_check():\n    check(count_elements_in_original_position)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "encrypt",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Create a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated.\nThe alphabet should be rotated in a manner such that the letters\nshift down by two multiplied to two places.",
        "examples": [
          ">>> encrypt('hi')\n'lm'",
          ">>> encrypt('asdfghjkl')\n'ewhjklnop'",
          ">>> encrypt('gf')\n'kj'",
          ">>> encrypt('et')\n'ix'"
        ]
      },
      "template": "def {{ encrypt }}({{ s }}: str) -> str:\n    {{ d }} = 'abcdefghijklmnopqrstuvwxyz'\n    {{ out }} = ''\n    for {{ c }} in {{ s }}:\n        if {{ c }} in {{ d }}:\n            {{ out }} += {{ d }}[({{ d }}.index({{ c }}) + 2 * 2) % 26]\n        else:\n            {{ out }} += {{ c }}\n    return {{ out }}",
      "placeholders": [
        "c",
        "d",
        "encrypt",
        "s",
        "out"
      ]
    },
    "target_function": {
      "name": "is_start_of_end_with_x_after_encryption",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Implement a function that determines whether a given string starts or ends with 'x' after encryption.",
        "examples": [
          ">>> is_start_of_end_with_x_after_encryption('gf')\nFalse",
          ">>> is_start_of_end_with_x_after_encryption('et')\nTrue"
        ]
      },
      "template": "def {{ is_start_of_end_with_x_after_encryption }}({{ string }}: str) -> bool:\n    {{ string }} = {{ encrypt }}({{ string }})\n    return {{ string }}[0] == 'x' or {{ string }}[-1] == 'x'",
      "placeholders": [
        "string",
        "encrypt",
        "is_start_of_end_with_x_after_encryption"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('abcdttttefgh') is False\n    assert candidate('abcdefght') is True\n    assert candidate('tttttttttt') is True\n\ndef test_check():\n    check(is_start_of_end_with_x_after_encryption)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Optional"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "next_smallest",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "You are given a list of integers.\nWrite a function next_smallest() that returns the 2nd smallest element of the list.\nReturn None if there is no such element.",
        "examples": [
          ">>> next_smallest([1, 2, 3, 4, 5])\n2",
          ">>> next_smallest([5, 1, 4, 3, 2])\n2",
          ">>> next_smallest([])\nNone",
          ">>> next_smallest([1, 1])\nNone"
        ]
      },
      "template": "def {{ next_smallest }}({{ lst }}: List[int]) -> Optional[int]:\n    {{ lst }} = sorted(set({{ lst }}))\n    return None if len({{ lst }}) < 2 else {{ lst }}[1]",
      "placeholders": [
        "lst",
        "next_smallest"
      ]
    },
    "target_function": {
      "name": "remove_second_smallest",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Return the list obtained by removing the second smallest value(s) from the given integer list.\nIf there is no such value, return the original integer list.",
        "examples": [
          ">>> remove_second_smallest([1, 2, 3, 4, 5])\n[1, 3, 4, 5]",
          ">>> remove_second_smallest([1, 1])\n[1, 1]",
          ">>> remove_second_smallest([1, 1, 2, 2])\n[1, 1]"
        ]
      },
      "template": "def {{ remove_second_smallest }}({{ lst }}: List[int]) -> List[int]:\n    {{ second_smallest }} = {{ next_smallest }}({{ lst }})\n    if {{ second_smallest }} is not None:\n        {{ lst }} = [{{ n }} for {{ n }} in {{ lst }} if {{ n }} != {{ second_smallest }}]\n    return {{ lst }}",
      "placeholders": [
        "lst",
        "second_smallest",
        "next_smallest",
        "remove_second_smallest",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([5, 7, 1, 10, 2, 8, 9, 3, 4, 6]) == [5, 7, 1, 10, 8, 9, 3, 4, 6]\n    assert candidate([1, 2, 2, 3, 3, 3, 3, 2, 1]) == [1, 3, 3, 3, 3, 1]\n    assert candidate([2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n\ndef test_check():\n    check(remove_second_smallest)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "is_bored",
      "arguments": [
        "S"
      ],
      "docstring": {
        "description": "You'll be given a string of words, and your task is to count the number\nof boredoms. A boredom is a sentence that starts with the word \"I\".\nSentences are delimited by '.', '?' or '!'.",
        "examples": [
          ">>> is_bored('Hello world')\n0",
          ">>> is_bored('The sky is blue. The sun is shining. I love this weather')\n1"
        ]
      },
      "template": "def {{ is_bored }}({{ S }}: str) -> int:\n    import re\n    {{ sentences }} = re.split('[.?!]\\\\s*', {{ S }})\n    return sum(({{ sentence }}[0:2] == 'I ' for {{ sentence }} in {{ sentences }}))",
      "placeholders": [
        "is_bored",
        "S",
        "sentence",
        "sentences"
      ]
    },
    "target_function": {
      "name": "count_non_boredoms",
      "arguments": [
        "string"
      ],
      "docstring": {
        "description": "Return the count of non-boredoms in the given string.\nHere, boredom refers to sentences starting with the word 'I',\nand sentences are separated by '.', '?', or '!'.\nNote that empty sentences are not counted.",
        "examples": [
          ">>> is_bored('Hello world')\n1",
          ">>> is_bored('The sky is blue. The sun is shining. I love this weather')\n2",
          ">>> is_bored('. ? !')\n0"
        ]
      },
      "template": "def {{ count_non_boredoms }}({{ string }}: str) -> int:\n    {{ sentences }} = {{ string }}.replace('?', '.').replace('!', '.').split('.')\n    {{ num_sentences }} = len([{{ sentence }} for {{ sentence }} in {{ sentences }} if len({{ sentence }}.strip()) > 0])\n    return {{ num_sentences }} - {{ is_bored }}({{ string }})",
      "placeholders": [
        "string",
        "num_sentences",
        "sentence",
        "count_non_boredoms",
        "is_bored",
        "sentences"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('aa. bb? cc! dd. ee? ff!') == 6\n    assert candidate('You and I... A I!!') == 2\n    assert candidate('Count non boredoms. This is good? I love you!') == 2\n\ndef test_check():\n    check(count_non_boredoms)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "any_int",
      "arguments": [
        "x",
        "y",
        "z"
      ],
      "docstring": {
        "description": "Create a function that takes 3 numbers.\nReturns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\nReturns false in any other cases.",
        "examples": [
          ">>> any_int(5, 2, 7)\nTrue",
          ">>> any_int(3, 2, 2)\nFalse",
          ">>> any_int(3, -2, 1)\nTrue",
          ">>> any_int(3.6, -2.2, 2)\nFalse"
        ]
      },
      "template": "def {{ any_int }}({{ x }}: float, {{ y }}: float, {{ z }}: float) -> bool:\n    if isinstance({{ x }}, int) and isinstance({{ y }}, int) and isinstance({{ z }}, int):\n        if {{ x }} + {{ y }} == {{ z }} or {{ x }} + {{ z }} == {{ y }} or {{ y }} + {{ z }} == {{ x }}:\n            return True\n        return False\n    return False",
      "placeholders": [
        "z",
        "any_int",
        "x",
        "y"
      ]
    },
    "target_function": {
      "name": "count_integer_sum_cases",
      "arguments": [
        "xs",
        "ys",
        "zs"
      ],
      "docstring": {
        "description": "Return the count of cases where,\nby selecting one element from each of the three given lists,\nif all three selected elements are integers\nand one element can be expressed as the sum of the other two elements.",
        "examples": [
          ">>> count_integer_sum_cases([5, 10], [2], [7])\n1",
          ">>> count_integer_sum_cases([3], [2, -2], [2, 1])\n2"
        ]
      },
      "template": "def {{ count_integer_sum_cases }}({{ xs }}: List[float], {{ ys }}: List[float], {{ zs }}: List[float]) -> int:\n    return len([1 for {{ x }} in {{ xs }} for {{ y }} in {{ ys }} for {{ z }} in {{ zs }} if {{ any_int }}({{ x }}, {{ y }}, {{ z }})])",
      "placeholders": [
        "count_integer_sum_cases",
        "xs",
        "any_int",
        "zs",
        "x",
        "z",
        "y",
        "ys"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1], [1, 2], [1, 2, 3]) == 3\n    assert candidate([1], [1, 2.0], [1, 2, 3]) == 1\n    assert candidate([-1, 0, 1], [-10, 0, 10], [-100, 0, 100]) == 1\n\ndef test_check():\n    check(count_integer_sum_cases)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "encode",
      "arguments": [
        "message"
      ],
      "docstring": {
        "description": "Write a function that takes a message, and encodes in such a\nway that it swaps case of all letters, replaces all vowels in\nthe message with the letter that appears 2 places ahead of that\nvowel in the english alphabet.\nAssume only letters.",
        "examples": [
          ">>> encode('test')\n'TGST'",
          ">>> encode('This is a message')\n'tHKS KS C MGSSCGG'"
        ]
      },
      "template": "def {{ encode }}({{ message }}: str) -> str:\n    {{ vowels }} = 'aeiouAEIOU'\n    {{ vowels_replace }} = dict([({{ i }}, chr(ord({{ i }}) + 2)) for {{ i }} in {{ vowels }}])\n    {{ message }} = {{ message }}.swapcase()\n    return ''.join([{{ vowels_replace }}[{{ i }}] if {{ i }} in {{ vowels }} else {{ i }} for {{ i }} in {{ message }}])",
      "placeholders": [
        "vowels",
        "vowels_replace",
        "encode",
        "i",
        "message"
      ]
    },
    "target_function": {
      "name": "count_changed_alphabet_characters",
      "arguments": [
        "message"
      ],
      "docstring": {
        "description": "Return the count of characters in the given string\nthat change their alphabet after encoding.",
        "examples": [
          ">>> count_changed_alphabet_characters('test')\n1",
          ">>> count_changed_alphabet_characters('This is a message')\n6"
        ]
      },
      "template": "def {{ count_changed_alphabet_characters }}({{ message }}: str) -> int:\n    {{ encoded_message }} = {{ encode }}({{ message }})\n    return len([1 for ({{ a }}, {{ b }}) in zip({{ message }}.lower(), {{ encoded_message }}.lower()) if {{ a }} != {{ b }}])",
      "placeholders": [
        "encode",
        "a",
        "message",
        "b",
        "count_changed_alphabet_characters",
        "encoded_message"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('abebcciddBCDOUBCD') == 5\n    assert candidate('a bc def gae') == 4\n    assert candidate('Count Changed Alphabet Characters') == 10\n\ndef test_check():\n    check(count_changed_alphabet_characters)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "skjkasdkd",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "You are given a list of integers.\nYou need to find the largest prime value and return the sum of its digits.",
        "examples": [
          ">>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n10",
          ">>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n25",
          ">>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n13",
          ">>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n11",
          ">>> skjkasdkd([0, 81, 12, 3, 1, 21])\n3",
          ">>> skjkasdkd([0, 8, 1, 2, 1, 7])\n7"
        ]
      },
      "template": "def {{ skjkasdkd }}({{ lst }}: List[int]) -> int:\n\n    def {{ isPrime }}({{ n }}):\n        for {{ i }} in range(2, int({{ n }} ** 0.5) + 1):\n            if {{ n }} % {{ i }} == 0:\n                return False\n        return True\n    {{ maxx }} = 0\n    {{ i }} = 0\n    while {{ i }} < len({{ lst }}):\n        if {{ lst }}[{{ i }}] > {{ maxx }} and {{ isPrime }}({{ lst }}[{{ i }}]):\n            {{ maxx }} = {{ lst }}[{{ i }}]\n        {{ i }} += 1\n    {{ result }} = sum((int({{ digit }}) for {{ digit }} in str({{ maxx }})))\n    return {{ result }}",
      "placeholders": [
        "lst",
        "i",
        "digit",
        "result",
        "n",
        "maxx",
        "isPrime",
        "skjkasdkd"
      ]
    },
    "target_function": {
      "name": "sum_of_digits_of_largest_prime_substring",
      "arguments": [
        "integer"
      ],
      "docstring": {
        "description": "Given a string representing non-negative integers,\nreturn the sum of digits of the largest prime number among all the contiguous substrings of length 3.",
        "examples": [
          ">>> sum_of_digits_of_largest_prime_substring('1019')\n2",
          ">>> sum_of_digits_of_largest_prime_substring('10199')\n19"
        ]
      },
      "template": "def {{ sum_of_digits_of_largest_prime_substring }}({{ integer }}: str) -> int:\n    return {{ skjkasdkd }}([int({{ integer }}[{{ i }}:{{ i }} + 3]) for {{ i }} in range(len({{ integer }}) - 2)])",
      "placeholders": [
        "i",
        "sum_of_digits_of_largest_prime_substring",
        "integer",
        "skjkasdkd"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('1232131') == 5\n    assert candidate('99773') == 25\n    assert candidate('20230711') == 10\n\ndef test_check():\n    check(sum_of_digits_of_largest_prime_substring)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Dict",
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "check_dict_case",
      "arguments": [
        "dict"
      ],
      "docstring": {
        "description": "Given a dictionary, return True if all keys are strings in lower\ncase or all keys are strings in upper case, else return False.\nThe function should return False is the given dictionary is empty.",
        "examples": [
          ">>> check_dict_case({ 'a': 'apple', 'b': 'banana' })\nTrue",
          ">>> check_dict_case({ 'a': 'apple', 'A': 'banana', 'B': 'banana' })\nFalse",
          ">>> check_dict_case({ 'a': 'apple', 8: 'banana', 'a': 'apple' })\nFalse",
          ">>> check_dict_case({ 'Name': 'John', 'Age': '36', 'City': 'Houston' })\nFalse",
          ">>> check_dict_case({ 'STATE': 'NC', 'ZIP': '12345' })\nTrue"
        ]
      },
      "template": "def {{ check_dict_case }}({{ dict }}: Dict[str, str]) -> bool:\n    if len({{ dict }}.keys()) == 0:\n        return False\n    else:\n        {{ state }} = 'start'\n        for {{ key }} in {{ dict }}.keys():\n            if not isinstance({{ key }}, str):\n                {{ state }} = 'mixed'\n                break\n            if {{ state }} == 'start':\n                if {{ key }}.isupper():\n                    {{ state }} = 'upper'\n                elif {{ key }}.islower():\n                    {{ state }} = 'lower'\n                else:\n                    break\n            elif {{ state }} == 'upper' and (not {{ key }}.isupper()) or ({{ state }} == 'lower' and (not {{ key }}.islower())):\n                {{ state }} = 'mixed'\n                break\n            else:\n                break\n        return {{ state }} == 'upper' or {{ state }} == 'lower'",
      "placeholders": [
        "key",
        "dict",
        "state",
        "check_dict_case"
      ]
    },
    "target_function": {
      "name": "check_case_consistency",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Implement a function that returns true if all the strings in the given list\nare either all lowercase or all uppercase, and false otherwise.",
        "examples": [
          ">>> check_case_consistency(['Name', 'Age', 'City'])\nFalse",
          ">>> check_case_consistency(['STATE', 'ZIP'])\nTrue"
        ]
      },
      "template": "def {{ check_case_consistency }}({{ lst }}: List[str]) -> bool:\n    return {{ check_dict_case }}({string: None for string in {{ lst }}})",
      "placeholders": [
        "check_dict_case",
        "lst",
        "check_case_consistency"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['aa', 'bb', 'cc', 'abc', 'abcd']) is True\n    assert candidate(['AAA', 'ABCD', 'ABCDE']) is True\n    assert candidate(['Check', 'case', 'consistency']) is False\n\ndef test_check():\n    check(check_case_consistency)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "count_up_to",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Implement a function that takes an non-negative integer and returns an array of the first n\nintegers that are prime numbers and less than n.",
        "examples": [
          ">>> count_up_to(5)\n[2, 3]",
          ">>> count_up_to(11)\n[2, 3, 5, 7]",
          ">>> count_up_to(0)\n[]",
          ">>> count_up_to(20)\n[2, 3, 5, 7, 11, 13, 17, 19]",
          ">>> count_up_to(1)\n[]",
          ">>> count_up_to(18)\n[2, 3, 5, 7, 11, 13, 17]"
        ]
      },
      "template": "def {{ count_up_to }}({{ n }}: int) -> List[int]:\n    {{ primes }} = []\n    for {{ i }} in range(2, {{ n }}):\n        {{ is_prime }} = True\n        for {{ j }} in range(2, {{ i }}):\n            if {{ i }} % {{ j }} == 0:\n                {{ is_prime }} = False\n                break\n        if {{ is_prime }}:\n            {{ primes }}.append({{ i }})\n    return {{ primes }}",
      "placeholders": [
        "i",
        "is_prime",
        "n",
        "primes",
        "j",
        "count_up_to"
      ]
    },
    "target_function": {
      "name": "sum_of_primes_smaller_than",
      "arguments": [
        "number"
      ],
      "docstring": {
        "description": "Calculate the sum of all prime numbers smaller than the given number.",
        "examples": [
          ">>> sum_of_primes_smaller_than(5)\n5",
          ">>> sum_of_primes_smaller_than(11)\n17"
        ]
      },
      "template": "def {{ sum_of_primes_smaller_than }}({{ number }}: int) -> int:\n    return sum({{ count_up_to }}({{ number }}))",
      "placeholders": [
        "sum_of_primes_smaller_than",
        "number",
        "count_up_to"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(2) == 0\n    assert candidate(20) == 77\n    assert candidate(100) == 1060\n\ndef test_check():\n    check(sum_of_primes_smaller_than)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "multiply",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Complete the function that takes two integers and returns\nthe product of their unit digits.\nAssume the input is always valid.",
        "examples": [
          ">>> multiply(148, 412)\n16",
          ">>> multiply(19, 28)\n72",
          ">>> multiply(2020, 1851)\n0",
          ">>> multiply(14, -15)\n20"
        ]
      },
      "template": "def {{ multiply }}({{ a }}: int, {{ b }}: int) -> int:\n    return abs({{ a }} % 10) * abs({{ b }} % 10)",
      "placeholders": [
        "a",
        "multiply",
        "b"
      ]
    },
    "target_function": {
      "name": "calculate_sum_or_difference_based_on_product",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Implement an efficient function that returns the sum of the two numbers\nif their product is even, and the difference of the two numbers if their product is odd.",
        "examples": [
          ">>> calculate_sum_or_difference_based_on_product(3, 4)\n7",
          ">>> calculate_sum_or_difference_based_on_product(3, 5)\n-2"
        ]
      },
      "template": "def {{ calculate_sum_or_difference_based_on_product }}({{ a }}: int, {{ b }}: int) -> int:\n    return {{ a }} + {{ b }} if {{ multiply }}({{ a }}, {{ b }}) % 2 == 0 else {{ a }} - {{ b }}",
      "placeholders": [
        "calculate_sum_or_difference_based_on_product",
        "a",
        "multiply",
        "b"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(11, 33) == -22\n    assert candidate(22, 44) == 66\n    assert candidate(-111, 333) == -444\n\ndef test_check():\n    check(calculate_sum_or_difference_based_on_product)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "count_upper",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "Given a string s, count the number of uppercase vowels in even indices.",
        "examples": [
          ">>> count_upper('aBCdEf')\n1",
          ">>> count_upper('abcdefg')\n0",
          ">>> count_upper('dBBE')\n0"
        ]
      },
      "template": "def {{ count_upper }}({{ s }}: str) -> int:\n    {{ count }} = 0\n    for {{ i }} in range(0, len({{ s }}), 2):\n        if {{ s }}[{{ i }}] in 'AEIOU':\n            {{ count }} += 1\n    return {{ count }}",
      "placeholders": [
        "i",
        "count",
        "s",
        "count_upper"
      ]
    },
    "target_function": {
      "name": "find_string_with_highest_uppercase_vowel_count_at_even_indices",
      "arguments": [
        "strings"
      ],
      "docstring": {
        "description": "Return the string from the given list of strings\nthat has the highest count of uppercase vowels at even indices.\nIn the case of having the same count, return the string that is located at the frontmost position.",
        "examples": [
          ">>> find_string_with_highest_uppercase_vowel_count_at_even_indices(['aBCdEf', 'abcdefg', 'dBBE'])\n'aBCdEf'",
          ">>> find_string_with_highest_uppercase_vowel_count_at_even_indices(['b', 'Eb', 'Ab'])\n'Eb'"
        ]
      },
      "template": "def {{ find_string_with_highest_uppercase_vowel_count_at_even_indices }}({{ strings }}: List[str]) -> str:\n    return max({{ strings }}, key={{ count_upper }})",
      "placeholders": [
        "count_upper",
        "find_string_with_highest_uppercase_vowel_count_at_even_indices",
        "strings"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['ABBBBBBB', 'ABABABAB', 'AAAAAA', 'BBBBBBBBBB']) == 'ABABABAB'\n    assert candidate(['BABEBIBOBU', 'acecicocuc', 'bbccAdd']) == 'bbccAdd'\n    assert candidate(['ABEC', 'EBIC', 'IBOC', 'OBUC']) == 'ABEC'\n\ndef test_check():\n    check(find_string_with_highest_uppercase_vowel_count_at_even_indices)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "closest_integer",
      "arguments": [
        "value"
      ],
      "docstring": {
        "description": "Create a function that takes a value (string) representing a number\nand returns the closest integer to it. If the number is equidistant\nfrom two integers, round it away from zero.",
        "examples": [
          ">>> closest_integer('10')\n10",
          ">>> closest_integer('15.3')\n15"
        ]
      },
      "template": "def {{ closest_integer }}({{ value }}: str) -> int:\n    from math import ceil, floor\n    if {{ value }}.count('.') == 1:\n        while {{ value }}[-1] == '0':\n            {{ value }} = {{ value }}[:-1]\n    {{ num }} = float({{ value }})\n    if {{ value }}[-2:] == '.5':\n        if {{ num }} > 0:\n            {{ res }} = {{ ceil }}({{ num }})\n        else:\n            {{ res }} = {{ floor }}({{ num }})\n    elif len({{ value }}) > 0:\n        {{ res }} = int(round({{ num }}))\n    else:\n        {{ res }} = 0\n    return {{ res }}",
      "placeholders": [
        "closest_integer",
        "res",
        "num",
        "ceil",
        "floor",
        "value"
      ]
    },
    "target_function": {
      "name": "find_largest_rearranged_decimal_number",
      "arguments": [
        "number"
      ],
      "docstring": {
        "description": "Given a positive decimal number represented as a string,\nreturn the rounded value of the largest decimal number that can be obtained\nby rearranging the order of digits, excluding the decimal point (.).",
        "examples": [
          ">>> find_largest_rearranged_decimal_number('13.24')\n43"
        ]
      },
      "template": "def {{ find_largest_rearranged_decimal_number }}({{ number }}: str) -> int:\n    {{ index }} = {{ number }}.index('.')\n    {{ digits }} = {{ number }}[:{{ index }}] + {{ number }}[{{ index }} + 1:]\n    {{ digits }} = ''.join(sorted({{ digits }}, reverse=True))\n    {{ number }} = {{ digits }}[:{{ index }}] + '.' + {{ digits }}[{{ index }}:]\n    return {{ closest_integer }}({{ number }})",
      "placeholders": [
        "index",
        "closest_integer",
        "find_largest_rearranged_decimal_number",
        "number",
        "digits"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('1234.5678') == 8765\n    assert candidate('567.567') == 777\n    assert candidate('2023.0712') == 7322\n\ndef test_check():\n    check(find_largest_rearranged_decimal_number)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "make_a_pile",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Given a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n    - the next odd number if n is odd.\n    - the next even number if n is even.\nReturn the number of stones in each level in a list, where element at index\ni represents the number of stones in the level (i+1).",
        "examples": [
          ">>> make_a_pile(3)\n[3, 5, 7]"
        ]
      },
      "template": "def {{ make_a_pile }}({{ n }}: int) -> List[int]:\n    return [{{ n }} + 2 * {{ i }} for {{ i }} in range({{ n }})]",
      "placeholders": [
        "i",
        "make_a_pile",
        "n"
      ]
    },
    "target_function": {
      "name": "get_last_elements_of_piles",
      "arguments": [
        "numbers"
      ],
      "docstring": {
        "description": "Given a list of positive integers,\nreturn a list of the last elements of the piles corresponding to each integer.",
        "examples": [
          ">>> get_last_elements_of_piles([2, 3])\n[4, 7]"
        ]
      },
      "template": "def {{ get_last_elements_of_piles }}({{ numbers }}: List[int]) -> List[int]:\n    return [{{ make_a_pile }}({{ number }})[-1] for {{ number }} in {{ numbers }}]",
      "placeholders": [
        "make_a_pile",
        "numbers",
        "get_last_elements_of_piles",
        "number"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == [1, 4, 7, 10, 13]\n    assert candidate([5, 3, 1, 5, 3, 1]) == [13, 7, 1, 13, 7, 1]\n    assert candidate([7, 10]) == [19, 28]\n\ndef test_check():\n    check(get_last_elements_of_piles)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "words_string",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "You will be given a string of words separated by commas or spaces. Your task is\nto split the string into words and return an array of the words.",
        "examples": [
          ">>> words_string('Hi, my name is John')\n['Hi', 'my', 'name', 'is', 'John']",
          ">>> words_string('One, two, three, four, five, six')\n['One', 'two', 'three', 'four', 'five', 'six']"
        ]
      },
      "template": "def {{ words_string }}({{ s }}: str) -> List[str]:\n    if not {{ s }}:\n        return []\n    {{ s_list }} = []\n    for {{ letter }} in {{ s }}:\n        if {{ letter }} == ',':\n            {{ s_list }}.append(' ')\n        else:\n            {{ s_list }}.append({{ letter }})\n    {{ s_list }} = ''.join({{ s_list }})\n    return {{ s_list }}.split()",
      "placeholders": [
        "letter",
        "s",
        "s_list",
        "words_string"
      ]
    },
    "target_function": {
      "name": "words_string_lower",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "You will be given a string of words separated by commas or spaces. Your task is\nto split the lowercased version of the string into words and return an array of the words.",
        "examples": [
          ">>> words_string_lower('Hi, my name is John')\n['hi', 'my', 'name', 'is', 'john']",
          ">>> words_string_lower('One, two, three, four, five, six')\n['one', 'two', 'three', 'four', 'five', 'six']"
        ]
      },
      "template": "def {{ words_string_lower }}({{ s }}: str) -> List[str]:\n    return {{ words_string }}({{ s }}.lower())",
      "placeholders": [
        "s",
        "words_string_lower",
        "words_string"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('') == []\n    assert candidate(' ') == []\n    assert candidate('Hi, my name is John') == ['hi', 'my', 'name', 'is', 'john']\n    assert candidate('One, two, three, Four, five') == ['one', 'two', 'three', 'four', 'five']\n    assert candidate(' , APPLE BANANA,, CANDY') == ['apple', 'banana', 'candy']\n\ndef test_check():\n    check(words_string_lower)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "choose_num",
      "arguments": [
        "x",
        "y"
      ],
      "docstring": {
        "description": "This function takes two positive numbers x and y and returns the\nbiggest even integer number that is in the range [x, y] inclusive. If\nthere's no such number, then the function should return -1.",
        "examples": [
          ">>> choose_num(12, 15)\n14",
          ">>> choose_num(13, 12)\n-1"
        ]
      },
      "template": "def {{ choose_num }}({{ x }}: int, {{ y }}: int) -> int:\n    if {{ x }} > {{ y }}:\n        return -1\n    if {{ y }} % 2 == 0:\n        return {{ y }}\n    if {{ x }} == {{ y }}:\n        return -1\n    return {{ y }} - 1",
      "placeholders": [
        "choose_num",
        "x",
        "y"
      ]
    },
    "target_function": {
      "name": "choose_num_two_intervals",
      "arguments": [
        "x",
        "y",
        "z",
        "w"
      ],
      "docstring": {
        "description": "This function takes two positive numbers x, y, z, and w and returns the\nbiggest even integer number that is in the ranges [x, y] and [z, w] inclusive.\nIf there's no such number, then the function should return -1.",
        "examples": [
          ">>> choose_num_two_intervals(12, 15, 18, 20)\n20",
          ">>> choose_num_two_intervals(13, 12, 0, 10)\n-1"
        ]
      },
      "template": "def {{ choose_num_two_intervals }}({{ x }}: int, {{ y }}: int, {{ z }}: int, {{ w }}: int) -> int:\n    {{ a }} = {{ choose_num }}({{ x }}, {{ y }})\n    {{ b }} = {{ choose_num }}({{ z }}, {{ w }})\n    if {{ a }} == -1 or {{ b }} == -1:\n        return -1\n    else:\n        return max({{ a }}, {{ b }})",
      "placeholders": [
        "choose_num",
        "choose_num_two_intervals",
        "a",
        "x",
        "z",
        "y",
        "b",
        "w"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(12, 15, 18, 20) == 20\n    assert candidate(13, 12, 1, 10) == -1\n    assert candidate(1, 5, 2, 3) == 4\n    assert candidate(10, 20, 13, 10) == -1\n    assert candidate(8, 6, 4, 2) == -1\n    assert candidate(2, 5, 5, 9) == 8\n\ndef test_check():\n    check(choose_num_two_intervals)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Union"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "rounded_avg",
      "arguments": [
        "n",
        "m"
      ],
      "docstring": {
        "description": "You are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m).\nRound the answer to the nearest integer and convert that to binary.\nIf n is greater than m, return -1.",
        "examples": [
          ">>> rounded_avg(1, 5)\n'0b11'",
          ">>> rounded_avg(7, 5)\n-1",
          ">>> rounded_avg(10, 20)\n'0b1111'",
          ">>> rounded_avg(20, 33)\n'0b11010'"
        ]
      },
      "template": "def {{ rounded_avg }}({{ n }}: int, {{ m }}: int) -> Union[str, int]:\n    if {{ m }} < {{ n }}:\n        return -1\n    {{ summation }} = 0\n    for {{ i }} in range({{ n }}, {{ m }} + 1):\n        {{ summation }} += {{ i }}\n    return bin(round({{ summation }} / ({{ m }} - {{ n }} + 1)))",
      "placeholders": [
        "i",
        "summation",
        "rounded_avg",
        "n",
        "m"
      ]
    },
    "target_function": {
      "name": "biggest_multiplier_of_two",
      "arguments": [
        "n",
        "m"
      ],
      "docstring": {
        "description": "You are given two positive integers n and m, and your task is to compute the\nthe biggest multiplier of 2 among the numbers that are smaller than\nthe average of [n, m] rounded to the nearest integer.\nIf n is greater than m, return -1.",
        "examples": [
          ">>> biggest_multiplier_of_two(1, 5)\n2",
          ">>> biggest_multiplier_of_two(7, 5)\n-1",
          ">>> biggest_multiplier_of_two(10, 20)\n8",
          ">>> biggest_multiplier_of_two(20, 33)\n16"
        ]
      },
      "template": "def {{ biggest_multiplier_of_two }}({{ n }}: int, {{ m }}: int) -> int:\n    if {{ m }} < {{ n }}:\n        return -1\n    return 2 ** (len({{ rounded_avg }}({{ n }}, {{ m }})) - 3)",
      "placeholders": [
        "rounded_avg",
        "biggest_multiplier_of_two",
        "m",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(1, 5) == 2\n    assert candidate(7, 5) == -1\n    assert candidate(10, 20) == 8\n    assert candidate(20, 33) == 16\n    assert candidate(1, 10) == 4\n    assert candidate(16, 64) == 32\n\ndef test_check():\n    check(biggest_multiplier_of_two)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "unique_digits",
      "arguments": [
        "x"
      ],
      "docstring": {
        "description": "Given a list of positive integers x. return a sorted list of all\nelements that hasn't any even digit.\n\nNote: Returned list should be sorted in increasing order.",
        "examples": [
          ">>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]",
          ">>> unique_digits([152, 323, 1422, 10])\n[]"
        ]
      },
      "template": "def {{ unique_digits }}({{ x }}: List[int]) -> List[int]:\n    {{ odd_digit_elements }} = []\n    for {{ i }} in {{ x }}:\n        if all((int({{ c }}) % 2 == 1 for {{ c }} in str({{ i }}))):\n            {{ odd_digit_elements }}.append({{ i }})\n    return sorted({{ odd_digit_elements }})",
      "placeholders": [
        "c",
        "i",
        "odd_digit_elements",
        "x",
        "unique_digits"
      ]
    },
    "target_function": {
      "name": "unique_sum_of_digits",
      "arguments": [
        "x"
      ],
      "docstring": {
        "description": "Given a list of positive integers x. Compute a sorted list of all\nelements that hasn't any even digit, and convert each element into the\nsum of digits of the number.",
        "examples": [
          ">>> unique_sum_of_digits([15, 33, 1422, 1])\n[1, 6, 6]",
          ">>> unique_sum_of_digits([152, 323, 1422, 10])\n[]"
        ]
      },
      "template": "def {{ unique_sum_of_digits }}({{ x }}: List[int]) -> List[int]:\n    return [sum((int({{ digit }}) for {{ digit }} in str({{ elem }}))) for {{ elem }} in {{ unique_digits }}({{ x }})]",
      "placeholders": [
        "x",
        "digit",
        "elem",
        "unique_sum_of_digits",
        "unique_digits"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([15, 33, 1422, 1]) == [1, 6, 6]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n    assert candidate([12, 34, 56, 78, 90]) == []\n    assert candidate([11, 22, 33, 44, 55, 66]) == [2, 6, 10]\n    assert candidate([97, 86, 75, 64, 53, 42, 31, 20]) == [4, 8, 12, 16]\n\ndef test_check():\n    check(unique_sum_of_digits)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "by_length",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Given an array of integers, sort the integers that are between 1 and 9 inclusive,\nreverse the resulting array, and then replace each digit by its corresponding name from\n\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".",
        "examples": [
          ">>> by_length([2, 1, 1, 4, 5, 8, 2, 3])\n['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']",
          ">>> by_length([])\n[]",
          ">>> by_length([1, -1, 55])\n['One']"
        ]
      },
      "template": "def {{ by_length }}({{ arr }}: List[int]) -> List[str]:\n    {{ dic }} = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    {{ sorted_arr }} = sorted({{ arr }}, reverse=True)\n    {{ new_arr }} = []\n    for {{ var }} in {{ sorted_arr }}:\n        try:\n            {{ new_arr }}.append({{ dic }}[{{ var }}])\n        except:\n            pass\n    return {{ new_arr }}",
      "placeholders": [
        "by_length",
        "sorted_arr",
        "var",
        "dic",
        "arr",
        "new_arr"
      ]
    },
    "target_function": {
      "name": "by_length_csv",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Given an array of integers, sort the integers that are between 1 and 9 inclusive,\nreverse the resulting array, and then replace each digit by its corresponding name from\n\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\nConvert the list of digit names into a comma-separated string.",
        "examples": [
          ">>> by_length_csv([2, 1, 1, 4, 5, 8, 2, 3])\n'Eight,Five,Four,Three,Two,Two,One,One'",
          ">>> by_length_csv([])\n''",
          ">>> by_length_csv([1, -1, 55])\n'One'"
        ]
      },
      "template": "def {{ by_length_csv }}({{ arr }}: List[int]) -> str:\n    return ','.join({{ by_length }}({{ arr }}))",
      "placeholders": [
        "by_length",
        "by_length_csv",
        "arr"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == 'Eight,Five,Four,Three,Two,Two,One,One'\n    assert candidate([]) == ''\n    assert candidate([1, -1, 55]) == 'One'\n    assert candidate([1, 3, 5, 7]) == 'Seven,Five,Three,One'\n    assert candidate([0, 0, 0, 0]) == ''\n    assert candidate([99, 0, 1, 4, 4, 1]) == 'Four,Four,One,One'\n\ndef test_check():\n    check(by_length_csv)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "f",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Implement the function f that takes n as a parameter,\nand returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\nor the sum of numbers from 1 to i otherwise.\ni starts from 1.\nthe factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).",
        "examples": [
          ">>> f(5)\n[1, 2, 6, 24, 15]"
        ]
      },
      "template": "def {{ f }}({{ n }}: int) -> List[int]:\n    {{ ret }} = []\n    for {{ i }} in range(1, {{ n }} + 1):\n        if {{ i }} % 2 == 0:\n            {{ x }} = 1\n            for {{ j }} in range(1, {{ i }} + 1):\n                {{ x }} *= {{ j }}\n            {{ ret }} += [{{ x }}]\n        else:\n            {{ x }} = 0\n            for {{ j }} in range(1, {{ i }} + 1):\n                {{ x }} += {{ j }}\n            {{ ret }} += [{{ x }}]\n    return {{ ret }}",
      "placeholders": [
        "i",
        "f",
        "j",
        "x",
        "n",
        "ret"
      ]
    },
    "target_function": {
      "name": "sorted_f",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Implement the function f that takes n as a parameter,\nand compute a list of size n, such that the value of the element at index i is the factorial of i if i is even\nor the sum of numbers from 1 to i otherwise.\ni starts from 1.\nSort the integer values in a descending order.\nthe factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).",
        "examples": [
          ">>> sorted_f(5)\n[24, 15, 6, 2, 1]"
        ]
      },
      "template": "def {{ sorted_f }}({{ n }}: int) -> List[int]:\n    return sorted({{ f }}({{ n }}), reverse=True)",
      "placeholders": [
        "f",
        "sorted_f",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(1) == [1]\n    assert candidate(5) == [24, 15, 6, 2, 1]\n    assert candidate(10) == [3628800, 40320, 720, 45, 28, 24, 15, 6, 2, 1]\n\ndef test_check():\n    check(sorted_f)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "even_odd_palindrome",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Given a positive integer n, return a tuple that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.",
        "examples": [
          ">>> even_odd_palindrome(3)\n(1, 2)",
          ">>> even_odd_palindrome(12)\n(4, 6)"
        ]
      },
      "template": "def {{ even_odd_palindrome }}({{ n }}: int) -> Tuple[int, int]:\n\n    def {{ is_palindrome }}({{ n }}):\n        return str({{ n }}) == str({{ n }})[::-1]\n    {{ even_palindrome_count }} = 0\n    {{ odd_palindrome_count }} = 0\n    for {{ i }} in range(1, {{ n }} + 1):\n        if {{ i }} % 2 == 1 and {{ is_palindrome }}({{ i }}):\n            {{ odd_palindrome_count }} += 1\n        elif {{ i }} % 2 == 0 and {{ is_palindrome }}({{ i }}):\n            {{ even_palindrome_count }} += 1\n    return ({{ even_palindrome_count }}, {{ odd_palindrome_count }})",
      "placeholders": [
        "i",
        "is_palindrome",
        "even_odd_palindrome",
        "n",
        "even_palindrome_count",
        "odd_palindrome_count"
      ]
    },
    "target_function": {
      "name": "even_odd_palindrome_interval",
      "arguments": [
        "m",
        "n"
      ],
      "docstring": {
        "description": "Given two positive integers m and n, return a tuple that has the number of even and odd\ninteger palindromes that fall within the range(m+1, n), inclusive.\nIf m is greater than n, return (0, 0).",
        "examples": [
          ">>> even_odd_palindrome_interval(3, 12)\n(3, 4)"
        ]
      },
      "template": "def {{ even_odd_palindrome_interval }}({{ m }}: int, {{ n }}: int) -> Tuple[int, int]:\n    if {{ m }} > {{ n }}:\n        return (0, 0)\n    return tuple(({{ en }} - {{ em }} for ({{ em }}, {{ en }}) in zip({{ even_odd_palindrome }}({{ m }}), {{ even_odd_palindrome }}({{ n }}))))",
      "placeholders": [
        "em",
        "en",
        "even_odd_palindrome",
        "n",
        "even_odd_palindrome_interval",
        "m"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(3, 12) == (3, 4)\n    assert candidate(5, 3) == (0, 0)\n    assert candidate(4, 4) == (0, 0)\n    assert candidate(4, 5) == (0, 1)\n    assert candidate(10, 20) == (0, 1)\n    assert candidate(11, 21) == (0, 0)\n\ndef test_check():\n    check(even_odd_palindrome_interval)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "count_nums",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Write a function count_nums which takes an array of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.",
        "examples": [
          ">>> count_nums([])\n0",
          ">>> count_nums([-1, 11, -11])\n1",
          ">>> count_nums([1, 1, 2])\n3"
        ]
      },
      "template": "def {{ count_nums }}({{ arr }}: List[int]) -> int:\n\n    def {{ digits_sum }}({{ n }}):\n        {{ neg }} = 1\n        if {{ n }} < 0:\n            ({{ n }}, {{ neg }}) = (-1 * {{ n }}, -1)\n        {{ n }} = [int({{ i }}) for {{ i }} in str({{ n }})]\n        {{ n }}[0] = {{ n }}[0] * {{ neg }}\n        return sum({{ n }})\n    return len(list(filter(lambda x: {{ x }} > 0, [{{ digits_sum }}({{ i }}) for {{ i }} in {{ arr }}])))",
      "placeholders": [
        "count_nums",
        "digits_sum",
        "i",
        "x",
        "neg",
        "n",
        "arr"
      ]
    },
    "target_function": {
      "name": "count_nums_union",
      "arguments": [
        "arr1",
        "arr2"
      ],
      "docstring": {
        "description": "Write a function count_nums_union which takes two arrays of integers and returns\nthe number of elements which has a sum of digits > 0 from union of the arrays (without repetition of elements).\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.",
        "examples": [
          ">>> count_nums_union([], [])\n0",
          ">>> count_nums_union([-1, 11, -11], [1, 1, 2])\n3"
        ]
      },
      "template": "def {{ count_nums_union }}({{ arr1 }}: List[int], {{ arr2 }}: List[int]) -> int:\n    return {{ count_nums }}(list(set({{ arr1 }}) | set({{ arr2 }})))",
      "placeholders": [
        "count_nums",
        "arr2",
        "count_nums_union",
        "arr1"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([], []) == 0\n    assert candidate([-1, 11, -11], [1, 1, 2]) == 3\n    assert candidate([-525, 124, 345], []) == 3\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == 4\n    assert candidate([-4, -3, -2, -1], [-2, -1, 0, 1]) == 1\n    assert candidate([1, 1, 1, 1], [2, 2, 2, 2]) == 2\n\ndef test_check():\n    check(count_nums_union)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "move_one_ball",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the array will be randomly ordered. Your task is to determine if\nit is possible to get an array sorted in non-decreasing order by performing\nthe following operation on the given array:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the array by one\nposition in the right direction. The last element of the array will be moved to\nthe starting position in the array i.e. 0th index.\n\nIf it is possible to obtain the sorted array by performing the above operation\nthen return True else return False.\nIf the given array is empty then return True.\n\nNote: The given list is guaranteed to have unique elements.",
        "examples": [
          ">>> move_one_ball([3, 4, 5, 1, 2])\nTrue",
          ">>> move_one_ball([3, 5, 4, 1, 2])\nFalse"
        ]
      },
      "template": "def {{ move_one_ball }}({{ arr }}: List[int]) -> bool:\n    if len({{ arr }}) == 0:\n        return True\n    {{ sorted_array }} = sorted({{ arr }})\n    {{ my_arr }} = []\n    {{ min_value }} = min({{ arr }})\n    {{ min_index }} = {{ arr }}.index({{ min_value }})\n    {{ my_arr }} = {{ arr }}[{{ min_index }}:] + {{ arr }}[0:{{ min_index }}]\n    for {{ i }} in range(len({{ arr }})):\n        if {{ my_arr }}[{{ i }}] != {{ sorted_array }}[{{ i }}]:\n            return False\n    return True",
      "placeholders": [
        "sorted_array",
        "i",
        "move_one_ball",
        "min_value",
        "my_arr",
        "arr",
        "min_index"
      ]
    },
    "target_function": {
      "name": "move_one_ball_any_order",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the array will be randomly ordered. Your task is to determine if\nit is possible to get an array sorted in non-decreasing or non-increasing order\nby performing the following operation on the given array:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the array by one\nposition in the right direction. The last element of the array will be moved to\nthe starting position in the array i.e. 0th index.\n\nIf it is possible to obtain the sorted array by performing the above operation\nthen return True else return False.\nIf the given array is empty then return True.\n\nNote: The given list is guaranteed to have unique elements.",
        "examples": [
          ">>> move_one_ball_any_order([3, 4, 5, 1, 2])\nTrue",
          ">>> move_one_ball_any_order([2, 1, 5, 4, 3])\nTrue",
          ">>> move_one_ball_any_order([3, 5, 4, 1, 2])\nFalse"
        ]
      },
      "template": "def {{ move_one_ball_any_order }}({{ arr }}: List[int]) -> bool:\n    return {{ move_one_ball }}({{ arr }}) or {{ move_one_ball }}([-{{ e }} for {{ e }} in {{ arr }}])",
      "placeholders": [
        "move_one_ball_any_order",
        "move_one_ball",
        "arr",
        "e"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([3, 4, 5, 1, 2]) is True\n    assert candidate([2, 1, 5, 4, 3]) is True\n    assert candidate([3, 5, 4, 1, 2]) is False\n    assert candidate([3, 5, 4, 2, 1]) is False\n    assert candidate([5, 6, 7, 1, 2, 3, 4]) is True\n    assert candidate([3, 2, 1, 7, 6, 5, 4]) is True\n\ndef test_check():\n    check(move_one_ball_any_order)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "exchange",
      "arguments": [
        "lst1",
        "lst2"
      ],
      "docstring": {
        "description": "In this problem, you will implement a function that takes two lists of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a list of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".",
        "examples": [
          ">>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n'YES'",
          ">>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n'NO'"
        ]
      },
      "template": "def {{ exchange }}({{ lst1 }}: List[int], {{ lst2 }}: List[int]) -> str:\n    {{ odd }} = 0\n    {{ even }} = 0\n    for {{ i }} in {{ lst1 }}:\n        if {{ i }} % 2 == 1:\n            {{ odd }} += 1\n    for {{ i }} in {{ lst2 }}:\n        if {{ i }} % 2 == 0:\n            {{ even }} += 1\n    if {{ even }} >= {{ odd }}:\n        return 'YES'\n    return 'NO'",
      "placeholders": [
        "i",
        "exchange",
        "lst2",
        "odd",
        "even",
        "lst1"
      ]
    },
    "target_function": {
      "name": "exchange_from_repetition",
      "arguments": [
        "lst1",
        "lst2",
        "n"
      ],
      "docstring": {
        "description": "In this problem, you will implement a function that takes two lists of numbers (lst1 and lst2) and a number (n),\nand determines whether it is possible to perform an exchange of elements\nbetween \"lst1\" and \"k-times repeated lst2\" (k <= n) to make lst1 a list of only even numbers.\nThere is no limit on the number of exchanged elements between \"lst1\" and \"k-times repeated lst2\".\nReturn the array of length n whose k-th element is \"YES\" if it is possible to exchange elements between the \"lst1\"\nand \"k-times repeated lst2\" to make all the elements of lst1 to be even.\nOtherwise, k-th element is \"NO\".",
        "examples": [
          ">>> exchange_from_repetition([1, 2, 3, 4], [1, 5, 3, 4], 1)\n['NO']",
          ">>> exchange_from_repetition([1, 2, 3, 4], [1, 5, 3, 4], 3)\n['NO', 'YES', 'YES']"
        ]
      },
      "template": "def {{ exchange_from_repetition }}({{ lst1 }}: List[int], {{ lst2 }}: List[int], {{ n }}: int) -> List[str]:\n    return [{{ exchange }}({{ lst1 }}, {{ lst2 }} * {{ k }}) for {{ k }} in range(1, {{ n }} + 1)]",
      "placeholders": [
        "exchange",
        "lst2",
        "k",
        "exchange_from_repetition",
        "n",
        "lst1"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4], 1) == ['YES']\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4], 2) == ['YES', 'YES']\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4], 3) == ['YES', 'YES', 'YES']\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4], 1) == ['NO']\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4], 2) == ['NO', 'YES']\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4], 3) == ['NO', 'YES', 'YES']\n\ndef test_check():\n    check(exchange_from_repetition)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Dict",
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "histogram",
      "arguments": [
        "test"
      ],
      "docstring": {
        "description": "Given a string representing a space separated lowercase letters, return a dictionary\nof the letter with the most repetition and containing the corresponding count.\nIf several letters have the same occurrence, return all of them.",
        "examples": [
          ">>> histogram('a b c')\n{ 'a': 1, 'b': 1, 'c': 1 }",
          ">>> histogram('a b b a')\n{ 'a': 2, 'b': 2 }",
          ">>> histogram('a b c a b')\n{ 'a': 2, 'b': 2 }",
          ">>> histogram('b b b b a')\n{ 'b': 4 }",
          ">>> histogram('')\n{  }"
        ]
      },
      "template": "def {{ histogram }}({{ test }}: str) -> Dict[str, int]:\n    {{ dict1 }} = {}\n    {{ list1 }} = {{ test }}.split(' ')\n    {{ t }} = 0\n    for {{ i }} in {{ list1 }}:\n        if {{ list1 }}.count({{ i }}) > {{ t }} and {{ i }} != '':\n            {{ t }} = {{ list1 }}.count({{ i }})\n    if {{ t }} > 0:\n        for {{ i }} in {{ list1 }}:\n            if {{ list1 }}.count({{ i }}) == {{ t }}:\n                {{ dict1 }}[{{ i }}] = {{ t }}\n    return {{ dict1 }}",
      "placeholders": [
        "dict1",
        "i",
        "test",
        "histogram",
        "t",
        "list1"
      ]
    },
    "target_function": {
      "name": "most_frequent_letter",
      "arguments": [
        "test"
      ],
      "docstring": {
        "description": "Given a string representing a space separated lowercase letters, return a tuple\nof the letter with the most repetition and containing the corresponding count.\nIf several letters have the same occurrence, return the largest one in an alphabetical order.",
        "examples": [
          ">>> most_frequent_letter('a b c')\n('c', 1)",
          ">>> most_frequent_letter('a b b a')\n('b', 2)",
          ">>> most_frequent_letter('a b c a b')\n('b', 2)"
        ]
      },
      "template": "def {{ most_frequent_letter }}({{ test }}: str) -> Tuple[str, int]:\n    return max([{{ e }} for {{ e }} in {{ histogram }}({{ test }}).items()], key=lambda x: {{ x }}[0])",
      "placeholders": [
        "test",
        "x",
        "histogram",
        "most_frequent_letter",
        "e"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('a b c') == ('c', 1)\n    assert candidate('a b b a') == ('b', 2)\n    assert candidate('a b c a b') == ('b', 2)\n    assert candidate('a b a a b') == ('a', 3)\n    assert candidate('b b b b a') == ('b', 4)\n    assert candidate('a b c d e e e f f f') == ('f', 3)\n\ndef test_check():\n    check(most_frequent_letter)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "reverse_delete",
      "arguments": [
        "s",
        "c"
      ],
      "docstring": {
        "description": "Task\nWe are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\nthen check if the result string is palindrome.\nA string is called palindrome if it reads the same backward as forward.\nYou should return a tuple containing the result string and True/False for the check.",
        "examples": [
          ">>> reverse_delete('abcde', 'ae')\n('bcd', False)",
          ">>> reverse_delete('abcdef', 'b')\n('acdef', False)",
          ">>> reverse_delete('abcdedcba', 'ab')\n('cdedc', True)"
        ]
      },
      "template": "def {{ reverse_delete }}({{ s }}: str, {{ c }}: str) -> Tuple[str, bool]:\n    {{ s }} = ''.join([{{ char }} for {{ char }} in {{ s }} if {{ char }} not in {{ c }}])\n    return ({{ s }}, {{ s }}[::-1] == {{ s }})",
      "placeholders": [
        "char",
        "s",
        "reverse_delete",
        "c"
      ]
    },
    "target_function": {
      "name": "reverse_delete_list",
      "arguments": [
        "s",
        "c"
      ],
      "docstring": {
        "description": "Task\nWe are given two strings s and c, you have to deleted all the characters in s that are equal to each of the characters in c\nthen check if each result string is palindrome.\nA string is called palindrome if it reads the same backward as forward.\nYou should return a list of the tuples containing result string and True/False for the check.",
        "examples": [
          ">>> reverse_delete_list('abcde', 'ae')\n[('bcde', False), ('abcd', 'False')]",
          ">>> reverse_delete_list('abcdef', 'b')\n[('acdef', False)]",
          ">>> reverse_delete_list('abcdedcba', 'ab')\n[('bcdedcb', True), ('acdedca', True)]"
        ]
      },
      "template": "def {{ reverse_delete_list }}({{ s }}: str, {{ c }}: str) -> List[Tuple[str, bool]]:\n    return [{{ reverse_delete }}({{ s }}, {{ e }}) for {{ e }} in {{ c }}]",
      "placeholders": [
        "c",
        "s",
        "reverse_delete",
        "reverse_delete_list",
        "e"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('abcde', 'ae') == [('bcde', False), ('abcd', False)]\n    assert candidate('abcdef', 'b') == [('acdef', False)]\n    assert candidate('aabaa', 'b') == [('aaaa', True)]\n    assert candidate('abcdedcba', 'ab') == [('bcdedcb', True), ('acdedca', True)]\n    assert candidate('abcdedcba', 'abc') == [('bcdedcb', True), ('acdedca', True), ('abdedba', True)]\n    assert candidate('eabcdefdcba', 'ef') == [('abcdfdcba', True), ('eabcdedcba', False)]\n\ndef test_check():\n    check(reverse_delete_list)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "odd_count",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a list of strings, where each string consists of only digits, return a list.\nEach element i of the output should be \"the number of odd elements in the\nstring i of the input.\" where all the i's should be replaced by the number\nof odd digits in the i'th string of the input.",
        "examples": [
          ">>> odd_count(['1234567'])\n['the number of odd elements 4n the str4ng 4 of the 4nput.']",
          ">>> odd_count(['3', '11111111'])\n['the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.']"
        ]
      },
      "template": "def {{ odd_count }}({{ lst }}: List[str]) -> List[str]:\n    {{ res }} = []\n    for {{ arr }} in {{ lst }}:\n        {{ n }} = sum((int({{ d }}) % 2 == 1 for {{ d }} in {{ arr }}))\n        {{ res }}.append('the number of odd elements ' + str({{ n }}) + 'n the str' + str({{ n }}) + 'ng ' + str({{ n }}) + ' of the ' + str({{ n }}) + 'nput.')\n    return {{ res }}",
      "placeholders": [
        "lst",
        "d",
        "res",
        "odd_count",
        "n",
        "arr"
      ]
    },
    "target_function": {
      "name": "split_odd_count",
      "arguments": [
        "lst",
        "strsize"
      ],
      "docstring": {
        "description": "Given a list of strings, where each string consists of only digits,\nfirst split each string into shorter ones with the length strsize and return a list.\nEach element i of the output should be \"the number of odd elements in the\nstring i of the input.\" where all the i's should be replaced by the number\nof odd digits in the i'th string of the input.",
        "examples": [
          ">>> split_odd_count(['1234567'], 7)\n['the number of odd elements 4n the str4ng 4 of the 4nput.']",
          ">>> split_odd_count(['3', '11111111'], 4)\n['the number of odd elements 1n the str1ng 1 of the 1nput.',"
        ]
      },
      "template": "def {{ split_odd_count }}({{ lst }}: List[str], {{ strsize }}: int) -> List[str]:\n    {{ split_lst }} = [{{ s }}[{{ i }}:{{ i }} + {{ strsize }}] for {{ s }} in {{ lst }} for {{ i }} in range(0, len({{ s }}), {{ strsize }})]\n    return {{ odd_count }}({{ split_lst }})",
      "placeholders": [
        "lst",
        "i",
        "odd_count",
        "s",
        "strsize",
        "split_odd_count",
        "split_lst"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['1234567'], 7) == ['the number of odd elements 4n the str4ng 4 of the 4nput.']\n    assert candidate(['3', '11111111'], 4) == ['the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 4n the str4ng 4 of the 4nput.', 'the number of odd elements 4n the str4ng 4 of the 4nput.']\n    assert candidate(['1', '2'], 2) == ['the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 0n the str0ng 0 of the 0nput.']\n    assert candidate(['987234826349'], 6) == ['the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.']\n    assert candidate(['987234826349'], 8) == ['the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.']\n    assert candidate(['987234826349'], 10) == ['the number of odd elements 4n the str4ng 4 of the 4nput.', 'the number of odd elements 1n the str1ng 1 of the 1nput.']\n\ndef test_check():\n    check(split_odd_count)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "minSubArraySum",
      "arguments": [
        "nums"
      ],
      "docstring": {
        "description": "Given an array of integers nums, find the minimum sum of any non-empty sub-array\nof nums.",
        "examples": [
          ">>> minSubArraySum([2, 3, 4, 1, 2, 4])\n1",
          ">>> minSubArraySum([-1, -2, -3])\n-6"
        ]
      },
      "template": "def {{ minSubArraySum }}({{ nums }}: List[int]) -> int:\n    {{ max_sum }} = 0\n    {{ s }} = 0\n    for {{ num }} in {{ nums }}:\n        {{ s }} += -{{ num }}\n        if {{ s }} < 0:\n            {{ s }} = 0\n        {{ max_sum }} = max({{ s }}, {{ max_sum }})\n    if {{ max_sum }} == 0:\n        {{ max_sum }} = max((-{{ i }} for {{ i }} in {{ nums }}))\n    {{ min_sum }} = -{{ max_sum }}\n    return {{ min_sum }}",
      "placeholders": [
        "i",
        "s",
        "num",
        "nums",
        "min_sum",
        "max_sum",
        "minSubArraySum"
      ]
    },
    "target_function": {
      "name": "minSubArraySumNonNegative",
      "arguments": [
        "nums"
      ],
      "docstring": {
        "description": "Given an array of integers nums, find the minimum sum of any non-empty sub-array\nof nums. Consider all negative integers as 0.",
        "examples": [
          ">>> minSubArraySumNonNegative([2, 3, 4, 1, 2, 4])\n1",
          ">>> minSubArraySumNonNegative([-1, -2, -3])\n0"
        ]
      },
      "template": "def {{ minSubArraySumNonNegative }}({{ nums }}: List[int]) -> int:\n    return {{ minSubArraySum }}([max({{ e }}, 0) for {{ e }} in {{ nums }}])",
      "placeholders": [
        "nums",
        "e",
        "minSubArraySumNonNegative",
        "minSubArraySum"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1\n    assert candidate([-1, -2, -3]) == 0\n    assert candidate([1, 2, 3, 4, 1, 2, 3, 4]) == 1\n    assert candidate([1, 2, -1, -3, -4, -5, 6, 1]) == 0\n    assert candidate([0, 0, 0]) == 0\n    assert candidate([1, 0, -1]) == 0\n\ndef test_check():\n    check(minSubArraySumNonNegative)\n\ntest_check()"
  },
  {
    "imports": [
      [
        null,
        [
          "math"
        ]
      ],
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "max_fill",
      "arguments": [
        "grid",
        "capacity"
      ],
      "docstring": {
        "description": "You are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it,\nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.",
        "examples": [
          ">>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n6",
          ">>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n5",
          ">>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n0"
        ]
      },
      "template": "def {{ max_fill }}({{ grid }}: List[List[int]], {{ capacity }}: int) -> int:\n    return sum([math.ceil(sum({{ arr }}) / {{ capacity }}) for {{ arr }} in {{ grid }}])",
      "placeholders": [
        "max_fill",
        "capacity",
        "grid",
        "arr"
      ]
    },
    "target_function": {
      "name": "max_fill_buckets",
      "arguments": [
        "grid",
        "capacities"
      ],
      "docstring": {
        "description": "You are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has corresponding buckets that can be used to extract water from it,\nand all buckets have the same capacity.\nYour task is to use the buckets with different capacities to empty the wells.\nOutput the list of the number of times you need to lower the buckets for each capacity.",
        "examples": [
          ">>> max_fill_buckets([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], [1, 2])\n[6, 4]",
          ">>> max_fill_buckets([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], [1, 2])\n[9, 5]",
          ">>> max_fill_buckets([[0, 0, 0], [0, 0, 0]], [5])\n[0]"
        ]
      },
      "template": "def {{ max_fill_buckets }}({{ grid }}: List[List[int]], {{ capacities }}: List[int]) -> List[int]:\n    return [{{ max_fill }}({{ grid }}, {{ capacity }}) for {{ capacity }} in {{ capacities }}]",
      "placeholders": [
        "capacities",
        "grid",
        "max_fill",
        "capacity",
        "max_fill_buckets"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], [1, 2]) == [6, 4]\n    assert candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], [3, 4]) == [4, 3]\n    assert candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], [1, 2]) == [9, 5]\n    assert candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], [3, 4]) == [4, 3]\n    assert candidate([[0, 0, 0], [0, 0, 0]], [5]) == [0]\n    assert candidate([[0, 0, 0], [0, 0, 0]], [1, 2, 3, 4, 5]) == [0, 0, 0, 0, 0]\n\ndef test_check():\n    check(max_fill_buckets)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "sort_array",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "In this Kata, you have to sort an array of non-negative integers according to\nnumber of ones in their binary representation in ascending order.\nFor similar number of ones, sort based on decimal value.\n\nIt must be implemented like this:",
        "examples": [
          ">>> sort_array([1, 5, 2, 3, 4])\n[1, 2, 4, 3, 5]",
          ">>> sort_array([-2, -3, -4, -5, -6])\n[-4, -2, -6, -5, -3]",
          ">>> sort_array([1, 0, 2, 3, 4])\n[0, 1, 2, 4, 3]"
        ]
      },
      "template": "def {{ sort_array }}({{ arr }}: List[int]) -> List[int]:\n    return sorted(sorted({{ arr }}), key=lambda x: bin({{ x }})[2:].count('1'))",
      "placeholders": [
        "sort_array",
        "x",
        "arr"
      ]
    },
    "target_function": {
      "name": "check_moving_sort_array",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "In this Kata, you have to sort an array of non-negative integers according to\nnumber of ones in their binary representation in ascending order.\nFor similar number of ones, sort based on decimal value.\nCompare the original array and its sorted array, and then return the list of whether each\nelement is moved or not from its original position. (True if it is moved, False otherwise.)\n\nIt must be implemented like this:",
        "examples": [
          ">>> check_moving_sort_array([1, 5, 2, 3, 4])\n[False, True, True, False, True]",
          ">>> check_moving_sort_array([-2, -3, -4, -5, -6])\n[True, True, True, False, True]",
          ">>> check_moving_sort_array([1, 0, 2, 3, 4])\n[True, True, False, True, True]"
        ]
      },
      "template": "def {{ check_moving_sort_array }}({{ arr }}: List[int]) -> List[bool]:\n    {{ sorted_arr }} = {{ sort_array }}({{ arr }})\n    return [True if {{ a }} != {{ b }} else False for ({{ a }}, {{ b }}) in zip({{ arr }}, {{ sorted_arr }})]",
      "placeholders": [
        "check_moving_sort_array",
        "a",
        "sorted_arr",
        "b",
        "sort_array",
        "arr"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 5, 2, 3, 4]) == [False, True, True, False, True]\n    assert candidate([-2, -3, -4, -5, -6]) == [True, True, True, False, True]\n    assert candidate([1, 0, 2, 3, 4]) == [True, True, False, True, True]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [False, False, True, True, True, True, True, True]\n    assert candidate([-4, -1, 9, 0, -9, 1, 4]) == [True, True, True, True, True, True, True]\n    assert candidate([11, 14]) == [False, False]\n\ndef test_check():\n    check(check_moving_sort_array)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "select_words",
      "arguments": [
        "s",
        "n"
      ],
      "docstring": {
        "description": "Given a string s and a natural number n, you have been tasked to implement\na function that returns a list of all words from string s that contain exactly\nn consonants, in order these words appear in the string s.\nIf the string s is empty then the function should return an empty list.\nNote: you may assume the input string contains only letters and spaces.",
        "examples": [
          ">>> select_words('Mary had a little lamb', 4)\n['little']",
          ">>> select_words('Mary had a little lamb', 3)\n['Mary', 'lamb']",
          ">>> select_words('simple white space', 2)\n[]",
          ">>> select_words('Hello world', 4)\n['world']",
          ">>> select_words('Uncle sam', 3)\n['Uncle']"
        ]
      },
      "template": "def {{ select_words }}({{ s }}: str, {{ n }}: int) -> List[str]:\n    {{ result }} = []\n    for {{ word }} in {{ s }}.split():\n        {{ n_consonants }} = 0\n        for {{ i }} in range(0, len({{ word }})):\n            if {{ word }}[{{ i }}].lower() not in ['a', 'e', 'i', 'o', 'u']:\n                {{ n_consonants }} += 1\n        if {{ n_consonants }} == {{ n }}:\n            {{ result }}.append({{ word }})\n    return {{ result }}",
      "placeholders": [
        "word",
        "i",
        "s",
        "n_consonants",
        "result",
        "select_words",
        "n"
      ]
    },
    "target_function": {
      "name": "select_largest_word",
      "arguments": [
        "s",
        "n"
      ],
      "docstring": {
        "description": "Given a string s and a natural number n, you have been tasked to implement\na function that returns the word from string s that contain exactly n consonants.\nIf there exist multiple words satisfying the condition, return the largest one in an alphabetical order.\nIf the string s is empty then the function should return an empty string.\nNote: you may assume the input string contains only letters and spaces.",
        "examples": [
          ">>> select_largest_word('Mary had a little lamb', 4)\n'little'",
          ">>> select_largest_word('Mary had a little lamb', 3)\n'lamb'",
          ">>> select_largest_word('simple white space', 2)\n''",
          ">>> select_largest_word('Hello world', 4)\n'world'",
          ">>> select_largest_word('Uncle sam', 3)\n'Uncle'"
        ]
      },
      "template": "def {{ select_largest_word }}({{ s }}: str, {{ n }}: int) -> str:\n    return max({{ select_words }}({{ s }}, {{ n }}) + [''])",
      "placeholders": [
        "s",
        "select_words",
        "select_largest_word",
        "n"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('Mary had a little lamb', 4) == 'little'\n    assert candidate('Mary had a little lamb', 3) == 'lamb'\n    assert candidate('simple white space', 2) == ''\n    assert candidate('Hello world', 4) == 'world'\n    assert candidate('Uncle sam', 3) == 'Uncle'\n    assert candidate('baeiou aeiouz', 1) == 'baeiou'\n\ndef test_check():\n    check(select_largest_word)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "get_closest_vowel",
      "arguments": [
        "word"
      ],
      "docstring": {
        "description": "You are given a word. Your task is to find the closest vowel that stands between\ntwo consonants from the right side of the word (case sensitive).\n\nVowels in the beginning and ending doesn't count. Return empty string if you didn't\nfind any vowel met the above condition.\n\nYou may assume that the given string contains English letter only.",
        "examples": [
          ">>> get_closest_vowel('yogurt')\n'u'",
          ">>> get_closest_vowel('FULL')\n'U'",
          ">>> get_closest_vowel('quick')\n''",
          ">>> get_closest_vowel('ab')\n''"
        ]
      },
      "template": "def {{ get_closest_vowel }}({{ word }}: str) -> str:\n    if len({{ word }}) < 3:\n        return ''\n    {{ vowels }} = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'O', 'U', 'I'}\n    for {{ i }} in range(len({{ word }}) - 2, 0, -1):\n        if {{ word }}[{{ i }}] in {{ vowels }}:\n            if {{ word }}[{{ i }} + 1] not in {{ vowels }} and {{ word }}[{{ i }} - 1] not in {{ vowels }}:\n                return {{ word }}[{{ i }}]\n    return ''",
      "placeholders": [
        "vowels",
        "get_closest_vowel",
        "i",
        "word"
      ]
    },
    "target_function": {
      "name": "transform_closest_vowel",
      "arguments": [
        "s"
      ],
      "docstring": {
        "description": "You are given a string containing multiple words. Your task is to make a new string by changing each word\nto its closest vowel that stands between two consonants from the right side of the word (case sensitive).\nYou need to concatenate all the closest vowels that are obtained from each word.\n\nVowels in the beginning and ending doesn't count. Ignore the word if you didn't\nfind any vowel met the above condition.\n\nYou may assume that the given string contains English letter only.",
        "examples": [
          ">>> transform_closest_vowel('yogurt FULL')\n'uU'",
          ">>> transform_closest_vowel('quick ab')\n''"
        ]
      },
      "template": "def {{ transform_closest_vowel }}({{ s }}: str) -> str:\n    return ''.join([{{ get_closest_vowel }}({{ word }}) for {{ word }} in {{ s }}.split()])",
      "placeholders": [
        "transform_closest_vowel",
        "s",
        "get_closest_vowel",
        "word"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('yogurt FULL') == 'uU'\n    assert candidate('quick ab') == ''\n    assert candidate('Alice loves Bob') == 'ieo'\n    assert candidate('happy sunny day ever') == 'auae'\n    assert candidate('aaa bbb ccc ddd') == ''\n    assert candidate('fox and dog') == 'oo'\n\ndef test_check():\n    check(transform_closest_vowel)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "match_parens",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "You are given a list of two strings, both strings consist of open\nparentheses '(' or close parentheses ')' only.\nYour job is to check if it is possible to concatenate the two strings in\nsome order, that the resulting string will be good.\nA string S is considered to be good if and only if all parentheses in S\nare balanced. For example: the string '(())()' is good, while the string\n'())' is not.\nReturn 'Yes' if there's a way to make a good string, and return 'No' otherwise.",
        "examples": [
          ">>> match_parens(['()(', ')'])\n'Yes'",
          ">>> match_parens([')', ')'])\n'No'"
        ]
      },
      "template": "def {{ match_parens }}({{ lst }}: List[str]) -> str:\n\n    def {{ check }}({{ s }}):\n        {{ val }} = 0\n        for {{ i }} in {{ s }}:\n            if {{ i }} == '(':\n                {{ val }} = {{ val }} + 1\n            else:\n                {{ val }} = {{ val }} - 1\n            if {{ val }} < 0:\n                return False\n        return True if {{ val }} == 0 else False\n    {{ S1 }} = {{ lst }}[0] + {{ lst }}[1]\n    {{ S2 }} = {{ lst }}[1] + {{ lst }}[0]\n    return 'Yes' if {{ check }}({{ S1 }}) or {{ check }}({{ S2 }}) else 'No'",
      "placeholders": [
        "val",
        "check",
        "lst",
        "i",
        "s",
        "S2",
        "S1",
        "match_parens"
      ]
    },
    "target_function": {
      "name": "match_parens_from_list",
      "arguments": [
        "str1",
        "lst2"
      ],
      "docstring": {
        "description": "You are given a string (str1) and a list of strings (lst2), where every string consists of open\nparentheses '(' or close parentheses ')' only.\nYour job is to check if it is possible to concatenate a string (selected from the list lst2)\nand the first string str1 in some order, that the resulting string will be good.\nA string S is considered to be good if and only if all parentheses in S\nare balanced. For example: the string '(())()' is good, while the string '())' is not.\nReturn 'Yes' if there's a way to make a good string, and return 'No' otherwise.",
        "examples": [
          ">>> match_parens_from_list('()(' [')', '(((())(()())))'])\n'Yes'",
          ">>> match_parens_from_list(')', [')'])\n'No'"
        ]
      },
      "template": "def {{ match_parens_from_list }}({{ str1 }}: str, {{ lst2 }}: List[str]) -> str:\n    for {{ str2 }} in {{ lst2 }}:\n        if {{ match_parens }}([{{ str1 }}, {{ str2 }}]) == 'Yes':\n            return 'Yes'\n    return 'No'",
      "placeholders": [
        "lst2",
        "match_parens_from_list",
        "str1",
        "match_parens",
        "str2"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('()(', [')', '(((())(()())))']) == 'Yes'\n    assert candidate(')', [')']) == 'No'\n    assert candidate('()((', ['))', '((()())']) == 'Yes'\n    assert candidate('()((', ['(((()()))', ')']) == 'No'\n    assert candidate('()((', ['(((()()))', ')', ')))', '))))']) == 'No'\n    assert candidate('()((', ['(((()()))', ')', '))']) == 'Yes'\n\ndef test_check():\n    check(match_parens_from_list)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "maximum",
      "arguments": [
        "arr",
        "k"
      ],
      "docstring": {
        "description": "Given an array arr of integers and a positive integer k, return a sorted list\nof length k with the maximum k numbers in arr.",
        "examples": [
          ">>> maximum([-3, -4, 5], 3)\n[-4, -3, 5]",
          ">>> maximum([4, -4, 4], 2)\n[4, 4]",
          ">>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n[2]"
        ]
      },
      "template": "def {{ maximum }}({{ arr }}: List[int], {{ k }}: int) -> List[int]:\n    if {{ k }} == 0:\n        return []\n    {{ arr }}.sort()\n    {{ ans }} = {{ arr }}[-{{ k }}:]\n    return {{ ans }}",
      "placeholders": [
        "ans",
        "k",
        "maximum",
        "arr"
      ]
    },
    "target_function": {
      "name": "minimum_of_maximum_subarrays",
      "arguments": [
        "arrays",
        "k"
      ],
      "docstring": {
        "description": "Given a list of arrays and a positive integer k, return the minimal integer among the arrays.",
        "examples": [
          ">>> minimum_of_maximum_subarrays([[-3, -4, 5], [4, -4, 4], [-3, 2, 1, 2, -1, -2, 1]], 2)\n-3",
          ">>> minimum_of_maximum_subarrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1)\n3"
        ]
      },
      "template": "def {{ minimum_of_maximum_subarrays }}({{ arrays }}: List[List[int]], {{ k }}: int) -> int:\n    {{ mins }} = [{{ maximum }}({{ arr }}, {{ k }})[0] for {{ arr }} in {{ arrays }}]\n    return min({{ mins }})",
      "placeholders": [
        "minimum_of_maximum_subarrays",
        "arrays",
        "mins",
        "k",
        "maximum",
        "arr"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[9, 3, 7], [5, 6]], 2) == 5\n    assert candidate([[37, 51, 22], [99, 13, 45], [43, 36, 28], [28, 39, 22]], 1) == 39\n    assert candidate([[50, 40, 20, 10], [22, 62, 78, 90]], 4) == 10\n\ndef test_check():\n    check(minimum_of_maximum_subarrays)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "solution",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.",
        "examples": [
          ">>> solution([5, 8, 7, 1])\n12",
          ">>> solution([3, 3, 3, 3, 3])\n9",
          ">>> solution([30, 13, 24, 321])\n0"
        ]
      },
      "template": "def {{ solution }}({{ lst }}: List[int]) -> int:\n    return sum([{{ x }} for ({{ idx }}, {{ x }}) in enumerate({{ lst }}) if {{ idx }} % 2 == 0 and {{ x }} % 2 == 1])",
      "placeholders": [
        "solution",
        "x",
        "lst",
        "idx"
      ]
    },
    "target_function": {
      "name": "alternate_sum",
      "arguments": [
        "arrays"
      ],
      "docstring": {
        "description": "Given a list of arrays, return the sum of all of the odd elements that are in even positions\nof all arrays in even positions minus the sum of all of the odd elements that are in odd positions.",
        "examples": [
          ">>> alternate_sum([[5, 8, 7, 1], [3, 3, 3, 3, 3]])\n3",
          ">>> alternate_sum([[30, 13, 24, 321], [3, 3, 3, 3, 3]])\n-9"
        ]
      },
      "template": "def {{ alternate_sum }}({{ arrays }}: List[List[int]]) -> int:\n    return sum([{{ solution }}({{ x }}) for ({{ idx }}, {{ x }}) in enumerate({{ arrays }}) if {{ idx }} % 2 == 0]) - sum([{{ solution }}({{ x }}) for ({{ idx }}, {{ x }}) in enumerate({{ arrays }}) if {{ idx }} % 2 == 1])",
      "placeholders": [
        "x",
        "arrays",
        "solution",
        "alternate_sum",
        "idx"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8, 9]]) == -17\n    assert candidate([[10, 11], [-4, -5, -6, -7], [1, 3, 5, 7, 9]]) == 15\n    assert candidate([[6, 4, 3, -1, -2], [8, 9, 10, 11]]) == 3\n\ndef test_check():\n    check(alternate_sum)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "add_elements",
      "arguments": [
        "arr",
        "k"
      ],
      "docstring": {
        "description": "Given a non-empty array of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.",
        "examples": [
          ">>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n24"
        ]
      },
      "template": "def {{ add_elements }}({{ arr }}: List[int], {{ k }}: int) -> int:\n    return sum(({{ elem }} for {{ elem }} in {{ arr }}[:{{ k }}] if len(str({{ elem }})) <= 2))",
      "placeholders": [
        "add_elements",
        "k",
        "arr",
        "elem"
      ]
    },
    "target_function": {
      "name": "max_num_passengers",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Given an array of integers arr where each element represents the weight of\npassengers, return the maximum number of passengers that can be carried on\na single elevator given that the sum of all the weights must be less than 100.",
        "examples": [
          ">>> max_num_passengers([111, 21, 3, 4000, 5, 6, 7, 8, 9])\n7",
          ">>> max_num_passengers([215, 327, 102])\n0"
        ]
      },
      "template": "def {{ max_num_passengers }}({{ arr }}: List[int]) -> int:\n    {{ arr }}.sort()\n    for {{ k }} in range(1, len({{ arr }}) + 1):\n        if {{ add_elements }}({{ arr }}, {{ k }}) >= 100:\n            return {{ k }} - 1\n    return len({{ arr }})",
      "placeholders": [
        "add_elements",
        "max_num_passengers",
        "k",
        "arr"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([70, 13, 25, 10, 10, 45]) == 4\n    assert candidate([60, 55, 42, 37, 97]) == 2\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9\n\ndef test_check():\n    check(max_num_passengers)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "get_odd_collatz",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\nThe Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\nas follows: start with any positive integer n. Then each term is obtained from the\nprevious term as follows: if the previous term is even, the next term is one half of\nthe previous term. If the previous term is odd, the next term is 3 times the previous\nterm plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\nNote:\n    1. Collatz(1) is [1].\n    2. returned list sorted in increasing order.\n\nFor example:\nget_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.",
        "examples": [
          ">>> get_odd_collatz(5)\n[1, 5]"
        ]
      },
      "template": "def {{ get_odd_collatz }}({{ n }}: int) -> List[int]:\n    if {{ n }} % 2 == 0:\n        {{ odd_collatz }} = []\n    else:\n        {{ odd_collatz }} = [{{ n }}]\n    while {{ n }} > 1:\n        if {{ n }} % 2 == 0:\n            {{ n }} = {{ n }} / 2\n        else:\n            {{ n }} = {{ n }} * 3 + 1\n        if {{ n }} % 2 == 1:\n            {{ odd_collatz }}.append(int({{ n }}))\n    return sorted({{ odd_collatz }})",
      "placeholders": [
        "get_odd_collatz",
        "odd_collatz",
        "n"
      ]
    },
    "target_function": {
      "name": "sum_odd_collatz",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Given a positive integer n, return the sum of odd numbers in collatz sequence.",
        "examples": [
          ">>> sum_odd_collatz(5)\n6",
          ">>> sum_odd_collatz(10)\n6"
        ]
      },
      "template": "def {{ sum_odd_collatz }}({{ n }}: int) -> int:\n    return sum({{ get_odd_collatz }}({{ n }}))",
      "placeholders": [
        "get_odd_collatz",
        "n",
        "sum_odd_collatz"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(11) == 47\n    assert candidate(7) == 54\n    assert candidate(100) == 19\n\ndef test_check():\n    check(sum_odd_collatz)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "valid_date",
      "arguments": [
        "date"
      ],
      "docstring": {
        "description": "You have to write a function which validates a given date string and\nreturns True if the date is valid otherwise False.\nThe date is valid if all of the following rules are satisfied:\n1. The date string is not empty.\n2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n3. The months should not be less than 1 or higher than 12.\n4. The date should be in the format: mm-dd-yyyy",
        "examples": [
          ">>> valid_date('03-11-2000')\nTrue",
          ">>> valid_date('15-01-2012')\nFalse",
          ">>> valid_date('04-0-2040')\nFalse",
          ">>> valid_date('06-04-2020')\nTrue",
          ">>> valid_date('06/04/2020')\nFalse"
        ]
      },
      "template": "def {{ valid_date }}({{ date }}: str) -> bool:\n    try:\n        {{ date }} = {{ date }}.strip()\n        ({{ month }}, {{ day }}, {{ year }}) = {{ date }}.split('-')\n        ({{ month }}, {{ day }}, {{ year }}) = (int({{ month }}), int({{ day }}), int({{ year }}))\n        if {{ month }} < 1 or {{ month }} > 12:\n            return False\n        if {{ month }} in [1, 3, 5, 7, 8, 10, 12] and {{ day }} < 1 or {{ day }} > 31:\n            return False\n        if {{ month }} in [4, 6, 9, 11] and {{ day }} < 1 or {{ day }} > 30:\n            return False\n        if {{ month }} == 2 and {{ day }} < 1 or {{ day }} > 29:\n            return False\n    except:\n        return False\n    return True",
      "placeholders": [
        "year",
        "date",
        "day",
        "month",
        "valid_date"
      ]
    },
    "target_function": {
      "name": "num_valid_birthdays",
      "arguments": [
        "dates"
      ],
      "docstring": {
        "description": "Given a list of birthdays with valid dates, return the number of people\nwho can be given some birthday gifts.",
        "examples": [
          ">>> num_valid_birthdays(['03-11-2000', '15-01-2012', '04-0-2040', '06-04-2020'])\n2"
        ]
      },
      "template": "def {{ num_valid_birthdays }}({{ dates }}: List[str]) -> int:\n    return sum([{{ valid_date }}({{ date }}) for {{ date }} in {{ dates }}])",
      "placeholders": [
        "dates",
        "valid_date",
        "date",
        "num_valid_birthdays"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['06/04/2020', '12-11-1987', '04-00-1999', '08-15-1992']) == 3\n    assert candidate(['00-01-1951', '19-02-1994', '10-24-1992']) == 1\n    assert candidate(['12-05-1976', '01-01-2010', '01/01/2010']) == 2\n\ndef test_check():\n    check(num_valid_birthdays)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Union"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "split_words",
      "arguments": [
        "txt"
      ],
      "docstring": {
        "description": "Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\nshould split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\nalphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25",
        "examples": [
          ">>> split_words('Hello world!')\n['Hello', 'world!']",
          ">>> split_words('Hello,world!')\n['Hello', 'world!']",
          ">>> split_words('abcdef')\n3"
        ]
      },
      "template": "def {{ split_words }}({{ txt }}: str) -> Union[List[str], int]:\n    if ' ' in {{ txt }}:\n        return {{ txt }}.split()\n    elif ',' in {{ txt }}:\n        return {{ txt }}.replace(',', ' ').split()\n    else:\n        return len([{{ i }} for {{ i }} in {{ txt }} if {{ i }}.islower() and ord({{ i }}) % 2 == 0])",
      "placeholders": [
        "txt",
        "split_words",
        "i"
      ]
    },
    "target_function": {
      "name": "num_words",
      "arguments": [
        "txt"
      ],
      "docstring": {
        "description": "Given one sentence of words, return the number of words in it.",
        "examples": [
          ">>> num_words('Hello world!')\n2",
          ">>> num_words('Hello,world!')\n2",
          ">>> num_words('abcdef')\n1"
        ]
      },
      "template": "def {{ num_words }}({{ txt }}: str) -> int:\n    {{ result }} = {{ split_words }}({{ txt }})\n    if isinstance({{ result }}, list):\n        return len({{ result }})\n    else:\n        return 1",
      "placeholders": [
        "txt",
        "num_words",
        "result",
        "split_words"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('The fox jumped over the fence.') == 6\n    assert candidate('The,fox,jumped,over,the,fence.') == 6\n    assert candidate('I, as a human, love to sleep.') == 7\n\ndef test_check():\n    check(num_words)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "is_sorted",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a list of numbers, return whether or not they are sorted\nin ascending order. If list has more than 1 duplicate of the same\nnumber, return False. Assume no negative numbers and only integers.",
        "examples": [
          ">>> is_sorted([5])\nTrue",
          ">>> is_sorted([1, 2, 3, 4, 5])\nTrue",
          ">>> is_sorted([1, 3, 2, 4, 5])\nFalse",
          ">>> is_sorted([1, 2, 3, 4, 5, 6])\nTrue",
          ">>> is_sorted([1, 2, 3, 4, 5, 6, 7])\nTrue",
          ">>> is_sorted([1, 3, 2, 4, 5, 6, 7])\nFalse",
          ">>> is_sorted([1, 2, 2, 3, 3, 4])\nTrue",
          ">>> is_sorted([1, 2, 2, 2, 3, 4])\nFalse"
        ]
      },
      "template": "def {{ is_sorted }}({{ lst }}: List[int]) -> bool:\n    {{ count_digit }} = dict([({{ i }}, 0) for {{ i }} in {{ lst }}])\n    for {{ i }} in {{ lst }}:\n        {{ count_digit }}[{{ i }}] += 1\n    if any(({{ count_digit }}[{{ i }}] > 2 for {{ i }} in {{ lst }})):\n        return False\n    if all(({{ lst }}[{{ i }} - 1] <= {{ lst }}[{{ i }}] for {{ i }} in range(1, len({{ lst }})))):\n        return True\n    else:\n        return False",
      "placeholders": [
        "i",
        "lst",
        "count_digit",
        "is_sorted"
      ]
    },
    "target_function": {
      "name": "all_sorted",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a non-empty list of lists of integers, return a boolean values indicating\nwhether each sublist is sorted in ascending order without more than one duplicate of the same number.",
        "examples": [
          ">>> all_sorted([[5], [1, 2, 3, 4, 5], [1, 3, 2, 4, 5], [1, 2, 3, 4, 5, 6], [1, 2, 2, 2, 3, 4]])\nFalse",
          ">>> all_sorted([1, 2, 3, 4, 5, 6, 7], [1, 2, 2, 3, 3, 4], [3, 5, 7, 8])\nTrue"
        ]
      },
      "template": "def {{ all_sorted }}({{ lst }}: List[List[int]]) -> bool:\n    return all([{{ is_sorted }}({{ sublist }}) for {{ sublist }} in {{ lst }}])",
      "placeholders": [
        "lst",
        "sublist",
        "is_sorted",
        "all_sorted"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 1, 1, 2], [2, 3, 5], [4, 4, 5]) is False\n    assert candidate([1, 2, 3, 4, 5], [5, 7, 10, 13]) is True\n    assert candidate([3, 3, 4], [1, 2, 3], [7, 6, 7]) is False\n\ndef test_check():\n    check(all_sorted)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "itertools",
        [
          "combinations"
        ]
      ],
      [
        "typing",
        [
          "List",
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "intersection",
      "arguments": [
        "interval1",
        "interval2"
      ],
      "docstring": {
        "description": "You are given two intervals,\nwhere each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two\nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".",
        "examples": [
          ">>> intersection((1, 2), (2, 3))\n'NO'",
          ">>> intersection((-1, 1), (0, 4))\n'NO'",
          ">>> intersection((-3, -1), (-5, 5))\n'YES'"
        ]
      },
      "template": "def {{ intersection }}({{ interval1 }}: Tuple[int, int], {{ interval2 }}: Tuple[int, int]) -> str:\n\n    def {{ is_prime }}({{ num }}):\n        if {{ num }} == 1 or {{ num }} == 0:\n            return False\n        if {{ num }} == 2:\n            return True\n        for {{ i }} in range(2, {{ num }}):\n            if {{ num }} % {{ i }} == 0:\n                return False\n        return True\n    {{ l }} = max({{ interval1 }}[0], {{ interval2 }}[0])\n    {{ r }} = min({{ interval1 }}[1], {{ interval2 }}[1])\n    {{ length }} = {{ r }} - {{ l }}\n    if {{ length }} > 0 and {{ is_prime }}({{ length }}):\n        return 'YES'\n    return 'NO'",
      "placeholders": [
        "r",
        "length",
        "i",
        "l",
        "interval1",
        "num",
        "is_prime",
        "intersection",
        "interval2"
      ]
    },
    "target_function": {
      "name": "all_prime_intersection",
      "arguments": [
        "intervals"
      ],
      "docstring": {
        "description": "Check if all intersections of given intervals are prime numbers.",
        "examples": [
          ">>> all_prime_intersection([(1, 2), (2, 3), (3, 4)])\nFalse",
          ">>> all_prime_intersection([(-3, 4), (-5, 5), (1, 4)])\nTrue"
        ]
      },
      "template": "def {{ all_prime_intersection }}({{ intervals }}: List[Tuple[int, int]]) -> bool:\n    {{ comb }} = combinations({{ intervals }}, 2)\n    for ({{ interval1 }}, {{ interval2 }}) in {{ comb }}:\n        if {{ intersection }}({{ interval1 }}, {{ interval2 }}) == 'NO':\n            return False\n    return True",
      "placeholders": [
        "intervals",
        "interval1",
        "comb",
        "all_prime_intersection",
        "intersection",
        "interval2"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([(-3, -1), (-5, 5), (3, 4)]) is False\n    assert candidate([(-1, 7), (-5, 4), (1, 4)]) is True\n    assert candidate([(1, 8), (3, 8), (-2, 6)]) is True\n\ndef test_check():\n    check(all_prime_intersection)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Optional"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "prod_signs",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "You are given an array arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the array, represented by 1, -1 or 0.\nNote: return None for empty arr.",
        "examples": [
          ">>> prod_signs([1, 2, 2, -4])\n9",
          ">>> prod_signs([0, 1])\n0",
          ">>> prod_signs([])\nNone"
        ]
      },
      "template": "def {{ prod_signs }}({{ arr }}: List[int]) -> Optional[int]:\n    if not {{ arr }}:\n        return None\n    {{ prod }} = 0 if 0 in {{ arr }} else (-1) ** len(list(filter(lambda x: {{ x }} < 0, {{ arr }})))\n    return {{ prod }} * sum([abs({{ i }}) for {{ i }} in {{ arr }}])",
      "placeholders": [
        "prod_signs",
        "i",
        "x",
        "prod",
        "arr"
      ]
    },
    "target_function": {
      "name": "prod_signs_within_threshold",
      "arguments": [
        "arr",
        "threshold"
      ],
      "docstring": {
        "description": "You are given an array arr of integers and you need to return\nsum of magnitudes of integers within the threshold value,\nmultiplied by product of all signs of each number in the array.\nNote: return None for empty arr.",
        "examples": [
          ">>> prod_signs_within_threshold([1, 2, 2, -4], 3)\n5",
          ">>> prod_signs_within_threshold([0, 1], 1)\n0",
          ">>> prod_signs_within_threshold([], 1)\nNone"
        ]
      },
      "template": "def {{ prod_signs_within_threshold }}({{ arr }}: List[int], {{ threshold }}: int) -> Optional[int]:\n    return {{ prod_signs }}(list(filter(lambda x: abs({{ x }}) <= {{ threshold }}, {{ arr }})))",
      "placeholders": [
        "prod_signs",
        "threshold",
        "x",
        "prod_signs_within_threshold",
        "arr"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([-1, -3, -5, -7, -9], 5) == 4\n    assert candidate([-10, -20, 30, -40, 50, -60], 45) == -100\n    assert candidate([-3, -2, -1, 0, 1, 2, 3], 2) == 0\n\ndef test_check():\n    check(prod_signs_within_threshold)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "tri",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\nthe last couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence:\ntri(1) = 3\ntri(n) = 1 + n / 2, if n is even.\ntri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8\nYou are given a non-negative integer number n, you have to a return a list of the\nfirst n + 1 numbers of the Tribonacci sequence.",
        "examples": [
          ">>> tri(3)\n[1, 3, 2, 8]"
        ]
      },
      "template": "def {{ tri }}({{ n }}: int) -> list[int]:\n    if {{ n }} == 0:\n        return [1]\n    {{ my_tri }} = [1, 3]\n    for {{ i }} in range(2, {{ n }} + 1):\n        if {{ i }} % 2 == 0:\n            {{ my_tri }}.append({{ i }} / 2 + 1)\n        else:\n            {{ my_tri }}.append({{ my_tri }}[{{ i }} - 1] + {{ my_tri }}[{{ i }} - 2] + ({{ i }} + 3) / 2)\n    return {{ my_tri }}",
      "placeholders": [
        "i",
        "tri",
        "my_tri",
        "n"
      ]
    },
    "target_function": {
      "name": "beautiful_tri",
      "arguments": [
        "start",
        "end"
      ],
      "docstring": {
        "description": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\nthe last couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence:\ntri(1) = 3\ntri(n) = 1 + n / 2, if n is even.\ntri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8\nYou are given a non-negative integer number n, you have to a return a list of the\nstart-th number and end-th number of the Tribonacci sequence that the number is\na multiple of 3.",
        "examples": [
          ">>> tri(5, 10)\n[3]"
        ]
      },
      "template": "def {{ beautiful_tri }}({{ start }}: int, {{ end }}: int) -> list[int]:\n    return [int({{ i }}) for {{ i }} in {{ tri }}({{ end }})[{{ start }}:] if {{ i }} % 3 == 0]",
      "placeholders": [
        "start",
        "i",
        "end",
        "beautiful_tri",
        "tri"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(5, 10) == [15, 24, 6]\n    assert candidate(21, 29) == [12, 168, 195, 15, 255]\n    assert candidate(33, 49) == [18, 360, 399, 21, 483, 528, 24, 624, 675]\n\ndef test_check():\n    check(beautiful_tri)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "digits",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Given a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.",
        "examples": [
          ">>> digits(1)\n1",
          ">>> digits(4)\n0",
          ">>> digits(235)\n15"
        ]
      },
      "template": "def {{ digits }}({{ n }}: int) -> int:\n    {{ product }} = 1\n    {{ odd_count }} = 0\n    for {{ digit }} in str({{ n }}):\n        {{ int_digit }} = int({{ digit }})\n        if {{ int_digit }} % 2 == 1:\n            {{ product }} = {{ product }} * {{ int_digit }}\n            {{ odd_count }} += 1\n    if {{ odd_count }} == 0:\n        return 0\n    else:\n        return {{ product }}",
      "placeholders": [
        "product",
        "odd_count",
        "digit",
        "int_digit",
        "digits",
        "n"
      ]
    },
    "target_function": {
      "name": "unique_odd_digits",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a list of positive integers, return the product of unique odd digits.",
        "examples": [
          ">>> unique_odd_digits([1, 4, 235])\n15",
          ">>> unique_odd_digits([123, 456, 789])\n945",
          ">>> unique_odd_digits([2, 4, 6, 8, 99])\n9"
        ]
      },
      "template": "def {{ unique_odd_digits }}({{ lst }}: List[int]) -> int:\n    {{ concat }} = ''\n    for {{ num }} in {{ lst }}:\n        {{ concat }} += str({{ num }})\n    {{ unique }} = set({{ concat }})\n    return {{ digits }}(int(''.join({{ unique }})))",
      "placeholders": [
        "lst",
        "concat",
        "num",
        "digits",
        "unique_odd_digits",
        "unique"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([0, 1, 2, 3, 4, 5]) == 15\n    assert candidate([22, 44, 66, 88]) == 0\n    assert candidate([1325, 540, 938]) == 135\n\ndef test_check():\n    check(unique_odd_digits)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "sum_squares",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "You are given a list of numbers.\nYou need to return the sum of squared numbers in the given list,\nround each element in the list to the upper int(Ceiling) first.",
        "examples": [
          ">>> lst([1.0, 2.0, 3.0])\n14",
          ">>> lst([1.0, 4.0, 9.0])\n98",
          ">>> lst([1.0, 3.0, 5.0, 7.0])\n84",
          ">>> lst([1.4, 4.2, 0.0])\n29",
          ">>> lst([-2.4, 1.0, 1.0])\n6"
        ]
      },
      "template": "def {{ sum_squares }}({{ lst }}: List[float]) -> int:\n    import math\n    {{ squared }} = 0\n    for {{ i }} in {{ lst }}:\n        {{ squared }} += math.ceil({{ i }}) ** 2\n    return {{ squared }}",
      "placeholders": [
        "i",
        "squared",
        "lst",
        "sum_squares"
      ]
    },
    "target_function": {
      "name": "diff_ceil_floor_sum_squares",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "You are given a list of numbers.\nYou need to return the absolute difference between the sum of squared numbers in the given list,\nround each element in the list to the upper int(Ceiling) first,\nand the sum of squared numbers in the given list,\nround each element in the list to the lower int(Floor) first.",
        "examples": [
          ">>> lst([1.0, 2.0, 3.0])\n0",
          ">>> lst([1.4, 4.2, 0.0])\n12",
          ">>> lst([-2.4, 1.0, 1.0])\n5"
        ]
      },
      "template": "def {{ diff_ceil_floor_sum_squares }}({{ lst }}: List[float]) -> int:\n    return abs({{ sum_squares }}({{ lst }}) - {{ sum_squares }}([-{{ i }} for {{ i }} in {{ lst }}]))",
      "placeholders": [
        "i",
        "diff_ceil_floor_sum_squares",
        "lst",
        "sum_squares"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([-3.1, 2.5, 7.9]) == 13\n    assert candidate([0.5, -0.5, 3.0, -2.0]) == 0\n    assert candidate([-3.2, -2.8, -1.6, 0.7, 1.5, 2.8]) == 6\n\ndef test_check():\n    check(diff_ceil_floor_sum_squares)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "check_if_last_char_is_a_letter",
      "arguments": [
        "txt"
      ],
      "docstring": {
        "description": "Create a function that returns True if the last character\nof a given string is an alphabetical character and is not\na part of a word, and False otherwise.\nNote: \"word\" is a group of characters separated by space.",
        "examples": [
          ">>> check_if_last_char_is_a_letter('apple pie')\nFalse",
          ">>> check_if_last_char_is_a_letter('apple pi e')\nTrue",
          ">>> check_if_last_char_is_a_letter('apple pi e ')\nFalse",
          ">>> check_if_last_char_is_a_letter('')\nFalse"
        ]
      },
      "template": "def {{ check_if_last_char_is_a_letter }}({{ txt }}: str) -> bool:\n    {{ check }} = {{ txt }}.split(' ')[-1]\n    return True if len({{ check }}) == 1 and 97 <= ord({{ check }}.lower()) <= 122 else False",
      "placeholders": [
        "txt",
        "check",
        "check_if_last_char_is_a_letter"
      ]
    },
    "target_function": {
      "name": "check_if_first_char_is_a_letter",
      "arguments": [
        "txt"
      ],
      "docstring": {
        "description": "Create a function that returns True if the first character\nof a given string is an alphabetical character and is not\na part of a word, and False otherwise.\nNote: \"word\" is a group of characters separated by space.",
        "examples": [
          ">>> check_if_first_char_is_a_letter('apple pie')\nFalse",
          ">>> check_if_first_char_is_a_letter('a pple pie')\nTrue",
          ">>> check_if_first_char_is_a_letter(' a pple pie')\nFalse",
          ">>> check_if_first_char_is_a_letter('')\nFalse"
        ]
      },
      "template": "def {{ check_if_first_char_is_a_letter }}({{ txt }}: str) -> bool:\n    return {{ check_if_last_char_is_a_letter }}({{ txt }}[::-1])",
      "placeholders": [
        "txt",
        "check_if_first_char_is_a_letter",
        "check_if_last_char_is_a_letter"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('a boat is on the river') is True\n    assert candidate(' over the rainbow') is False\n    assert candidate('life is good') is False\n\ndef test_check():\n    check(check_if_first_char_is_a_letter)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "can_arrange",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Create a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given array will not contain\nduplicate values.",
        "examples": [
          ">>> can_arrange([1, 2, 4, 3, 5])\n3",
          ">>> can_arrange([1, 2, 3])\n-1"
        ]
      },
      "template": "def {{ can_arrange }}({{ arr }}: List[int]) -> int:\n    {{ ind }} = -1\n    {{ i }} = 1\n    while {{ i }} < len({{ arr }}):\n        if {{ arr }}[{{ i }}] < {{ arr }}[{{ i }} - 1]:\n            {{ ind }} = {{ i }}\n        {{ i }} += 1\n    return {{ ind }}",
      "placeholders": [
        "i",
        "arr",
        "ind",
        "can_arrange"
      ]
    },
    "target_function": {
      "name": "is_ordered",
      "arguments": [
        "arr"
      ],
      "docstring": {
        "description": "Create a function which returns True if the given array is sorted in\neither ascending or descending order, otherwise return False.",
        "examples": [
          ">>> is_ordered([1, 2, 4, 3, 5])\nFalse",
          ">>> is_ordered([1, 2, 3])\nTrue",
          ">>> is_ordered([3, 2, 1])\nTrue"
        ]
      },
      "template": "def {{ is_ordered }}({{ arr }}: List[int]) -> bool:\n    return {{ can_arrange }}({{ arr }}) == -1 or {{ can_arrange }}({{ arr }}[::-1]) == -1",
      "placeholders": [
        "is_ordered",
        "arr",
        "can_arrange"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([6, 5, 4, 3, 2, 1]) is True\n    assert candidate([3, 5, 4, 2, 7, 9]) is False\n    assert candidate([-1, -2, -3, -5]) is True\n\ndef test_check():\n    check(is_ordered)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List",
          "Optional",
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "largest_smallest_integers",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Create a function that returns a tuple (a, b), where 'a' is\nthe largest of negative integers, and 'b' is the smallest\nof positive integers in a list.\nIf there is no negative or positive integers, return them as None.",
        "examples": [
          ">>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n(None, 1)",
          ">>> largest_smallest_integers([])\n(None, None)",
          ">>> largest_smallest_integers([0])\n(None, None)"
        ]
      },
      "template": "def {{ largest_smallest_integers }}({{ lst }}: List[int]) -> Tuple[Optional[int], Optional[int]]:\n    {{ smallest }} = list(filter(lambda x: {{ x }} < 0, {{ lst }}))\n    {{ largest }} = list(filter(lambda x: {{ x }} > 0, {{ lst }}))\n    return (max({{ smallest }}) if {{ smallest }} else None, min({{ largest }}) if {{ largest }} else None)",
      "placeholders": [
        "lst",
        "x",
        "smallest",
        "largest_smallest_integers",
        "largest"
      ]
    },
    "target_function": {
      "name": "smallest_interval_including_zero",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Create a function that returns the length of the smallest interval that includes zero.\nIf there is no such interval, return 0.",
        "examples": [
          ">>> smallest_interval_including_zero([2, 4, 1, 3, 5, 7])\n0",
          ">>> smallest_interval_including_zero([0])\n0",
          ">>> smallest_interval_including_zero([-5, -3, 1, 2, 4])\n4"
        ]
      },
      "template": "def {{ smallest_interval_including_zero }}({{ lst }}: List[int]) -> int:\n    ({{ start }}, {{ end }}) = {{ largest_smallest_integers }}({{ lst }})\n    if {{ start }} is None or {{ end }} is None:\n        return 0\n    return {{ end }} - {{ start }}",
      "placeholders": [
        "lst",
        "start",
        "end",
        "largest_smallest_integers",
        "smallest_interval_including_zero"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([-2, 0, 1, 2, 3]) == 3\n    assert candidate([0, 1, 2, 3]) == 0\n    assert candidate([-5, -4, -3, -2, -1]) == 0\n\ndef test_check():\n    check(smallest_interval_including_zero)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "itertools",
        [
          "combinations"
        ]
      ],
      [
        "typing",
        [
          "List",
          "Union"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "compare_one",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Create a function that takes integers, floats, or strings representing\nreal numbers, and returns the larger variable in its given variable type.\nReturn None if the values are equal.\nNote: If a real number is represented as a string, the floating point might be . or ,",
        "examples": [
          ">>> compare_one(1, 2.5)\n2.5",
          ">>> compare_one(1, '2,3')\n'2,3'",
          ">>> compare_one('5,1', '6')\n'6'",
          ">>> compare_one('1', 1)\nNone"
        ]
      },
      "template": "def {{ compare_one }}({{ a }}: Union[int, float, str], {{ b }}: Union[int, float, str]) -> Union[int, float, str, None]:\n    ({{ temp_a }}, {{ temp_b }}) = ({{ a }}, {{ b }})\n    if isinstance({{ temp_a }}, str):\n        {{ temp_a }} = {{ temp_a }}.replace(',', '.')\n    if isinstance({{ temp_b }}, str):\n        {{ temp_b }} = {{ temp_b }}.replace(',', '.')\n    if float({{ temp_a }}) == float({{ temp_b }}):\n        return None\n    return {{ a }} if float({{ temp_a }}) > float({{ temp_b }}) else {{ b }}",
      "placeholders": [
        "compare_one",
        "a",
        "temp_b",
        "b",
        "temp_a"
      ]
    },
    "target_function": {
      "name": "biggest",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Create a function that takes a list of integers, floats, or strings representing\nreal numbers, and returns the non-duplicate largest variable in its given variable type.\nReturn None if the largest value is duplicated.\nNote: If a real number is represented as a string, the floating point might be . or ,",
        "examples": [
          ">>> biggest([1, 2.5, '2,3'])\n2.5",
          ">>> biggest(['1', 1])\nNone",
          ">>> biggest(['5,1', '-6'])\n'5,1'"
        ]
      },
      "template": "def {{ biggest }}({{ lst }}: List[Union[int, float, str]]) -> Union[int, float, str, None]:\n    {{ bigger }} = [{{ compare_one }}({{ a }}, {{ b }}) for ({{ a }}, {{ b }}) in combinations({{ lst }}, 2)]\n    {{ bigger }} = [{{ elem }} for {{ elem }} in {{ bigger }} if {{ elem }} is not None]\n    if not {{ bigger }}:\n        return None\n    return max({{ bigger }})",
      "placeholders": [
        "compare_one",
        "biggest",
        "lst",
        "bigger",
        "a",
        "elem",
        "b"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([1, 1, 1, 1, 1]) is None\n    assert candidate(['8,4', 8.1, '-8,3', 8.2]) == '8,4'\n    assert candidate([10, 10, 8, 9, 6]) == 10\n\ndef test_check():\n    check(biggest)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "is_equal_to_sum_even",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers",
        "examples": [
          ">>> is_equal_to_sum_even(4)\nFalse",
          ">>> is_equal_to_sum_even(6)\nFalse",
          ">>> is_equal_to_sum_even(8)\nTrue"
        ]
      },
      "template": "def {{ is_equal_to_sum_even }}({{ n }}: int) -> bool:\n    return {{ n }} % 2 == 0 and {{ n }} >= 8",
      "placeholders": [
        "is_equal_to_sum_even",
        "n"
      ]
    },
    "target_function": {
      "name": "num_test_subjects",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "In your country, people are obligated to take a inspection test every 2 years\nafter they turn 8.\nYou are given a list of ages of people in your country. Return the number of\npeople who are required to take the test in the next year.",
        "examples": [
          ">>> num_test_subjects([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n2",
          ">>> num_test_subjects([30, 42, 27, 21, 8, 1])\n2",
          ">>> num_test_subjects([7, 3, 5, 6, 8, 9])\n2"
        ]
      },
      "template": "def {{ num_test_subjects }}({{ lst }}: List[int]) -> int:\n    return sum([{{ is_equal_to_sum_even }}({{ x }} + 1) for {{ x }} in {{ lst }}])",
      "placeholders": [
        "x",
        "is_equal_to_sum_even",
        "lst",
        "num_test_subjects"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([27, 28, 29, 30, 31, 32]) == 3\n    assert candidate([7, 6, 8, 9, 11, 13, 100]) == 4\n    assert candidate([37, 31, 30, 29, 8, 13, 14, 49, 57]) == 6\n\ndef test_check():\n    check(num_test_subjects)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "special_factorial",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "The Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0",
        "examples": [
          ">>> special_factorial(4)\n288"
        ]
      },
      "template": "def {{ special_factorial }}({{ n }}: int) -> int:\n    {{ fact_i }} = 1\n    {{ special_fact }} = 1\n    for {{ i }} in range(1, {{ n }} + 1):\n        {{ fact_i }} *= {{ i }}\n        {{ special_fact }} *= {{ fact_i }}\n    return {{ special_fact }}",
      "placeholders": [
        "i",
        "fact_i",
        "special_fact",
        "n",
        "special_factorial"
      ]
    },
    "target_function": {
      "name": "factorial",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "The factorial of a positive integer n, denoted by n!, is the product of all\npositive integers less than or equal to n.",
        "examples": [
          ">>> factorial(4)\n24",
          ">>> factorial(1)\n1",
          ">>> factorial(5)\n120"
        ]
      },
      "template": "def {{ factorial }}({{ n }}: int) -> int:\n    {{ fact }} = {{ special_factorial }}({{ n }})\n    for {{ i }} in range(1, {{ n }}):\n        {{ fact }} //= {{ special_factorial }}({{ i }})\n    return {{ fact }}",
      "placeholders": [
        "fact",
        "i",
        "factorial",
        "n",
        "special_factorial"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(7) == 5040\n    assert candidate(6) == 720\n    assert candidate(10) == 3628800\n\ndef test_check():\n    check(factorial)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "fix_spaces",
      "arguments": [
        "text"
      ],
      "docstring": {
        "description": "Given a string text, replace all spaces in it with underscores,\nand if a string has more than 2 consecutive spaces,\nthen replace all consecutive spaces with -",
        "examples": [
          ">>> fix_spaces('Example')\n'Example'",
          ">>> fix_spaces('Example 1')\n'Example_1'",
          ">>> fix_spaces(' Example 2')\n'_Example_2'",
          ">>> fix_spaces(' Example  3')\n'_Example-3'"
        ]
      },
      "template": "def {{ fix_spaces }}({{ text }}: str) -> str:\n    {{ new_text }} = ''\n    {{ i }} = 0\n    ({{ start }}, {{ end }}) = (0, 0)\n    while {{ i }} < len({{ text }}):\n        if {{ text }}[{{ i }}] == ' ':\n            {{ end }} += 1\n        else:\n            if {{ end }} - {{ start }} > 2:\n                {{ new_text }} += '-' + {{ text }}[{{ i }}]\n            elif {{ end }} - {{ start }} > 0:\n                {{ new_text }} += '_' * ({{ end }} - {{ start }}) + {{ text }}[{{ i }}]\n            else:\n                {{ new_text }} += {{ text }}[{{ i }}]\n            ({{ start }}, {{ end }}) = ({{ i }} + 1, {{ i }} + 1)\n        {{ i }} += 1\n    if {{ end }} - {{ start }} > 2:\n        {{ new_text }} += '-'\n    elif {{ end }} - {{ start }} > 0:\n        {{ new_text }} += '_'\n    return {{ new_text }}",
      "placeholders": [
        "start",
        "new_text",
        "i",
        "fix_spaces",
        "end",
        "text"
      ]
    },
    "target_function": {
      "name": "extended_fix_spaces",
      "arguments": [
        "text"
      ],
      "docstring": {
        "description": "Given a string text, replace all spaces and tab in it with underscores.\nConsider a tab as 4 spaces, and if a string has more than 2 consecutive spaces,\nthen replace all consecutive spaces with -",
        "examples": [
          ">>> extended_fix_spaces('Example')\n'Example'",
          ">>> extended_fix_spaces('Example    1')\n'Example-1'",
          ">>> extended_fix_spaces('   Example 2')\n'-Example_2'",
          ">>> extended_fix_spaces(' Example 3')\n'_Example-3'",
          ">>> extended_fix_spaces(' Example   4_')\n'_Example-4_'"
        ]
      },
      "template": "def {{ extended_fix_spaces }}({{ text }}: str) -> str:\n    return {{ fix_spaces }}({{ text }}.replace('\\t', '    '))",
      "placeholders": [
        "text",
        "fix_spaces",
        "extended_fix_spaces"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('\\tcandidate([9, 2, 4, 3, 8, 9])') == '-candidate([9,_2,_4,_3,_8,_9])'\n    assert candidate('cool\\tand aweesome function!') == 'cool-and_aweesome_function!'\n    assert candidate('\\t\\t\\t\\t') == '-'\n\ndef test_check():\n    check(extended_fix_spaces)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "file_name_check",
      "arguments": [
        "file_name"
      ],
      "docstring": {
        "description": "Create a function which takes a string representing a file's name, and returns\n'Yes' if the the file's name is valid, and returns 'No' otherwise.\nA file's name is considered to be valid if and only if all the following conditions\nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot '.'\n- The substring before the dot should not be empty, and it starts with a letter from\nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: ['txt', 'exe', 'dll']",
        "examples": [
          ">>> file_name_check('example.txt')\n'Yes'",
          ">>> file_name_check('1example.dll')\n'No'"
        ]
      },
      "template": "def {{ file_name_check }}({{ file_name }}: str) -> str:\n    {{ suf }} = ['txt', 'exe', 'dll']\n    {{ lst }} = {{ file_name }}.split(sep='.')\n    if len({{ lst }}) != 2:\n        return 'No'\n    if not {{ lst }}[1] in {{ suf }}:\n        return 'No'\n    if len({{ lst }}[0]) == 0:\n        return 'No'\n    if not {{ lst }}[0][0].isalpha():\n        return 'No'\n    {{ t }} = len([{{ x }} for {{ x }} in {{ lst }}[0] if {{ x }}.isdigit()])\n    if {{ t }} > 3:\n        return 'No'\n    return 'Yes'",
      "placeholders": [
        "lst",
        "file_name",
        "x",
        "suf",
        "t",
        "file_name_check"
      ]
    },
    "target_function": {
      "name": "download_link_check",
      "arguments": [
        "link"
      ],
      "docstring": {
        "description": "Create a function which takes a string representing a link address, and returns\n'Yes' if the the link is valid, and returns 'No' otherwise.\nA link name is considered to be valid if and only if all the following conditions\nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot '.'\n- The substring before the dot should not be empty, and it starts with a letter from\nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n- The link should start with 'https://'",
        "examples": [
          ">>> download_link_check('https://example.txt')\n'Yes'",
          ">>> file_name_check('https://1example.dll')\n'No'",
          ">>> file_name_check('example.txt')\n'No'"
        ]
      },
      "template": "def {{ download_link_check }}({{ link }}: str) -> str:\n    if not {{ link }}.startswith('https://'):\n        return 'No'\n    return {{ file_name_check }}({{ link }}[8:])",
      "placeholders": [
        "download_link_check",
        "file_name_check",
        "link"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('https://hello-world.dll') == 'Yes'\n    assert candidate('file://cool010.exe') == 'No'\n    assert candidate('https://0010110.txt') == 'No'\n\ndef test_check():\n    check(download_link_check)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "sum_squares",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "\"\nThis function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\nchange the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.",
        "examples": [
          ">>> sum_squares([1, 2, 3])\n6",
          ">>> sum_squares([])\n0",
          ">>> sum_squares([-1, -5, 2, -1, -5])\n-126"
        ]
      },
      "template": "def {{ sum_squares }}({{ lst }}: list[int]) -> int:\n    {{ result }} = []\n    for {{ i }} in range(len({{ lst }})):\n        if {{ i }} % 3 == 0:\n            {{ result }}.append({{ lst }}[{{ i }}] ** 2)\n        elif {{ i }} % 4 == 0 and {{ i }} % 3 != 0:\n            {{ result }}.append({{ lst }}[{{ i }}] ** 3)\n        else:\n            {{ result }}.append({{ lst }}[{{ i }}])\n    return sum({{ result }})",
      "placeholders": [
        "i",
        "result",
        "lst",
        "sum_squares"
      ]
    },
    "target_function": {
      "name": "extended_sum_squares",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "This function will take a list of integers. For all entries in the list, the\nfunction shall square the integer entry if its index is a multiple of 3 and\nwill cube the integer entry if its index is a multiple of 4 and not a\nmultiple of 3 and negate the integer entry if its index is a multiple of 5\nand not a multiple of 3 and 4. The function will not change the entries in\nthe list whose indexes are not a multiple of 3 or 4 or 5. The function shall\nthen return the sum of all entries.",
        "examples": [
          ">>> sum_squares([1, 2, 3])\n6",
          ">>> sum_squares([])\n0",
          ">>> sum_squares([-1, -5, 2, -1, -5, -6])\n-120"
        ]
      },
      "template": "def {{ extended_sum_squares }}({{ lst }}: list[int]) -> int:\n    return {{ sum_squares }}([-{{ x }} if {{ idx }} % 5 == 0 and {{ idx }} % 4 != 0 and ({{ idx }} % 3 != 0) else {{ x }} for ({{ idx }}, {{ x }}) in enumerate({{ lst }})])",
      "placeholders": [
        "lst",
        "sum_squares",
        "extended_sum_squares",
        "x",
        "idx"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([4, 7, 5, 3, 1, 1, 4, 6, 8, 9, 100]) == 552\n    assert candidate([3, 4, 1, 5, 0, 8, 8, 5]) == 100\n    assert candidate([2, 3, 5, 7, 11, 13, 17, 19]) == 1687\n\ndef test_check():\n    check(extended_sum_squares)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "words_in_sentence",
      "arguments": [
        "sentence"
      ],
      "docstring": {
        "description": "You are given a string representing a sentence,\nthe sentence contains some words separated by a space,\nand you have to return a string that contains the words from the original sentence,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.",
        "examples": [
          ">>> words_in_sentence('This is a test')\n'is'",
          ">>> words_in_sentence('lets go for swimming')\n'go for'"
        ]
      },
      "template": "def {{ words_in_sentence }}({{ sentence }}: str) -> str:\n    {{ new_lst }} = []\n    for {{ word }} in {{ sentence }}.split():\n        {{ flg }} = 0\n        if len({{ word }}) == 1:\n            {{ flg }} = 1\n        for {{ i }} in range(2, len({{ word }})):\n            if len({{ word }}) % {{ i }} == 0:\n                {{ flg }} = 1\n        if {{ flg }} == 0 or len({{ word }}) == 2:\n            {{ new_lst }}.append({{ word }})\n    return ' '.join({{ new_lst }})",
      "placeholders": [
        "new_lst",
        "word",
        "i",
        "flg",
        "sentence",
        "words_in_sentence"
      ]
    },
    "target_function": {
      "name": "extended_words_in_sentence",
      "arguments": [
        "sentence",
        "sep"
      ],
      "docstring": {
        "description": "You are given a string representing a sentence,\nthe sentence contains some words separated by `sep`,\nand you have to return a string that contains the words from the original sentence,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.",
        "examples": [
          ">>> extended_words_in_sentence('This is a test', ' ')\n'is'",
          ">>> extended_words_in_sentence('lets,go,for,swimming', ',')\n'go,for'"
        ]
      },
      "template": "def {{ extended_words_in_sentence }}({{ sentence }}: str, {{ sep }}: str) -> str:\n    return {{ words_in_sentence }}({{ sentence }}.replace({{ sep }}, ' ')).replace(' ', {{ sep }})",
      "placeholders": [
        "words_in_sentence",
        "sentence",
        "extended_words_in_sentence",
        "sep"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('apple|delta|for|much|quantity', '|') == 'apple|delta|for'\n    assert candidate('what-is-your-hobby', '-') == 'is-hobby'\n    assert candidate('your,task,is,to,support,your,colleague', ',') == 'is,to,support'\n\ndef test_check():\n    check(extended_words_in_sentence)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Optional"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "simplify",
      "arguments": [
        "x",
        "n"
      ],
      "docstring": {
        "description": "Your task is to implement a function that will simplify the expression\nx * n. The function returns True if x * n evaluates to a whole number and False\notherwise. Both x and n, are string representation of a fraction, and have the following format,\n<numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\nYou can assume that x, and n are valid fractions, and do not have zero as denominator.",
        "examples": [
          ">>> simplify('1/5', '5/1')\nTrue",
          ">>> simplify('1/6', '2/1')\nFalse",
          ">>> simplify('7/10', '10/2')\nFalse"
        ]
      },
      "template": "def {{ simplify }}({{ x }}: str, {{ n }}: str) -> bool:\n    ({{ a }}, {{ b }}) = {{ x }}.split('/')\n    ({{ c }}, {{ d }}) = {{ n }}.split('/')\n    {{ numerator }} = int({{ a }}) * int({{ c }})\n    {{ denom }} = int({{ b }}) * int({{ d }})\n    if {{ numerator }} / {{ denom }} == int({{ numerator }} / {{ denom }}):\n        return True\n    return False",
      "placeholders": [
        "c",
        "d",
        "simplify",
        "a",
        "x",
        "numerator",
        "denom",
        "n",
        "b"
      ]
    },
    "target_function": {
      "name": "get_simplified_pair",
      "arguments": [
        "l"
      ],
      "docstring": {
        "description": "Find a pair (a, b) which can be simplified in the given list of fractions.\nSimplified means that a * b is a whole number. Both a and b are string representation\nof a fraction, and have the following format, <numerator>/<denominator> where both\nnumerator and denominator are positive whole numbers.\n\nIf there is no such pair, return None.\nIf there is multiple such pair, return the first one.",
        "examples": [
          ">>> get_simplified_pair(['1/5', '5/1', '1/6', '2/1', '7/10', '10/2'])\n('1/5', '5/1')",
          ">>> get_simplified_pair(['1/6', '2/1', '7/10', '10/2'])\n('2/1', '10/2')"
        ]
      },
      "template": "def {{ get_simplified_pair }}({{ l }}: list[str]) -> Optional[tuple[str, str]]:\n    for {{ i }} in range(len({{ l }})):\n        for {{ j }} in range({{ i }} + 1, len({{ l }})):\n            if {{ simplify }}({{ l }}[{{ i }}], {{ l }}[{{ j }}]):\n                return ({{ l }}[{{ i }}], {{ l }}[{{ j }}])\n    return None",
      "placeholders": [
        "i",
        "l",
        "simplify",
        "get_simplified_pair",
        "j"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['3/5', '3/7', '9/3', '7/2']) is None\n    assert candidate(['4/9', '18/1', '7/3']) == ('4/9', '18/1')\n    assert candidate(['11/13', '7/3', '18/14', '4/6']) == ('7/3', '18/14')\n\ndef test_check():\n    check(get_simplified_pair)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "order_by_points",
      "arguments": [
        "nums"
      ],
      "docstring": {
        "description": "Write a function which sorts the given list of integers\nin ascending order according to the sum of their digits.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original list.",
        "examples": [
          ">>> order_by_points([1, 11, -1, -11, -12])\n[-1, -11, 1, -12, 11]",
          ">>> order_by_points([])\n[]"
        ]
      },
      "template": "def {{ order_by_points }}({{ nums }}: list[int]) -> list[int]:\n\n    def {{ digits_sum }}({{ n }}):\n        {{ neg }} = 1\n        if {{ n }} < 0:\n            ({{ n }}, {{ neg }}) = (-1 * {{ n }}, -1)\n        {{ n }} = [int({{ i }}) for {{ i }} in str({{ n }})]\n        {{ n }}[0] = {{ n }}[0] * {{ neg }}\n        return sum({{ n }})\n    return sorted({{ nums }}, key={{ digits_sum }})",
      "placeholders": [
        "digits_sum",
        "i",
        "order_by_points",
        "nums",
        "neg",
        "n"
      ]
    },
    "target_function": {
      "name": "positive_order_by_points",
      "arguments": [
        "nums"
      ],
      "docstring": {
        "description": "Write a function which sorts the integers in the given list\nthat is greater than zero.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original list.",
        "examples": [
          ">>> positive_order_by_points([1, 11, -1, -11, -12])\n[1, 11]",
          ">>> positive_order_by_points([])\n[]"
        ]
      },
      "template": "def {{ positive_order_by_points }}({{ nums }}: list[int]) -> list[int]:\n    return {{ order_by_points }}([{{ num }} for {{ num }} in {{ nums }} if {{ num }} > 0])",
      "placeholders": [
        "nums",
        "order_by_points",
        "positive_order_by_points",
        "num"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([302, 444, 97, 92, 114]) == [302, 114, 92, 444, 97]\n    assert candidate([4932, -30585, -392828, 1128]) == [1128, 4932]\n    assert candidate([85, -7, 877, 344]) == [344, 85, 877]\n\ndef test_check():\n    check(positive_order_by_points)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "specialFilter",
      "arguments": [
        "nums"
      ],
      "docstring": {
        "description": "Write a function that takes an array of numbers as input and returns\nthe number of elements in the array that are greater than 10 and both\nfirst and last digits of a number are odd (1, 3, 5, 7, 9).",
        "examples": [
          ">>> specialFilter([15, -73, 14, -15])\n1",
          ">>> specialFilter([33, -2, -3, 45, 21, 109])\n2"
        ]
      },
      "template": "def {{ specialFilter }}({{ nums }}: list[int]) -> int:\n    {{ count }} = 0\n    for {{ num }} in {{ nums }}:\n        if {{ num }} > 10:\n            {{ odd_digits }} = (1, 3, 5, 7, 9)\n            {{ number_as_string }} = str({{ num }})\n            if int({{ number_as_string }}[0]) in {{ odd_digits }} and int({{ number_as_string }}[-1]) in {{ odd_digits }}:\n                {{ count }} += 1\n    return {{ count }}",
      "placeholders": [
        "specialFilter",
        "num",
        "nums",
        "count",
        "number_as_string",
        "odd_digits"
      ]
    },
    "target_function": {
      "name": "extended_special_filter",
      "arguments": [
        "nums"
      ],
      "docstring": {
        "description": "Write a function that takes an array of numbers as input and returns\nthe number of elements in the array that are greater than 10 and both\nfirst digits of a number are odd (1, 3, 5, 7, 9) and last digits of a number is even.",
        "examples": [
          ">>> specialFilter([15, -73, 14, -15])\n1",
          ">>> specialFilter([33, -2, -3, 45, 21, 109])\n0"
        ]
      },
      "template": "def {{ extended_special_filter }}({{ nums }}: list[int]) -> int:\n    {{ count }} = 0\n    for {{ num }} in {{ nums }}:\n        if {{ num }} > 10:\n            {{ odd_digits }} = (1, 3, 5, 7, 9)\n            {{ even_digits }} = (2, 4, 6, 8, 0)\n            {{ number_as_string }} = str({{ num }})\n            if int({{ number_as_string }}[0]) in {{ odd_digits }} and int({{ number_as_string }}[-1]) in {{ even_digits }}:\n                {{ count }} += 1\n    return {{ count }}",
      "placeholders": [
        "num",
        "nums",
        "count",
        "number_as_string",
        "extended_special_filter",
        "odd_digits",
        "even_digits"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([302, 444, 97, 92, 114]) == 3\n    assert candidate([4932, 30585, 392828, 1128]) == 2\n    assert candidate([66485, 9327, 88757, 344]) == 1\n\ndef test_check():\n    check(extended_special_filter)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "get_max_triples",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\nand a[i] + a[j] + a[k] is a multiple of 3.",
        "examples": [
          ">>> get_max_triples(5)\n1"
        ]
      },
      "template": "def {{ get_max_triples }}({{ n }}: int) -> int:\n    {{ A }} = [{{ i }} * {{ i }} - {{ i }} + 1 for {{ i }} in range(1, {{ n }} + 1)]\n    {{ ans }} = []\n    for {{ i }} in range({{ n }}):\n        for {{ j }} in range({{ i }} + 1, {{ n }}):\n            for {{ k }} in range({{ j }} + 1, {{ n }}):\n                if ({{ A }}[{{ i }}] + {{ A }}[{{ j }}] + {{ A }}[{{ k }}]) % 3 == 0:\n                    {{ ans }} += [({{ A }}[{{ i }}], {{ A }}[{{ j }}], {{ A }}[{{ k }}])]\n    return len({{ ans }})",
      "placeholders": [
        "i",
        "ans",
        "A",
        "k",
        "get_max_triples",
        "n",
        "j"
      ]
    },
    "target_function": {
      "name": "get_not_max_triple",
      "arguments": [
        "n"
      ],
      "docstring": {
        "description": "You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\nand a[i] + a[j] + a[k] is not a multiple of 3.\nAssume that n >= 3.",
        "examples": [
          ">>> get_not_max_triples(5)\n9"
        ]
      },
      "template": "def {{ get_not_max_triple }}({{ n }}: int) -> int:\n    return {{ n }} * ({{ n }} - 1) * ({{ n }} - 2) // 6 - {{ get_max_triples }}({{ n }})",
      "placeholders": [
        "get_max_triples",
        "n",
        "get_not_max_triple"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(8) == 45\n    assert candidate(13) == 198\n    assert candidate(16) == 385\n\ndef test_check():\n    check(get_not_max_triple)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "bf",
      "arguments": [
        "planet1",
        "planet2"
      ],
      "docstring": {
        "description": "There are eight planets in our solar system: the closerst to the Sun\nis Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\nUranus, Neptune.\nWrite a function that takes two planet names as strings planet1 and planet2.\nThe function should return a tuple containing all planets whose orbits are\nlocated between the orbit of planet1 and the orbit of planet2, sorted by\nthe proximity to the sun.\nThe function should return an empty tuple if planet1 or planet2\nare not correct planet names.",
        "examples": [
          ">>> bf('Jupiter', 'Neptune')\n('Saturn', 'Uranus')",
          ">>> bf('Earth', 'Mercury')\n'Venus'",
          ">>> bf('Mercury', 'Uranus')\n('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')"
        ]
      },
      "template": "def {{ bf }}({{ planet1 }}: str, {{ planet2 }}: str) -> Tuple[str, ...]:\n    {{ planet_names }} = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n    if {{ planet1 }} not in {{ planet_names }} or {{ planet2 }} not in {{ planet_names }} or {{ planet1 }} == {{ planet2 }}:\n        return ()\n    {{ planet1_index }} = {{ planet_names }}.index({{ planet1 }})\n    {{ planet2_index }} = {{ planet_names }}.index({{ planet2 }})\n    if {{ planet1_index }} < {{ planet2_index }}:\n        return {{ planet_names }}[{{ planet1_index }} + 1:{{ planet2_index }}]\n    else:\n        return {{ planet_names }}[{{ planet2_index }} + 1:{{ planet1_index }}]",
      "placeholders": [
        "planet1",
        "planet_names",
        "planet2",
        "bf",
        "planet2_index",
        "planet1_index"
      ]
    },
    "target_function": {
      "name": "living_area",
      "arguments": [
        "planet1",
        "planet2"
      ],
      "docstring": {
        "description": "There are eight planets in our solar system: the closerst to the Sun\nis Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\nUranus, Neptune.\nAmong this planets, Earth is the only planet that can live human.\nYour task is to check whether there is a planet that can live human\nbetween planet1 and planet2 exclusively.\nReturn true if there is a planet that can live human between planet1 and planet2.",
        "examples": [
          ">>> living_area('Jupiter', 'Neptune')\nFalse",
          ">>> living_area('Earth', 'Mercury')\nFalse",
          ">>> living_area('Mercury', 'Uranus')\nTrue"
        ]
      },
      "template": "def {{ living_area }}({{ planet1 }}: str, {{ planet2 }}: str) -> bool:\n    return 'Earth' in {{ bf }}({{ planet1 }}, {{ planet2 }})",
      "placeholders": [
        "living_area",
        "planet1",
        "planet2",
        "bf"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('Venus', 'Jupiter') is True\n    assert candidate('Uranus', 'Mars') is False\n    assert candidate('Mars', 'Mercury') is True\n\ndef test_check():\n    check(living_area)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "List"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "sorted_list_sum",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Write a function that accepts a list of strings as a parameter,\ndeletes the strings that have odd lengths from it,\nand returns the resulted list with a sorted order,\nThe list is always a list of strings and never an array of numbers,\nand it may contain duplicates.\nThe order of the list should be ascending by length of each word, and you\nshould return the list sorted by that rule.\nIf two words have the same length, sort the list alphabetically.\nThe function should return a list of strings in sorted order.\nYou may assume that all words will have the same length.",
        "examples": [
          ">>> list_sort(['aa', 'a', 'aaa'])\n['aa']",
          ">>> list_sort(['ab', 'a', 'aaa', 'cd'])\n['ab', 'cd']"
        ]
      },
      "template": "def {{ sorted_list_sum }}({{ lst }}: List[str]) -> List[str]:\n    {{ lst }}.sort()\n    {{ new_lst }} = []\n    for {{ i }} in {{ lst }}:\n        if len({{ i }}) % 2 == 0:\n            {{ new_lst }}.append({{ i }})\n    return sorted({{ new_lst }}, key=len)",
      "placeholders": [
        "new_lst",
        "sorted_list_sum",
        "i",
        "lst"
      ]
    },
    "target_function": {
      "name": "extract_even_words",
      "arguments": [
        "text"
      ],
      "docstring": {
        "description": "Write a function that accepts a string as a parameter, and a string\nis consisted of words separated by spaces, deletes the words that have\nodd lengths from it, and returns the resulted string with a sorted order,\nThe order of the words should be ascending by length of each word, and you\nshould return the string sorted by that rule.\nIF two words have the same length, sort the string alphabetically.",
        "examples": [
          ">>> extract_odd_words('aa a aaa')\n'aa'",
          ">>> extract_odd_words('ab a aaa cd')\n'ab cd'"
        ]
      },
      "template": "def {{ extract_even_words }}({{ text }}: str) -> str:\n    return ' '.join({{ sorted_list_sum }}({{ text }}.split()))",
      "placeholders": [
        "sorted_list_sum",
        "text",
        "extract_even_words"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('apple sand pear black cheeze') == 'pear sand cheeze'\n    assert candidate('answer python analysis task mirror') == 'task answer mirror python analysis'\n    assert candidate('hand monitor cream tissue water') == 'hand tissue'\n\ndef test_check():\n    check(extract_even_words)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "x_or_y",
      "arguments": [
        "n",
        "x",
        "y"
      ],
      "docstring": {
        "description": "A simple program which should return the value of x if n is\na prime number and should return the value of y otherwise.",
        "examples": [
          ">>> x_or_y(7, 34, 12)\n34",
          ">>> x_or_y(15, 8, 5)\n5"
        ]
      },
      "template": "def {{ x_or_y }}({{ n }}: int, {{ x }}: int, {{ y }}: int) -> int:\n    if {{ n }} == 1:\n        return {{ y }}\n    for {{ i }} in range(2, {{ n }}):\n        if {{ n }} % {{ i }} == 0:\n            return {{ y }}\n    else:\n        return {{ x }}",
      "placeholders": [
        "i",
        "x",
        "x_or_y",
        "y",
        "n"
      ]
    },
    "target_function": {
      "name": "list_x_or_y",
      "arguments": [
        "ns",
        "xs",
        "ys"
      ],
      "docstring": {
        "description": "A simple program which should return a list of values of x if the\ncorresponding value in ns is a prime number and should return the value of y\notherwise.",
        "examples": [
          ">>> list_x_or_by([7, 15, 21], [34, 8, 3], [12, 5, 7])\n[34, 5, 7]",
          ">>> list_x_or_by([1, 2, 3], [34, 8, 3], [12, 5, 7])\n[12, 8, 3]"
        ]
      },
      "template": "def {{ list_x_or_y }}({{ ns }}: list[int], {{ xs }}: list[int], {{ ys }}: list[int]) -> list[int]:\n    return [{{ x_or_y }}({{ n }}, {{ x }}, {{ y }}) for ({{ n }}, {{ x }}, {{ y }}) in zip({{ ns }}, {{ xs }}, {{ ys }})]",
      "placeholders": [
        "xs",
        "x",
        "ns",
        "list_x_or_y",
        "x_or_y",
        "y",
        "n",
        "ys"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([9, 5, 13, 7, 15, 33], [3, 4, 6, 2, 6, 4], [2, 3, 7, 2, 4, 3]) == [2, 4, 6, 2, 4, 3]\n    assert candidate([44, 43, 42, 41, 40], [9, 3, 5, 3, 2], [8, 7, 6, 5, 4]) == [8, 3, 6, 3, 4]\n    assert candidate([95, 97, 45, 39], [11, 4, 38, 2], [10, 1, 4, 9]) == [10, 4, 4, 9]\n\ndef test_check():\n    check(list_x_or_y)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "double_the_difference",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a list of numbers, return the sum of squares of the numbers\nin the list that are odd. Ignore numbers that are negative or not integers.",
        "examples": [
          ">>> double_the_difference([1, 3, 2, 0])\n10",
          ">>> double_the_difference([-1, -2, 0])\n0",
          ">>> double_the_difference([9, -2])\n81",
          ">>> double_the_difference([0])\n0"
        ]
      },
      "template": "def {{ double_the_difference }}({{ lst }}: list[float]) -> int:\n    return sum([{{ i }} ** 2 for {{ i }} in {{ lst }} if {{ i }} > 0 and {{ i }} % 2 != 0 and ('.' not in str({{ i }}))])",
      "placeholders": [
        "i",
        "double_the_difference",
        "lst"
      ]
    },
    "target_function": {
      "name": "extended_double_the_difference",
      "arguments": [
        "lst"
      ],
      "docstring": {
        "description": "Given a list of numbers, return the sum of squares of the numbers\nin the list that are odd and the cubic of the number in the list that\nare even. Ignore numbers that are negative or not integers.",
        "examples": [
          ">>> double_the_difference([1, 3, 2, 0])\n18",
          ">>> double_the_difference([-1, -2, 0])\n0",
          ">>> double_the_difference([9, -2])\n81",
          ">>> double_the_difference([0])\n0"
        ]
      },
      "template": "def {{ extended_double_the_difference }}({{ lst }}: list[float]) -> int:\n    {{ x }} = {{ double_the_difference }}({{ lst }})\n    {{ x }} += sum(({{ i }} ** 3 for {{ i }} in {{ lst }} if {{ i }} > 0 and {{ i }} % 2 == 0 and ('.' not in str({{ i }}))))\n    return {{ x }}",
      "placeholders": [
        "lst",
        "i",
        "x",
        "extended_double_the_difference",
        "double_the_difference"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([-1, 9, -5, 5, 13, 7, 0, 15]) == 549\n    assert candidate([-5, -2, 7, 2, 1]) == 58\n    assert candidate([3, 4, 5, 6, 7]) == 363\n\ndef test_check():\n    check(extended_double_the_difference)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "compare",
      "arguments": [
        "game",
        "guess"
      ],
      "docstring": {
        "description": "I think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two arrays of scores and guesses of equal length, where each index shows a match.\nReturn an array of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.",
        "examples": [
          ">>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n[0, 0, 0, 0, 3, 3]",
          ">>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n[4, 4, 1, 0, 0, 6]"
        ]
      },
      "template": "def {{ compare }}({{ game }}: list[int], {{ guess }}: list[int]) -> list[int]:\n    return [abs({{ x }} - {{ y }}) for ({{ x }}, {{ y }}) in zip({{ game }}, {{ guess }})]",
      "placeholders": [
        "x",
        "compare",
        "guess",
        "y",
        "game"
      ]
    },
    "target_function": {
      "name": "who_is_winner",
      "arguments": [
        "game",
        "guesses"
      ],
      "docstring": {
        "description": "Return the index of guesses that is the most closely guess the game.\nIf there is a tie, return the index of the first guess that is the most\nclosely guess the game.",
        "examples": [
          ">>> who_is_winner([1, 2, 3], [[2, 0, 3], [1, 2, 3]])\n1",
          ">>> who_is_winner([1, 2, 3], [[2, 0, 3], [4, 5, 6]])\n0"
        ]
      },
      "template": "def {{ who_is_winner }}({{ game }}: list[int], {{ guesses }}: list[list[int]]) -> int:\n    return min(range(len({{ guesses }})), key=lambda i: sum({{ compare }}({{ game }}, {{ guesses }}[{{ i }}])))",
      "placeholders": [
        "i",
        "who_is_winner",
        "compare",
        "game",
        "guesses"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([3, 9], [[1, 2], [3, 0], [0, 9]]) == 2\n    assert candidate([3, 3], [[3, 0], [0, 3]]) == 0\n    assert candidate([4, 2, 8], [[0, 3, 5], [5, 0, 7], [1, 2, 9]]) == 1\n\ndef test_check():\n    check(who_is_winner)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "Strongest_Extension",
      "arguments": [
        "class_name",
        "extensions"
      ],
      "docstring": {
        "description": "You will be given the name of a class (a string) and a list of extensions.\nThe extensions are to be used to load additional classes to the class. The\nstrength of the extension is as follows: Let CAP be the number of the uppercase\nletters in the extension's name, and let SM be the number of lowercase letters\nin the extension's name, the strength is given by the fraction CAP - SM.\nYou should find the strongest extension and return a string in this\nformat: ClassName.StrongestExtensionName.\nIf there are two or more extensions with the same strength, you should\nchoose the one that comes first in the list.\nFor example, if you are given \"Slices\" as the class and a list of the\nextensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\nreturn 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n(its strength is -1).",
        "examples": [
          ">>> Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n'my_class.AA'"
        ]
      },
      "template": "def {{ Strongest_Extension }}({{ class_name }}: str, {{ extensions }}: list[str]) -> str:\n    {{ strong }} = {{ extensions }}[0]\n    {{ my_val }} = len([{{ x }} for {{ x }} in {{ extensions }}[0] if {{ x }}.isalpha() and {{ x }}.isupper()]) - len([{{ x }} for {{ x }} in {{ extensions }}[0] if {{ x }}.isalpha() and {{ x }}.islower()])\n    for {{ s }} in {{ extensions }}:\n        {{ val }} = len([{{ x }} for {{ x }} in {{ s }} if {{ x }}.isalpha() and {{ x }}.isupper()]) - len([{{ x }} for {{ x }} in {{ s }} if {{ x }}.isalpha() and {{ x }}.islower()])\n        if {{ val }} > {{ my_val }}:\n            {{ strong }} = {{ s }}\n            {{ my_val }} = {{ val }}\n    {{ ans }} = {{ class_name }} + '.' + {{ strong }}\n    return {{ ans }}",
      "placeholders": [
        "extensions",
        "val",
        "class_name",
        "ans",
        "s",
        "strong",
        "x",
        "Strongest_Extension",
        "my_val"
      ]
    },
    "target_function": {
      "name": "extended_strongest_extension",
      "arguments": [
        "extensions"
      ],
      "docstring": {
        "description": "You will be given a list of extensions. These extensions consist of package name and\nfunction name such as `package1.function1`.\nThe strength of the extension is as follows: Let CAP be the number of the uppercase\nletters in the function's name, and let SM be the number of lowercase letters\nin the function's name, the strength is given by the fraction CAP - SM.\nYou should find the strongest functions and return a dictionary which has package name as key\nand the strongest extension as value in this format: `package1.function1`.\nIf there are two or more extensions with the same strength in the same package, you should\nchoose the one that comes first in the list.",
        "examples": [
          ">>> extended_strongest_extension(['my_class.AA', 'my_class.Be', 'my_class2.Be', 'my_class2.CC'])\n{'my_class': 'my_class.AA', 'my_class2': 'my_class2.CC'}"
        ]
      },
      "template": "def {{ extended_strongest_extension }}({{ extensions }}: list[str]) -> str:\n    {{ result }} = {}\n    for {{ extension }} in {{ extensions }}:\n        ({{ package }}, {{ function }}) = {{ extension }}.split('.')\n        if {{ package }} not in {{ result }}:\n            {{ result }}[{{ package }}] = [{{ function }}]\n        else:\n            {{ result }}[{{ package }}].append({{ function }})\n    for {{ package }} in {{ result }}:\n        {{ result }}[{{ package }}] = {{ Strongest_Extension }}({{ package }}, {{ result }}[{{ package }}])\n    return {{ result }}",
      "placeholders": [
        "extensions",
        "package",
        "Strongest_Extension",
        "result",
        "extended_strongest_extension",
        "function",
        "extension"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['pack1.func1', 'pack1.Func1', 'pack1.FunC1']) == {'pack1': 'pack1.FunC1'}\n    assert candidate(['math.MIN', 'math.MAX', 'abc.abstractmethod']) == {'math': 'math.MIN', 'abc': 'abc.abstractmethod'}\n    assert candidate(['mirror.iSNa', 'category.FUNC', 'mirror.IsnA']) == {'mirror': 'mirror.iSNa', 'category': 'category.FUNC'}\n\ndef test_check():\n    check(extended_strongest_extension)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "cycpattern_check",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "You are given 2 words. You need to return True if the second word or any\nof its rotations is a substring in the first word",
        "examples": [
          ">>> cycpattern_check('abcd', 'abd')\nFalse",
          ">>> cycpattern_check('hello', 'ell')\nTrue",
          ">>> cycpattern_check('whassup', 'psus')\nFalse",
          ">>> cycpattern_check('abab', 'baa')\nTrue",
          ">>> cycpattern_check('efef', 'eeff')\nFalse",
          ">>> cycpattern_check('himenss', 'simen')\nTrue"
        ]
      },
      "template": "def {{ cycpattern_check }}({{ a }}: str, {{ b }}: str) -> bool:\n    {{ l }} = len({{ b }})\n    {{ pat }} = {{ b }} + {{ b }}\n    for {{ i }} in range(len({{ a }}) - {{ l }} + 1):\n        for {{ j }} in range({{ l }} + 1):\n            if {{ a }}[{{ i }}:{{ i }} + {{ l }}] == {{ pat }}[{{ j }}:{{ j }} + {{ l }}]:\n                return True\n    return False",
      "placeholders": [
        "l",
        "i",
        "a",
        "cycpattern_check",
        "b",
        "pat",
        "j"
      ]
    },
    "target_function": {
      "name": "extended_cycpattern_check",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "You are given 2 words. You need to return True if the second word or any\nof its rotations is a substring in the first word or any of its rotations",
        "examples": [
          ">>> cycpattern_check('abcd', 'abd')\nTrue",
          ">>> cycpattern_check('hello', 'ell')\nTrue",
          ">>> cycpattern_check('whassup', 'psus')\nFalse",
          ">>> cycpattern_check('abab', 'baa')\nTrue",
          ">>> cycpattern_check('efeff', 'eeff')\nTrue",
          ">>> cycpattern_check('himenss', 'simen')\nTrue"
        ]
      },
      "template": "def {{ extended_cycpattern_check }}({{ a }}: str, {{ b }}: str) -> bool:\n    return any(({{ cycpattern_check }}({{ a }}[{{ i }}:] + {{ a }}[:{{ i }}], {{ b }}) for {{ i }} in range(len({{ a }}))))",
      "placeholders": [
        "i",
        "a",
        "cycpattern_check",
        "extended_cycpattern_check",
        "b"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('oossiie', 'iso') is False\n    assert candidate('rikkenwhwiejf', 'friwiej') is True\n    assert candidate('whatemfho', 'howhat') is True\n\ndef test_check():\n    check(extended_cycpattern_check)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Tuple"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "even_odd_count",
      "arguments": [
        "num"
      ],
      "docstring": {
        "description": "Given an integer. return a tuple that has the number of even and odd digits respectively.",
        "examples": [
          ">>> even_odd_count(-12)\n(1, 1)",
          ">>> even_odd_count(123)\n(1, 2)"
        ]
      },
      "template": "def {{ even_odd_count }}({{ num }}: int) -> Tuple[int, int]:\n    {{ even_count }} = 0\n    {{ odd_count }} = 0\n    for {{ i }} in str(abs({{ num }})):\n        if int({{ i }}) % 2 == 0:\n            {{ even_count }} += 1\n        else:\n            {{ odd_count }} += 1\n    return ({{ even_count }}, {{ odd_count }})",
      "placeholders": [
        "even_count",
        "odd_count",
        "i",
        "num",
        "even_odd_count"
      ]
    },
    "target_function": {
      "name": "balanced_number",
      "arguments": [
        "num"
      ],
      "docstring": {
        "description": "Given an integer. return True if the number of even digits and odd digits\nare the same.",
        "examples": [
          ">>> balanced_number(1324)\nTrue",
          ">>> balanced_number(9119)\nFalse"
        ]
      },
      "template": "def {{ balanced_number }}({{ num }}: int) -> bool:\n    ({{ even_count }}, {{ odd_count }}) = {{ even_odd_count }}({{ num }})\n    return {{ even_count }} == {{ odd_count }}",
      "placeholders": [
        "even_count",
        "odd_count",
        "balanced_number",
        "num",
        "even_odd_count"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(1234) is True\n    assert candidate(12345) is False\n    assert candidate(10) is True\n\ndef test_check():\n    check(balanced_number)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "int_to_mini_roman",
      "arguments": [
        "number"
      ],
      "docstring": {
        "description": "Given a positive integer, obtain its roman numeral equivalent as a string,\nand return it in lowercase.\nRestrictions: 1 <= num <= 1000",
        "examples": [
          ">>> int_to_mini_roman(19)\n'xix'",
          ">>> int_to_mini_roman(152)\n'clii'",
          ">>> int_to_mini_roman(426)\n'cdxxvi'"
        ]
      },
      "template": "def {{ int_to_mini_roman }}({{ number }}: int) -> str:\n    {{ num }} = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    {{ sym }} = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M']\n    {{ i }} = 12\n    {{ res }} = ''\n    while {{ number }}:\n        {{ div }} = {{ number }} // {{ num }}[{{ i }}]\n        {{ number }} %= {{ num }}[{{ i }}]\n        while {{ div }}:\n            {{ res }} += {{ sym }}[{{ i }}]\n            {{ div }} -= 1\n        {{ i }} -= 1\n    return {{ res }}.lower()",
      "placeholders": [
        "div",
        "res",
        "i",
        "number",
        "num",
        "sym",
        "int_to_mini_roman"
      ]
    },
    "target_function": {
      "name": "beautiful_roman_number",
      "arguments": [
        "number"
      ],
      "docstring": {
        "description": "Check if a given number is a beautiful roman number.\nA roman number is beautiful if it is a palindrome and its length is greater than 1.\nRestrictions: 1 <= a * b <= 1000",
        "examples": [
          ">>> beautiful_roman_number(2)\nTrue",
          ">>> beautiful_roman_number(4)\nFalse",
          ">>> beautiful_roman_number(19)\nTrue"
        ]
      },
      "template": "def {{ beautiful_roman_number }}({{ number }}: int) -> bool:\n    {{ x }} = {{ int_to_mini_roman }}({{ number }})\n    return {{ x }} == {{ x }}[::-1] and len({{ x }}) > 1",
      "placeholders": [
        "beautiful_roman_number",
        "x",
        "int_to_mini_roman",
        "number"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(30) is True\n    assert candidate(190) is True\n    assert candidate(450) is False\n\ndef test_check():\n    check(beautiful_roman_number)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "right_angle_triangle",
      "arguments": [
        "a",
        "b",
        "c"
      ],
      "docstring": {
        "description": "Given the lengths of the three sides of a triangle. Return True if the three\nsides form a right-angled triangle, False otherwise.\nA right-angled triangle is a triangle in which one angle is right angle or\n90 degree.",
        "examples": [
          ">>> right_angle_triangle(3, 4, 5)\nTrue",
          ">>> right_angle_triangle(1, 2, 3)\nFalse"
        ]
      },
      "template": "def {{ right_angle_triangle }}({{ a }}: int, {{ b }}: int, {{ c }}: int) -> bool:\n    return {{ a }} * {{ a }} == {{ b }} * {{ b }} + {{ c }} * {{ c }} or {{ b }} * {{ b }} == {{ a }} * {{ a }} + {{ c }} * {{ c }} or {{ c }} * {{ c }} == {{ a }} * {{ a }} + {{ b }} * {{ b }}",
      "placeholders": [
        "a",
        "c",
        "right_angle_triangle",
        "b"
      ]
    },
    "target_function": {
      "name": "make_right_angle_triangle",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Given the lengths of two sides of a triangle, return the integer length of\nthe third side if the three sides form a right-angled triangle, -1 otherwise.\nAll sides of the triangle could not exceed 1000.\nIf there is more than one possible value, return the smallest one.\nA right-angled triangle is a triangle in which one angle is right angle or\n90 degree.",
        "examples": [
          ">>> make_right_angle_triangle(3, 4)\n5",
          ">>> make_right_angle_triangle(1, 2)\n-1"
        ]
      },
      "template": "def {{ make_right_angle_triangle }}({{ a }}: int, {{ b }}: int) -> int:\n    if 1 <= {{ a }} <= 1000 and 1 <= {{ b }} <= 1000:\n        for {{ c }} in range(1, 1000):\n            if {{ right_angle_triangle }}({{ a }}, {{ b }}, {{ c }}):\n                return {{ c }}\n    return -1",
      "placeholders": [
        "c",
        "a",
        "b",
        "make_right_angle_triangle",
        "right_angle_triangle"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(6, 10) == 8\n    assert candidate(13, 5) == 12\n    assert candidate(5, 11) == -1\n\ndef test_check():\n    check(make_right_angle_triangle)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "find_max",
      "arguments": [
        "words"
      ],
      "docstring": {
        "description": "Write a function that accepts a list of strings.\nThe list contains different words. Return the word with maximum number\nof unique characters. If multiple strings have maximum number of unique\ncharacters, return the one which comes first in lexicographical order.",
        "examples": [
          ">>> find_max(['name', 'of', 'string'])\n'string'",
          ">>> find_max(['name', 'enam', 'game'])\n'enam'",
          ">>> find_max(['aaaaaaa', 'bb', 'cc'])\n'aaaaaaa'"
        ]
      },
      "template": "def {{ find_max }}({{ words }}: list[str]) -> str:\n    return sorted({{ words }}, key=lambda x: (-len(set({{ x }})), {{ x }}))[0]",
      "placeholders": [
        "words",
        "find_max",
        "x"
      ]
    },
    "target_function": {
      "name": "contain_complicated_words",
      "arguments": [
        "words"
      ],
      "docstring": {
        "description": "Check if the given list of words contains complicated words.\ncomplicated words means the word contains more than 5 unique characters.\nReturn the index of the most complicated word in words and -1 if there\ndoesn't exist complicated word.\nIf there are multiple the most complicated words, return the index of\nthe first complicated word in lexicographical order.",
        "examples": [
          ">>> contain_complicated_words(['name', 'of', 'string'])\n2",
          ">>> contain_complicated_words(['name', 'enam', 'game'])\n-1",
          ">>> contain_complicated_words(['aaaaaaa', 'bb', 'cc'])\n-1"
        ]
      },
      "template": "def {{ contain_complicated_words }}({{ words }}: list[str]) -> int:\n    {{ word }} = {{ find_max }}({{ words }})\n    if len(set({{ word }})) > 5:\n        return {{ words }}.index({{ word }})\n    else:\n        return -1",
      "placeholders": [
        "find_max",
        "contain_complicated_words",
        "words",
        "word"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['analysis', 'cheeze', 'accept', 'centered']) == 0\n    assert candidate(['pee', 'sat', 'erase']) == -1\n    assert candidate(['eeeeeeee', 'wwwwseeeeew', 'wwwwwzxdef']) == 2\n\ndef test_check():\n    check(contain_complicated_words)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "eat",
      "arguments": [
        "number",
        "need",
        "remaining"
      ],
      "docstring": {
        "description": "You're a hungry rabbit, and you already have eaten a certain number of carrots,\nbut now you need to eat more carrots to complete the day's meals.\nyou should return an array of [ total number of eaten carrots after your meals,\n                                the number of carrots left after your meals ]\nif there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.",
        "examples": [
          ">>> eat(5, 6, 10)\n[11, 4]",
          ">>> eat(4, 8, 9)\n[12, 1]",
          ">>> eat(1, 10, 10)\n[11, 0]",
          ">>> eat(2, 11, 5)\n[7, 0]"
        ]
      },
      "template": "def {{ eat }}({{ number }}: int, {{ need }}: int, {{ remaining }}: int) -> list[int]:\n    if {{ need }} <= {{ remaining }}:\n        return [{{ number }} + {{ need }}, {{ remaining }} - {{ need }}]\n    else:\n        return [{{ number }} + {{ remaining }}, 0]",
      "placeholders": [
        "need",
        "eat",
        "remaining",
        "number"
      ]
    },
    "target_function": {
      "name": "eat_days",
      "arguments": [
        "numbers",
        "need",
        "remaining"
      ],
      "docstring": {
        "description": "You're a hungry rabbit, and every you already have eaten a certain number\nof carrots in your friend's house, but now you need to eat more carrots to\ncomplete the day's meals.\nyou should return an array of [\n    total number of eaten carrots after a couple of days,\n    the number of remaining carrots in a stock after a couple of days ]\nif there are not enough remaining carrots, you will eat all remaining carrots,\nand sleep in a hunger status. (you will not eat more carrots in the next day)",
        "examples": [
          ">>> eat_week([3, 7, 4, 6, 5, 2, 9], 7, 10)\n[50, 0]"
        ]
      },
      "template": "def {{ eat_days }}({{ numbers }}: list[int], {{ need }}: int, {{ remaining }}: int) -> list[int]:\n    ({{ ans1 }}, {{ ans2 }}) = (0, {{ remaining }})\n    for {{ number }} in {{ numbers }}:\n        ({{ x1 }}, {{ ans2 }}) = {{ eat }}({{ number }}, max({{ need }} - {{ number }}, 0), {{ ans2 }})\n        {{ ans1 }} += {{ x1 }}\n    return [{{ ans1 }}, {{ ans2 }}]",
      "placeholders": [
        "need",
        "eat_days",
        "number",
        "numbers",
        "ans2",
        "x1",
        "eat",
        "remaining",
        "ans1"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate([3, 5, 4, 5], 5, 10) == [20, 7]\n    assert candidate([1, 2, 1, 2], 4, 5) == [11, 0]\n    assert candidate([3, 5], 4, 2) == [9, 1]\n\ndef test_check():\n    check(eat_days)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "do_algebra",
      "arguments": [
        "operator",
        "operand"
      ],
      "docstring": {
        "description": "Given two lists operator, and operand. The first list has basic algebra operations, and\nthe second list is a list of integers. Use the two given lists to build the algebric\nexpression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + )\nSubtraction ( - )\nMultiplication ( * )\nFloor division ( // )\nExponentiation ( ** )\n\nExample:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\n    The length of operator list is equal to the length of operand list minus one.\n    Operand is a list of of non-negative integers.\n    Operator list has at least one operator, and operand list has at least two operands.",
        "examples": []
      },
      "template": "def {{ do_algebra }}({{ operator }}: list[str], {{ operand }}: list[int]) -> int:\n    {{ expression }} = str({{ operand }}[0])\n    for ({{ oprt }}, {{ oprn }}) in zip({{ operator }}, {{ operand }}[1:]):\n        {{ expression }} += {{ oprt }} + str({{ oprn }})\n    return eval({{ expression }})",
      "placeholders": [
        "expression",
        "oprt",
        "operand",
        "oprn",
        "operator",
        "do_algebra"
      ]
    },
    "target_function": {
      "name": "do_algebra_sequentially",
      "arguments": [
        "operator",
        "operand"
      ],
      "docstring": {
        "description": "Given two lists operator, and operand. The first list has basic algebra operations, and\nthe second list is a list of integers. Use the two given lists to build the algebric\nexpression and return the evaluation of this expression. Note that the operator is applied\nsequentially from left to right.\n\nThe basic algebra operations:\nAddition ( + )\nSubtraction ( - )\nMultiplication ( * )\nFloor division ( // )\nExponentiation ( ** )\n\nExample:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = (((2 + 3) * 4) - 5)\n=> result = 15\n\nNote:\n    The length of operator list is equal to the length of operand list minus one.\n    Operand is a list of of non-negative integers.\n    Operator list has at least one operator, and operand list has at least two operands.",
        "examples": []
      },
      "template": "def {{ do_algebra_sequentially }}({{ operator }}: list, {{ operand }}: list) -> list[int]:\n    {{ val }} = {{ operand }}[0]\n    for ({{ op }}, {{ val2 }}) in zip({{ operator }}, {{ operand }}[1:]):\n        {{ val }} = {{ do_algebra }}([{{ op }}], [{{ val }}, {{ val2 }}])\n    return {{ val }}",
      "placeholders": [
        "val",
        "op",
        "operand",
        "do_algebra_sequentially",
        "operator",
        "do_algebra",
        "val2"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(['-', '*', '+'], [3, 1, 4, 5]) == 13\n    assert candidate(['-', '-', '//', '+'], [9, 3, 2, 3, 5]) == 6\n    assert candidate(['*', '+'], [3, 5, 7]) == 22\n\ndef test_check():\n    check(do_algebra_sequentially)\n\ntest_check()"
  },
  {
    "imports": [
      [
        "typing",
        [
          "Optional"
        ]
      ]
    ],
    "auxiliary_function": {
      "name": "string_to_md5",
      "arguments": [
        "text"
      ],
      "docstring": {
        "description": "Given a string 'text', return its md5 hash equivalent string.\nIf 'text' is an empty string, return None.",
        "examples": [
          ">>> string_to_md5('Hello world')\n'3e25960a79dbc69b674cd4ec67a72c62'"
        ]
      },
      "template": "def {{ string_to_md5 }}({{ text }}: str) -> Optional[str]:\n    import hashlib\n    return hashlib.md5({{ text }}.encode('ascii')).hexdigest() if {{ text }} else None",
      "placeholders": [
        "text",
        "string_to_md5"
      ]
    },
    "target_function": {
      "name": "match_password",
      "arguments": [
        "password",
        "h"
      ],
      "docstring": {
        "description": "Given a string 'password' and its md5 hash equivalent string 'h',\nreturn True if 'password' is the original string, otherwise return False.\nif 'password' is an empty string, return False.",
        "examples": [
          ">>> match_password('Hello world', '3e25960a79dbc69b674cd4ec67a72c62')\nTrue",
          ">>> match_password('Hello world', '3e25960a79dbc69b674cd4ec67a73c62')\nFalse"
        ]
      },
      "template": "def {{ match_password }}({{ password }}: str, {{ h }}: str) -> bool:\n    return {{ string_to_md5 }}({{ password }}) == {{ h }} if len({{ password }}) > 0 else False",
      "placeholders": [
        "password",
        "h",
        "match_password",
        "string_to_md5"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate('this is password', '8910e62fae2505e21f568632df8410a9') is True\n    assert candidate('this was password', '8910e62fae2505e21f568632df8410a9') is False\n    assert candidate('', '8910e62fae2505e21f568632df8410a9') is False\n\ndef test_check():\n    check(match_password)\n\ntest_check()"
  },
  {
    "imports": [],
    "auxiliary_function": {
      "name": "generate_integers",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Given two positive integers a and b, return the even digits between a\nand b, in ascending order.",
        "examples": [
          ">>> generate_integers(2, 8)\n[2, 4, 6, 8]",
          ">>> generate_integers(8, 2)\n[2, 4, 6, 8]",
          ">>> generate_integers(10, 14)\n[]"
        ]
      },
      "template": "def {{ generate_integers }}({{ a }}: int, {{ b }}: int) -> list[int]:\n    {{ lower }} = max(2, min({{ a }}, {{ b }}))\n    {{ upper }} = min(8, max({{ a }}, {{ b }}))\n    return [{{ i }} for {{ i }} in range({{ lower }}, {{ upper }} + 1) if {{ i }} % 2 == 0]",
      "placeholders": [
        "generate_integers",
        "upper",
        "i",
        "a",
        "b",
        "lower"
      ]
    },
    "target_function": {
      "name": "sum_of_even_digits",
      "arguments": [
        "a",
        "b"
      ],
      "docstring": {
        "description": "Given two positive integers a and b, return the sum of the even digits\nbetween a and b, inclusive.",
        "examples": [
          ">>> sum_of_even_digits(2, 8)\n20",
          ">>> sum_of_even_digits(8, 2)\n20",
          ">>> sum_of_even_digits(10, 14)\n0"
        ]
      },
      "template": "def {{ sum_of_even_digits }}({{ a }}: int, {{ b }}: int) -> int:\n    return sum({{ generate_integers }}({{ a }}, {{ b }}))",
      "placeholders": [
        "sum_of_even_digits",
        "a",
        "generate_integers",
        "b"
      ]
    },
    "tests": "def check(candidate):\n    assert candidate(7, 3) == 10\n    assert candidate(10, 1) == 20\n    assert candidate(6, 6) == 6\n\ndef test_check():\n    check(sum_of_even_digits)\n\ntest_check()"
  }
]
